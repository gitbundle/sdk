/* tslint:disable */
/* eslint-disable */
/**
 * GitBundle API
 * GitBundle API documentation.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ActionCreateInput {
    'description': string;
    'disabled': boolean;
    'identifier': string;
    'yaml_path': string;
}
export interface ActionModel {
    'created': number;
    'created_by': number;
    'description': string;
    'disabled': boolean;
    'event'?: TriggerEvent | null;
    'id': number;
    'name': string;
    'repo_id': number;
    'seq': number;
    'updated': number;
    'version': number;
    'yaml_path': string;
    'yaml_provider': YamlProvider;
}


export interface ActionUpdateInput {
    'description'?: string | null;
    'disabled'?: boolean | null;
    'identifier'?: string | null;
    'yaml_path'?: string | null;
}
export interface ActionWorkflow {
    'model': ActionModel;
    'workflow'?: WorkflowModel | null;
}
export interface AdminPatchInput {
    'admin': boolean;
}
export interface AdminStats {
    'total_groups': number;
    'total_users': number;
}

export const ArchiveAttribute = {
    ExportIgnore: 'export_ignore',
    ExportSubst: 'export_subst'
} as const;

export type ArchiveAttribute = typeof ArchiveAttribute[keyof typeof ArchiveAttribute];


export interface BlamePart {
    'commit': Commit;
    'lines': Array<string>;
}
export interface BootstrapMetadata {
    'group'?: GroupModel | null;
    'path_ref'?: PathRefInfo | null;
    'repo'?: RepoParent | null;
    'user'?: UserModel | null;
}
export interface BranchCreateInput {
    'bypass_rules': boolean;
    'name': string;
    'target'?: string | null;
}
export interface BranchRenameInput {
    'bypass_rules': boolean;
    'new_name': string;
    'old_name': string;
}

export const CIStatus = {
    Pending: 'pending',
    Initializing: 'initializing',
    Skipped: 'skipped',
    Blocked: 'blocked',
    Declined: 'declined',
    Running: 'running',
    Success: 'success',
    Failure: 'failure',
    Killed: 'killed',
    Error: 'error'
} as const;

export type CIStatus = typeof CIStatus[keyof typeof CIStatus];


export interface CheckModel {
    'commit_sha': string;
    'created': number;
    'created_by': number;
    'ended': number;
    'id': number;
    'link': string;
    'metadata': any;
    'name': string;
    'payload': CheckPayload;
    'payload_kind': CheckPayloadKind;
    'payload_version': string;
    'repo_id': number;
    'started': number;
    'status': CheckStatus;
    'summary': string;
    'updated': number;
}


export interface CheckPayload {
    'data': any;
    'kind': CheckPayloadKind;
    'version': string;
}



export const CheckPayloadKind = {
    Empty: 'empty',
    Raw: 'raw',
    Markdown: 'markdown',
    Action: 'action'
} as const;

export type CheckPayloadKind = typeof CheckPayloadKind[keyof typeof CheckPayloadKind];


export interface CheckReportInput {
    'ended': number;
    'link': string;
    'name': string;
    'payload': CheckPayload;
    'started': number;
    'status': CheckStatus;
    'summary': string;
}



export const CheckStatus = {
    Pending: 'pending',
    Running: 'running',
    Success: 'success',
    Failure: 'failure',
    Error: 'error'
} as const;

export type CheckStatus = typeof CheckStatus[keyof typeof CheckStatus];


export interface CodeOwnerEvaluation {
    'evaluation_entries': Array<CodeOwnerEvaluationEntry>;
    'file_sha': string;
}
export interface CodeOwnerEvaluationEntry {
    'owner_evaluations': Array<OwnerEvaluation>;
    'pattern': string;
    'usergroup_owner_evaluations': Array<UserGroupOwnerEvaluation>;
}

export const CodeOwnerViolationCode = {
    Noop: 'noop',
    UserNotFound: 'user_not_found',
    PatternInvalid: 'pattern_invalid',
    PatternEmpty: 'pattern_empty'
} as const;

export type CodeOwnerViolationCode = typeof CodeOwnerViolationCode[keyof typeof CodeOwnerViolationCode];


export interface CodeOwnersValidation {
    'violations': Array<CodeOwnersViolation>;
}
export interface CodeOwnersViolation {
    'code': CodeOwnerViolationCode;
    'message': string;
    'params': Array<any>;
}


export interface Commit {
    'author': Identity;
    'committer': Identity;
    'file_stats': Array<CommitFileStats>;
    'message': string;
    'parent_shas': Array<string>;
    'sha': string;
    'signature'?: CommitGPGSignature | null;
    'title': string;
}
export interface CommitBranch {
    'commit'?: Commit | null;
    'name': string;
    'sha': string;
}
export interface CommitDiffFile {
    'end_line'?: number;
    'path'?: string;
    'start_line'?: number;
}
export interface CommitDivergence {
    'ahead': number;
    'behind': number;
}
export interface CommitDivergenceRequest {
    'from': string;
    'to': string;
}

export const CommitFileActionType = {
    Create: 'create',
    Update: 'update',
    Delete: 'delete',
    Move: 'move',
    PatchText: 'patch_text'
} as const;

export type CommitFileActionType = typeof CommitFileActionType[keyof typeof CommitFileActionType];


export interface CommitFileStats {
    'change_type': FileDiffStatus;
    'deletions': number;
    'insertions': number;
    'old_path'?: string | null;
    'path': string;
}


export interface CommitFilesInput {
    'actions': Array<RepoCommitFileAction>;
    'branch': string;
    'bypass_rules'?: boolean;
    'dry_run_rules'?: boolean;
    'message': string;
    'new_branch': string;
    'title': string;
}
export interface CommitFilesOutput {
    'commit_sha': string;
    'dry_run_rules': boolean;
    'rule_checks': Array<RuleCheckResult>;
}
export interface CommitGPGSignature {
    'payload': string;
    'signature': string;
}
export interface CommitTag {
    'commit'?: Commit | null;
    'is_annotated': boolean;
    'message'?: string | null;
    'name': string;
    'sha': string;
    'tagger'?: Identity | null;
    'title'?: string | null;
}
export interface CommitWithPathRenameDetails {
    'commit': Commit;
    'path_rename_details'?: PathRenameDetails | null;
}
export interface ConnectorCreateInput {
    'data': string;
    'description': string;
    'group_ref': string;
    'name': string;
    'type': string;
}
export interface ConnectorModel {
    'created': number;
    'data': string;
    'description': string;
    'group_id': number;
    'id': number;
    'name': string;
    'type': string;
    'updated': number;
    'version': number;
}
export interface ConnectorPatchInput {
    'data'?: string | null;
    'description'?: string | null;
    'name'?: string | null;
}
export interface ContainerContext {
    'id': string;
    'network': string;
}
export interface Contributor {
    'display_name'?: string;
    'email': string;
    'id': number;
    'name': string;
    'num_commits': number;
}
export interface CreatedOption {
    'created_gt'?: number | null;
    'created_lt'?: number | null;
}
export interface DefApprovals {
    'require_code_owners'?: boolean;
    'require_latest_commit'?: boolean;
    'require_minimum_count'?: number;
    'require_no_change_request'?: boolean;
}
export interface DefBypass {
    'repo_owners'?: boolean;
    'users'?: Array<UserModel>;
}
export interface DefComments {
    'require_resolve_all'?: boolean;
}
export interface DefLifecycle {
    'create_forbidden'?: boolean;
    'delete_forbidden'?: boolean;
    'update_forbidden'?: boolean;
}
export interface DefMerge {
    'delete_branch'?: boolean;
    'strategies_allowed'?: Array<PullreqMergeMethod>;
}
export interface DefPullreq {
    'approvals'?: DefApprovals;
    'comments'?: DefComments;
    'merge'?: DefMerge;
    'status_checks'?: DefStatusChecks;
}
export interface DefStatusChecks {
    'require_uids'?: Array<string>;
}
export interface DiffFileContent {
    'header'?: string | null;
    'hunk'?: HunkHeader | null;
    'lines': Array<string>;
}
export interface DiffStats {
    'commits'?: number;
    'files_changed'?: number;
}
export interface FeedModel {
    'created': number;
    'created_by': number;
    'date_contribution'?: number | null;
    'feed_type': FeedType;
    'id': number;
    'is_private': boolean;
    'num_contributions'?: number | null;
    'payload': any;
    'pullreq_activity_id'?: number | null;
    'pullreq_id'?: number | null;
    'pullreq_review_id'?: number | null;
    'release_id'?: number | null;
    'repo_id': number;
    'updated': number;
}


export interface FeedRelations {
    'creator'?: UserModel | null;
    'model': FeedModel;
    'pullreq'?: PullreqAuthor | null;
    'pullreq_activity'?: PullreqActivityCreator | null;
    'pullreq_review'?: PullreqReviewCreator | null;
    'release'?: ReleaseCreator | null;
    'repo'?: RepositoryModel | null;
}

export const FeedType = {
    Noop: 'noop',
    RepoCreated: 'repo_created',
    RepoImported: 'repo_imported',
    RepoDeleted: 'repo_deleted',
    RepoForked: 'repo_forked',
    RepoRenamed: 'repo_renamed',
    RepoTransferred: 'repo_transferred',
    RepoRestored: 'repo_restored',
    BranchCreated: 'branch_created',
    BranchRenamed: 'branch_renamed',
    BranchDeleted: 'branch_deleted',
    TagCreated: 'tag_created',
    TagDeleted: 'tag_deleted',
    CommitsPushed: 'commits_pushed',
    PullRequestCreated: 'pull_request_created',
    PullRequestClosed: 'pull_request_closed',
    PullRequestReopened: 'pull_request_reopened',
    PullRequestMerged: 'pull_request_merged',
    PullRequestReviewed: 'pull_request_reviewed',
    PullRequestCommented: 'pull_request_commented',
    ReleaseCreated: 'release_created',
    ReleaseDeleted: 'release_deleted'
} as const;

export type FeedType = typeof FeedType[keyof typeof FeedType];



export const FileDiffStatus = {
    Undefined: 'undefined',
    Added: 'added',
    Deleted: 'deleted',
    Modified: 'modified',
    Renamed: 'renamed',
    Copied: 'copied'
} as const;

export type FileDiffStatus = typeof FileDiffStatus[keyof typeof FileDiffStatus];


export interface GeneralSettings {
    'file_size_limit': number;
}
export interface GithubContext {
    'action': string;
    'action_path': string;
    'action_ref': string;
    'action_repository': string;
    'action_status': string;
    'actor': string;
    'actor_id': string;
    'api_url': string;
    'base_ref': string;
    'env': string;
    'event': any;
    'event_name': string;
    'event_path': string;
    'graphql_url': string;
    'head_ref': string;
    'job': string;
    'path': string;
    'ref': string;
    'ref_name': string;
    'ref_protected': boolean;
    'ref_type': string;
    'repository': string;
    'repositoryUrl': string;
    'repository_id': string;
    'repository_owner': string;
    'repository_owner_id': string;
    'retention_days': string;
    'run_attempt': string;
    'run_id': string;
    'run_number': string;
    'secret_source': string;
    'server_url': string;
    'sha': string;
    'token': string;
    'triggering_actor': string;
    'workflow': string;
    'workflow_ref': string;
    'workflow_sha': string;
    'workspace': string;
}
export interface GroupCreateInput {
    'description'?: string | null;
    'identifier': string;
    'is_public': boolean;
    'parent_ref': string;
}
export interface GroupImportInput {
    'description'?: string;
    'identifier': string;
    'is_public': boolean;
    'parent_ref': string;
    'provider': RepoProvider;
    'provider_group': string;
}
export interface GroupImportReposInput {
    'provider': RepoProvider;
    'provider_group': string;
}
export interface GroupImportReposOutput {
    'failed_repos': Array<Array<any>>;
    'succeed_repos': Array<RepositoryModel>;
}
export interface GroupMemberAddInput {
    'role': MembershipRole;
    'user_identifier': string;
}


export interface GroupMemberUpdateInput {
    'role': MembershipRole;
}


export interface GroupModel {
    'created': number;
    'created_by': number;
    'deleted'?: number | null;
    'description'?: string | null;
    'id': number;
    'is_public': boolean;
    'is_user_home': boolean;
    'name': string;
    'parent_id'?: number | null;
    'path'?: string | null;
    'updated': number;
    'version': number;
}
export interface GroupMoveInput {
    'name'?: string | null;
}
export interface GroupPatchInput {
    'description'?: string | null;
    'is_public'?: boolean | null;
}
export interface GroupProviderInput {
    'provider': RepoProvider;
    'provider_group': string;
}
export interface GroupRestoreInput {
    'new_identifier'?: string | null;
    'new_parent_ref'?: string | null;
}

export const GroupSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Created: 'created',
    Updated: 'updated'
} as const;

export type GroupSort = typeof GroupSort[keyof typeof GroupSort];


export interface Heatmap {
    'contributions': Array<NumContributonWithDate>;
    'years': Array<number>;
}
export interface HunkHeader {
    'new_line': number;
    'new_span': number;
    'old_line': number;
    'old_span': number;
    'text': string;
}
export interface Identity {
    'email': string;
    'existing'?: boolean | null;
    'name': string;
    'when'?: number | null;
}
export interface JobContext {
    'check_run_id': number;
    'container': ContainerContext;
    'services': { [key: string]: ServiceContext; };
    'status': StatusContext;
}


export interface JobProgress {
    'failure': string;
    'progress': number;
    'result': string;
    'state': JobState;
}



export const JobState = {
    Pending: 'pending',
    Scheduled: 'scheduled',
    Running: 'running',
    Finished: 'finished',
    Failed: 'failed',
    Canceled: 'canceled'
} as const;

export type JobState = typeof JobState[keyof typeof JobState];


export interface JobsContext {
    'outputs': { [key: string]: any; };
    'result': StatusContext;
}


export interface JsonErrorResponseNull {
    'code': number;
    'data'?: any;
    'message': string;
}
export interface License {
    'label': string;
    'value': string;
}
export interface LiveLogLine {
    'command'?: string | null;
    'out': string;
    'pos': number;
    'time': number;
}
export interface LoginInput {
    'identifier': string;
    'password': string;
}
export interface LoginOutput {
    'access_token': string;
    'expires_at'?: number | null;
    'two_factor_enabled'?: boolean | null;
}
export interface MembershipGroup {
    'groups': Array<GroupModel>;
    'model': MembershipModel;
}
export interface MembershipModel {
    'created': number;
    'created_by': number;
    'group_id': number;
    'id': number;
    'removeable': boolean;
    'role': MembershipRole;
    'updated': number;
    'user_id': number;
}



export const MembershipRole = {
    Reader: 'reader',
    Executor: 'executor',
    Contributor: 'contributor',
    Owner: 'owner'
} as const;

export type MembershipRole = typeof MembershipRole[keyof typeof MembershipRole];



export const MembershipSort = {
    Noop: 'noop',
    Id: 'id',
    Created: 'created'
} as const;

export type MembershipSort = typeof MembershipSort[keyof typeof MembershipSort];


export interface MembershipUserGroup {
    'group'?: GroupModel | null;
    'model': MembershipModel;
    'user'?: UserModel | null;
}
export interface NumContributonWithDate {
    'date_contribution': number;
    'num_contributions': number;
}

export const OrderOption = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type OrderOption = typeof OrderOption[keyof typeof OrderOption];


export interface OwnerEvaluation {
    'owner'?: UserModel | null;
    'review_decision': PullreqReviewDecision;
    'review_sha': string;
}


export interface PageOption {
    'page'?: number;
    'size'?: number;
}

export const ParentResourceType = {
    Group: 'group',
    Repository: 'repository'
} as const;

export type ParentResourceType = typeof ParentResourceType[keyof typeof ParentResourceType];


export interface PathDetails {
    'last_commit': Commit;
    'path': string;
}
export interface PathRefInfo {
    'ref_name': string;
    'ref_type': PathRefType;
    'repo_path': string;
}



export const PathRefType = {
    Branch: 'branch',
    Tag: 'tag',
    Commit: 'commit'
} as const;

export type PathRefType = typeof PathRefType[keyof typeof PathRefType];


export interface PathRenameDetails {
    'commit_sha_after'?: string;
    'commit_sha_before'?: string;
    'old_path': string;
    'path': string;
}
/**
 * Permission represents the different types of permissions a principal can have.
 */

export const Permission = {
    GroupView: 'group_view',
    GroupEdit: 'group_edit',
    GroupDelete: 'group_delete',
    RepoView: 'repo_view',
    RepoEdit: 'repo_edit',
    RepoDelete: 'repo_delete',
    RepoPush: 'repo_push',
    RepoReportCommitCheck: 'repo_report_commit_check',
    UserView: 'user_view',
    UserEdit: 'user_edit',
    UserDelete: 'user_delete',
    UserEditAdmin: 'user_edit_admin',
    ServiceAccountView: 'service_account_view',
    ServiceAccountEdit: 'service_account_edit',
    ServiceAccountDelete: 'service_account_delete',
    ServiceView: 'service_view',
    ServiceEdit: 'service_edit',
    ServiceDelete: 'service_delete',
    ServiceEditAdmin: 'service_edit_admin',
    ActionView: 'action_view',
    ActionEdit: 'action_edit',
    ActionDelete: 'action_delete',
    ActionExecute: 'action_execute',
    VariableView: 'variable_view',
    VariableEdit: 'variable_edit',
    VariableDelete: 'variable_delete',
    VariableAccess: 'variable_access',
    ConnectorView: 'connector_view',
    ConnectorEdit: 'connector_edit',
    ConnectorDelete: 'connector_delete',
    ConnectorAccess: 'connector_access',
    TemplateView: 'template_view',
    TemplateEdit: 'template_edit',
    TemplateDelete: 'template_delete',
    TemplateAccess: 'template_access',
    RunnerView: 'runner_view',
    RunnerAdd: 'runner_add',
    RunnerDelete: 'runner_delete',
    RunnerEdit: 'runner_edit',
    RunnerAccess: 'runner_access'
} as const;

export type Permission = typeof Permission[keyof typeof Permission];


export interface ProtectionBranch {
    'bypass'?: DefBypass;
    'lifecycle'?: DefLifecycle;
    'pullreq'?: DefPullreq;
}
export interface ProtectionDefinition {
    'branch': ProtectionBranch;
}
export interface ProtectionPattern {
    'default'?: boolean;
    'exclude'?: Array<string>;
    'include'?: Array<string>;
}
export interface PublicKeyCreateInput {
    'content': string;
    'name'?: string | null;
    'usage': PublicKeyUsage;
}


export interface PublicKeyModel {
    'comment': string;
    'content': Array<number>;
    'created': number;
    'created_by': number;
    'fingerprint': string;
    'id': number;
    'name': string;
    'type': string;
    'usage': PublicKeyUsage;
    'verified'?: number | null;
}



export const PublicKeySort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Created: 'created'
} as const;

export type PublicKeySort = typeof PublicKeySort[keyof typeof PublicKeySort];



export const PublicKeyUsage = {
    Auth: 'auth',
    Sign: 'sign'
} as const;

export type PublicKeyUsage = typeof PublicKeyUsage[keyof typeof PublicKeyUsage];


export interface PullreqActivityCreator {
    'creator'?: UserModel | null;
    'model': PullreqActivityModel;
}

export const PullreqActivityKind = {
    System: 'system',
    Comment: 'comment',
    ChangeComment: 'change_comment'
} as const;

export type PullreqActivityKind = typeof PullreqActivityKind[keyof typeof PullreqActivityKind];


export interface PullreqActivityMetadata {
    'suggestions'?: PullreqActivitySuggestionsMetadata | null;
}
export interface PullreqActivityModel {
    'code_comment_line_new'?: number | null;
    'code_comment_line_old'?: number | null;
    'code_comment_merge_base_sha'?: string | null;
    'code_comment_path'?: string | null;
    'code_comment_source_sha'?: string | null;
    'code_comment_span_new'?: number | null;
    'code_comment_span_old'?: number | null;
    'created': number;
    'created_by': number;
    'deleted'?: number | null;
    'edited': number;
    'id': number;
    'kind': PullreqActivityKind;
    'metadata'?: PullreqActivityMetadata | null;
    'order': number;
    'outdated'?: boolean | null;
    'parent_id'?: number | null;
    'payload': any;
    'pullreq_id': number;
    'reply_seq': number;
    'repo_id': number;
    'resolved'?: number | null;
    'resolved_by'?: number | null;
    'sub_order': number;
    'text': string;
    'type': PullreqActivityType;
    'updated': number;
    'version': number;
}


export interface PullreqActivityRelations {
    'children': Array<PullreqActivityModel>;
    'creator'?: UserModel | null;
    'model': PullreqActivityModel;
    'resolver'?: UserModel | null;
}

export const PullreqActivityStatus = {
    Active: 'active',
    Resolved: 'resolved'
} as const;

export type PullreqActivityStatus = typeof PullreqActivityStatus[keyof typeof PullreqActivityStatus];


export interface PullreqActivitySuggestionsMetadata {
    'applied_check_sum': string;
    'applied_commit_sha': string;
    'check_sums': Array<string>;
}

export const PullreqActivityType = {
    Comment: 'comment',
    CodeComment: 'code_comment',
    TitleChange: 'title_change',
    StateChange: 'state_change',
    ReviewSubmit: 'review_submit',
    BranchUpdate: 'branch_update',
    BranchDelete: 'branch_delete',
    Merge: 'merge'
} as const;

export type PullreqActivityType = typeof PullreqActivityType[keyof typeof PullreqActivityType];


export interface PullreqApplySuggestionsInput {
    'bypass_rules': boolean;
    'dry_run_rules': boolean;
    'message': string;
    'suggestions': Array<PullreqSuggestionReference>;
    'title': string;
}
export interface PullreqApplySuggestionsOutput {
    'commit_sha'?: string | null;
    'dry_run_rules': boolean;
    'rule_checks': Array<RuleCheckResult>;
}
export interface PullreqAuthor {
    'author'?: UserModel | null;
    'model': PullreqModel;
}
export interface PullreqCheck {
    'bypassable': boolean;
    'model': CheckModel;
    'required': boolean;
}
export interface PullreqChecksOutput {
    'checks': Array<PullreqCheck>;
    'commit_sha': string;
}
export interface PullreqCommentCreateInput {
    'line_end': number;
    'line_end_new': boolean;
    'line_start': number;
    'line_start_new': boolean;
    'parent_id': number;
    'path': string;
    'source_commit_sha': string;
    'target_commit_sha': string;
    'text': string;
}
export interface PullreqCommentStatusInput {
    'status': PullreqActivityStatus;
}


export interface PullreqCommentUpdateInput {
    'text': string;
}
export interface PullreqCreateInput {
    'description': string;
    'is_draft': boolean;
    'source_branch': string;
    'source_repo_ref': string;
    'target_branch': string;
    'title': string;
}
export interface PullreqFileViewCreateInput {
    'commit_sha': string;
    'path': string;
}
export interface PullreqFileViewModel {
    'created': number;
    'id': number;
    'obsolete': boolean;
    'path': string;
    'pullreq_id': number;
    'sha': string;
    'updated': number;
    'user_id': number;
}

export const PullreqMergeCheckStatus = {
    Unchecked: 'unchecked',
    Conflict: 'conflict',
    Mergeable: 'mergeable'
} as const;

export type PullreqMergeCheckStatus = typeof PullreqMergeCheckStatus[keyof typeof PullreqMergeCheckStatus];


export interface PullreqMergeInput {
    'bypass_rules': boolean;
    'delete_source_branch'?: boolean;
    'dry_run': boolean;
    'message': string;
    'method'?: PullreqMergeMethod | null;
    'source_sha': string;
    'title': string;
}



export const PullreqMergeMethod = {
    Merge: 'merge',
    Squash: 'squash',
    Rebase: 'rebase'
} as const;

export type PullreqMergeMethod = typeof PullreqMergeMethod[keyof typeof PullreqMergeMethod];


export interface PullreqMergeOutput {
    'allowed_methods'?: Array<PullreqMergeMethod> | null;
    'branch_deleted'?: boolean | null;
    'conflict_files': Array<string>;
    'dry_run'?: boolean | null;
    'minimum_required_approvals_count'?: number | null;
    'minimum_required_approvals_count_latest'?: number | null;
    'requires_code_owners_approval'?: boolean | null;
    'requires_code_owners_approval_latest'?: boolean | null;
    'requires_comment_resolution'?: boolean | null;
    'requires_no_change_requests'?: boolean | null;
    'rule_checks': Array<RuleCheckResult>;
    'sha'?: string | null;
}
export interface PullreqModel {
    'activity_seq'?: number | null;
    'closed'?: number | null;
    'comment_count': number;
    'commit_count'?: number | null;
    'created': number;
    'created_by': number;
    'description': string;
    'edited': number;
    'file_count'?: number | null;
    'id': number;
    'is_draft': boolean;
    'merge_base_sha': string;
    'merge_check_status': PullreqMergeCheckStatus;
    'merge_conflicts'?: Array<string>;
    'merge_method'?: PullreqMergeMethod | null;
    'merge_sha'?: string | null;
    'merge_target_sha'?: string | null;
    'merged'?: number | null;
    'merged_by'?: number | null;
    'number': number;
    'source_branch': string;
    'source_repo_id': number;
    'source_sha': string;
    'state': PullreqState;
    'target_branch': string;
    'target_repo_id': number;
    'title': string;
    'unresolved_count': number;
    'updated': number;
    'version': number;
}


export interface PullreqReviewCreator {
    'creator'?: UserModel | null;
    'model': PullreqReviewModel;
}

export const PullreqReviewDecision = {
    Pending: 'pending',
    Reviewed: 'reviewed',
    Approved: 'approved',
    Changereq: 'changereq'
} as const;

export type PullreqReviewDecision = typeof PullreqReviewDecision[keyof typeof PullreqReviewDecision];


export interface PullreqReviewModel {
    'created': number;
    'created_by': number;
    'decision': PullreqReviewDecision;
    'id': number;
    'pullreq_id': number;
    'sha': string;
    'updated': number;
}


export interface PullreqReviewSubmitInput {
    'commit_sha': string;
    'decision': PullreqReviewDecision;
}


export interface PullreqReviewerAddInput {
    'reviewer_id': number;
}
export interface PullreqReviewerModel {
    'created': number;
    'created_by': number;
    'id': number;
    'latest_review_id'?: number | null;
    'pullreq_id': number;
    'repo_id': number;
    'review_decision': PullreqReviewDecision;
    'sha': string;
    'type': PullreqReviewerType;
    'updated': number;
    'user_id': number;
}



export const PullreqReviewerType = {
    SelfAssigned: 'self_assigned',
    Requested: 'requested',
    Assigned: 'assigned'
} as const;

export type PullreqReviewerType = typeof PullreqReviewerType[keyof typeof PullreqReviewerType];


export interface PullreqReviewerUser {
    'model': PullreqReviewerModel;
    'user'?: UserModel | null;
}

export const PullreqSort = {
    Noop: 'noop',
    Number: 'number',
    Created: 'created',
    Edited: 'edited',
    Merged: 'merged',
    Updated: 'updated'
} as const;

export type PullreqSort = typeof PullreqSort[keyof typeof PullreqSort];



export const PullreqState = {
    Open: 'open',
    Merged: 'merged',
    Closed: 'closed'
} as const;

export type PullreqState = typeof PullreqState[keyof typeof PullreqState];


export interface PullreqStateUpdateInput {
    'is_draft': boolean;
    'state': PullreqState;
}


export interface PullreqSuggestionReference {
    'check_sum': string;
    'comment_id': number;
}
export interface PullreqUpdateInput {
    'description': string;
    'title': string;
}
export interface PullreqWithDiffStats {
    'author'?: UserModel | null;
    'diff_stats': DiffStats;
    'merger'?: UserModel | null;
    'model': PullreqModel;
}
export interface QueryOption {
    'page'?: number;
    'size'?: number;
    'query'?: string;
}
export interface RegisterInput {
    'display_name'?: string | null;
    'email': string;
    'name': string;
    'password': string;
}
export interface RegisterTokenModel {
    'created': number;
    'created_by': number;
    'id': number;
    'parent_id': number;
    'scope': Scope;
    'token': string;
    'updated': number;
    'version': number;
}


export interface ReleaseCreateInput {
    'bypass_rules': boolean;
    'description': string;
    'is_draft': boolean;
    'is_prerelease': boolean;
    'tag_name': string;
    'target': string;
    'title': string;
}
export interface ReleaseCreator {
    'creator'?: UserModel | null;
    'model': ReleaseModel;
}
export interface ReleaseModel {
    'assets'?: Array<string>;
    'contributors'?: Array<Contributor>;
    'created': number;
    'created_by': number;
    'deleted'?: number | null;
    'description': string;
    'id': number;
    'is_draft': boolean;
    'is_latest'?: boolean | null;
    'is_prerelease': boolean;
    'num_commits': number;
    'origin_author'?: string | null;
    'origin_author_id'?: number | null;
    'repo_id': number;
    'sha1': string;
    'tag_name': string;
    'title': string;
    'updated': number;
    'version': number;
}

export const ReleaseSort = {
    Noop: 'noop',
    Id: 'id',
    Created: 'created',
    Updated: 'updated'
} as const;

export type ReleaseSort = typeof ReleaseSort[keyof typeof ReleaseSort];


export interface RepoCommitDivergencesInput {
    'max_count': number;
    'requests': Array<CommitDivergenceRequest>;
}
export interface RepoCommitFileAction {
    'action': CommitFileActionType;
    'encoding'?: RepoFileContentEncodingType;
    'path': string;
    'payload': string;
    'sha': string;
}


export interface RepoContent {
    'dir'?: RepoDirContent | null;
    'file'?: RepoFileContent | null;
    'submodule'?: RepoSubmoduleContent | null;
    'symlink'?: RepoSymlinkContent | null;
}
export interface RepoContentInfo {
    'commit_url'?: string | null;
    'latest_commit'?: Commit | null;
    'name': string;
    'path': string;
    'repo_url'?: string | null;
    'sha': string;
    'type': RepoContentType;
}


export interface RepoContentOutput {
    'commit_url'?: string;
    'latest_commit'?: Commit;
    'name': string;
    'path': string;
    'repo_url'?: string;
    'sha': string;
    'type': RepoContentType;
    'content': RepoContent;
    'total_commits': number;
}



export const RepoContentType = {
    File: 'file',
    Dir: 'dir',
    Symlink: 'symlink',
    Submodule: 'submodule'
} as const;

export type RepoContentType = typeof RepoContentType[keyof typeof RepoContentType];


export interface RepoCreateInput {
    'default_branch'?: string;
    'description': string;
    'fork_id'?: number | null;
    'git_ignore': string;
    'identifier': string;
    'is_public': boolean;
    'license': string;
    'parent_ref': string;
    'readme': boolean;
    'single_branch': string;
}
export interface RepoDirContent {
    'entries': Array<RepoContentInfo>;
}
export interface RepoFileContent {
    'data': string;
    'encoding': RepoFileContentEncodingType;
    'size': number;
}



export const RepoFileContentEncodingType = {
    Utf8: 'utf8',
    Base64: 'base64'
} as const;

export type RepoFileContentEncodingType = typeof RepoFileContentEncodingType[keyof typeof RepoFileContentEncodingType];


export interface RepoImportInput {
    'description': string;
    'identifier': string;
    'is_public': boolean;
    'parent_ref': string;
    'provider': RepoProvider;
    'provider_repo': string;
}
export interface RepoMergeCheckInput {
    'head_repo_ref'?: string;
}
export interface RepoMergeCheckOutput {
    'conflict_files': Array<string>;
    'mergeable': boolean;
}
export interface RepoMoveInput {
    'identifier'?: string | null;
}
export interface RepoParent {
    'model': RepositoryModel;
    'parent'?: RepositoryModel | null;
}
export interface RepoPathsOutput {
    'dirs': Array<string>;
    'files': Array<string>;
}
export interface RepoProvider {
    'origin'?: string | null;
    'password'?: string | null;
    'type': RepoProviderType;
    'username'?: string | null;
}



export const RepoProviderType = {
    Github: 'github',
    Gitlab: 'gitlab'
} as const;

export type RepoProviderType = typeof RepoProviderType[keyof typeof RepoProviderType];


export interface RepoRestoreInput {
    'new_identifier'?: string | null;
    'new_parent_ref'?: string | null;
}

export const RepoSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Created: 'created',
    Updated: 'updated'
} as const;

export type RepoSort = typeof RepoSort[keyof typeof RepoSort];


export interface RepoStarsInput {
    'star': boolean;
}
export interface RepoStatsOutput {
    'branch_total_num': number;
    'pullreq_total_num': number;
    'release_total_num': number;
    'tag_total_num': number;
}
export interface RepoSubmoduleContent {
    'commit_sha': string;
    'url': string;
}
export interface RepoSymlinkContent {
    'size': number;
    'target': string;
}
export interface RepoUpdateDefaultBranchInput {
    'name': string;
}
export interface RepoUpdateInput {
    'description'?: string | null;
    'is_public'?: boolean | null;
}
export interface RepositoryModel {
    'created': number;
    'created_by': number;
    'default_branch': string;
    'deleted'?: number | null;
    'description': string;
    'display_name': string;
    'fork_id'?: number | null;
    'git_ssh_url'?: string | null;
    'git_uid': string;
    'git_url'?: string | null;
    'group_id': number;
    'id': number;
    'importing': boolean;
    'is_empty': boolean;
    'is_public': boolean;
    'name': string;
    'num_closed_pulls': number;
    'num_forks': number;
    'num_merged_pulls': number;
    'num_open_pulls': number;
    'num_pulls': number;
    'num_stars': number;
    'path'?: string | null;
    'pullreq_seq': number;
    'size': number;
    'size_updated'?: number | null;
    'updated': number;
    'version': number;
}
export interface RepositoryStarModel {
    'created': number;
    'created_by': number;
    'group_id': number;
    'id': number;
    'repo_id': number;
    'updated': number;
}
export interface RuleCheckOutput {
    'rule_checks': Array<RuleCheckResult>;
}
export interface RuleCheckResult {
    'bypassable': boolean;
    'bypassed': boolean;
    'rule': RuleMetadata;
    'violations': Array<RuleViolation>;
}
export interface RuleCreateInput {
    'definition'?: ProtectionDefinition | null;
    'description': string;
    'name': string;
    'pattern': ProtectionPattern;
    'state': RuleState;
    'type': RuleType;
}


export interface RuleMetadata {
    'group_path': string;
    'repo_path': string;
    'rule_definition': any;
    'rule_id': number;
    'rule_name': string;
    'rule_pattern': any;
    'rule_state': RuleState;
    'rule_type': RuleType;
}


export interface RuleModel {
    'created': number;
    'created_by': number;
    'definition': any;
    'description': string;
    'group_id'?: number | null;
    'id': number;
    'name': string;
    'pattern': any;
    'repo_id'?: number | null;
    'state': RuleState;
    'type': RuleType;
    'updated': number;
    'version': number;
}


export interface RulePatchInput {
    'definition'?: ProtectionDefinition | null;
    'description'?: string | null;
    'name'?: string | null;
    'pattern'?: ProtectionPattern | null;
    'state'?: RuleState | null;
}



export const RuleSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Created: 'created',
    Updated: 'updated'
} as const;

export type RuleSort = typeof RuleSort[keyof typeof RuleSort];



export const RuleState = {
    Disabled: 'disabled',
    Active: 'active',
    Monitor: 'monitor'
} as const;

export type RuleState = typeof RuleState[keyof typeof RuleState];



export const RuleType = {
    Branch: 'branch'
} as const;

export type RuleType = typeof RuleType[keyof typeof RuleType];


export interface RuleViolation {
    'code': string;
    'message': string;
    'params': Array<any>;
}

export const RunnerArchContext = {
    X86: 'x86',
    X64: 'x64',
    Arm: 'arm',
    Arm64: 'arm64'
} as const;

export type RunnerArchContext = typeof RunnerArchContext[keyof typeof RunnerArchContext];


export interface RunnerContext {
    'arch': RunnerArchContext;
    'debug': string;
    'environment': RunnerEnvironmentContext;
    'name': string;
    'os': RunnerOsContext;
    'temp': string;
    'tool_cache': string;
    'uuid': string;
}


export interface RunnerCreator {
    'creator'?: UserModel | null;
    'model': RunnerModel;
}

export const RunnerEnvironmentContext = {
    SelfHosted: 'self-hosted'
} as const;

export type RunnerEnvironmentContext = typeof RunnerEnvironmentContext[keyof typeof RunnerEnvironmentContext];


export interface RunnerModel {
    'created': number;
    'created_by': number;
    'description': string;
    'id': number;
    'labels': Array<string>;
    'last_online': number;
    'name': string;
    'parent_id': number;
    'release': string;
    'scope': Scope;
    'status': RunnerStatus;
    'token_id': number;
    'updated': number;
    'uuid': string;
    'version': number;
}



export const RunnerOsContext = {
    Linux: 'Linux',
    Windows: 'Windows',
    MacOs: 'macOS'
} as const;

export type RunnerOsContext = typeof RunnerOsContext[keyof typeof RunnerOsContext];


export interface RunnerPatchInput {
    'description': string;
}
export interface RunnerPostInput {
    'labels': Array<string>;
    'name': string;
    'release': string;
    'token': string;
}
export interface RunnerStageOutput {
    'access_token': string;
    'stage_metadata'?: StageMetadata | null;
}

export const RunnerStatus = {
    Offline: 'offline',
    Online: 'online'
} as const;

export type RunnerStatus = typeof RunnerStatus[keyof typeof RunnerStatus];



export const Scope = {
    System: 'system',
    Group: 'group',
    Repository: 'repository'
} as const;

export type Scope = typeof Scope[keyof typeof Scope];


export interface SecuritySettings {
    'secret_scanning_enabled'?: boolean;
}
export interface ServiceAccountCreateInput {
    'display_name': string;
    'email': string;
    'parent_id': number;
    'parent_type': ParentResourceType;
}


export interface ServiceAccountTokenOutput {
    'access_token': string;
    'expires_at'?: number | null;
}
export interface ServiceContext {
    'id': string;
    'network': string;
    'ports': { [key: string]: string; };
}

export const SseType = {
    Noop: 'noop',
    WorkflowUpdated: 'workflow_updated',
    WorkflowRunning: 'workflow_running',
    WorkflowCompleted: 'workflow_completed',
    WorkflowCanceled: 'workflow_canceled',
    RepositoryImportCompleted: 'repository_import_completed',
    PullreqUpdated: 'pullreq_updated'
} as const;

export type SseType = typeof SseType[keyof typeof SseType];


export interface StageContext {
    /**
     * Including all vars, priority from low to high, higher priority key could override lower priority key 1. The predefined variables for github/gitlab. 2. The web ui configured vars or envs, exclude secrets.
     */
    'all': { [key: string]: string; };
    /**
     * Contains variables set in a workflow, job, or step. Static data eg: env.ENV_NAME Value is encoded with base64 standard
     */
    'env': { [key: string]: string; };
    'github': any;
    /**
     * Contains the inputs of a reusable or manually triggered workflow. Runtime data eg: ${{inputs.INPUT_NAME}} value is jobs.<job_id>.with ![github: jobs.<job_id>.with](https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax#jobsjob_idwith)
     */
    'inputs': { [key: string]: any; };
    'job': any;
    /**
     * For reusable workflows only, contains outputs of jobs from the reusable workflow. Runtime data Initialized when stage is pushed into queue. Updated when stage is updated by api or else. key: job name or stage name value: JobsContext, refer to [Github docs](https://docs.github.com/en/actions/reference/workflows-and-actions/contexts#jobs-context). Converted to serde_json::Value for recursively inject variables
     */
    'jobs': { [key: string]: any; };
    'matrix': { [key: string]: string; };
    /**
     * Contains the outputs of all jobs that are defined as a dependency of the current job. Runtime data key: job name value: JobsContext. Converted to serde_json::Value for recursively inject variables.
     */
    'needs': { [key: string]: any; };
    'runner': any;
    /**
     * Contains the names and values of secrets that are available to a workflow run. Sensitive data, only available to the job that will be running. eg: github: secrets.SECRET_NAME gitlab: $SECRET_NAME, secret.SECRET_NAME Value is encoded with base64 standard
     */
    'secrets': { [key: string]: string; };
    /**
     * Information about the steps that have been run in the current job. Runtime data key:   step id (set in step yaml) value: refer to StepsContext. Converted to serde_json::Value for recursively inject variables.
     */
    'steps': { [key: string]: any; };
    'strategy': any;
    /**
     * Contains variables set at the repository, organization, or environment levels. Static data eg: gitlab: variables.VAR_NAME github: vars.VAR_NAME Value is encoded with base64 standard
     */
    'vars': { [key: string]: string; };
}
export interface StageMetadata {
    'context': StageContext;
    'stage': StageModel;
}
export interface StageModel {
    'action_id': number;
    'arch': string;
    'created': number;
    'errignore': boolean;
    'error': string;
    'exit_code': number;
    'id': number;
    'is_reusable': boolean;
    'kernel': string;
    'kind': string;
    'labels': Array<string>;
    'limit': number;
    'limit_repo': number;
    'machine': string;
    'name': string;
    'needs': Array<string>;
    'number': number;
    'on_failure': boolean;
    'on_success': boolean;
    'os': string;
    'outputs'?: { [key: string]: any; };
    'parent_group_id': number;
    'parent_id'?: number | null;
    'repo_id': number;
    'started'?: number | null;
    'status': CIStatus;
    'stopped'?: number | null;
    'type': string;
    'updated': number;
    'variant': string;
    'version': number;
    'workflow_id': number;
    'yaml_provider': YamlProvider;
    'yaml_resolved': string;
}


export interface StageSteps {
    'model': StageModel;
    'steps': Array<StepModel>;
}
export interface StageUpdateInput {
    'error'?: string | null;
    'exit_code'?: number | null;
    /**
     * Used for storing the result of the yaml decoded stage.
     */
    'jobstatus'?: StatusContext | null;
    'outputs'?: { [key: string]: any; };
    'started'?: number | null;
    'status'?: CIStatus | null;
    'stopped'?: number | null;
}



export const StatusContext = {
    Noop: 'noop',
    Success: 'success',
    Failure: 'failure',
    Cancelled: 'cancelled',
    Skipped: 'skipped'
} as const;

export type StatusContext = typeof StatusContext[keyof typeof StatusContext];


export interface StepCreateInput {
    'depends_on': any;
    'detached': boolean;
    'errignore': boolean;
    'error': string;
    'exit_code': number;
    'image': string;
    'name': string;
    'number': number;
    'parent_group_id': number;
    'status': CIStatus;
    'stepid'?: string;
    'yaml_provider': YamlProvider;
    'yaml_resolved': string;
}


export interface StepModel {
    'depends_on': any;
    'detached': boolean;
    'errignore': boolean;
    'error': string;
    'exit_code': number;
    'id': number;
    'image': string;
    'name': string;
    'number': number;
    'outputs'?: { [key: string]: any; };
    'parent_group_id': number;
    'stage_id': number;
    'started'?: number | null;
    'status': CIStatus;
    'stopped'?: number | null;
    'version': number;
    'yaml_provider': YamlProvider;
    'yaml_resolved': string;
}


export interface StepUpdateInput {
    'error'?: string | null;
    'exit_code'?: number | null;
    'outputs'?: { [key: string]: any; };
    'started'?: number | null;
    'status'?: CIStatus | null;
    /**
     * The step result status after the yaml is executed
     */
    'stepconclusion'?: StatusContext | null;
    'stepid'?: string;
    /**
     * The step result status after the yaml is executed.
     */
    'stepoutcome'?: StatusContext | null;
    'stopped'?: number | null;
}


export interface StepsContext {
    'conclusion': StatusContext;
    'outcome': StatusContext;
    'outputs': { [key: string]: any; };
}


export interface SystemConfig {
    'nested_groups_enabled': boolean;
    'public_resource_creation_enabled': boolean;
    'user_signup_allowed': boolean;
}
export interface TagCreateInput {
    'bypass_rules': boolean;
    'message': string;
    'name': string;
    'target': string;
}
export interface TokenCreateInput {
    'lifetime_ms'?: number | null;
    'name': string;
    'permissions'?: Array<Permission>;
}
export interface TokenCreateOutput {
    'access_token': string;
    'expires_at'?: number | null;
    'model': TokenModel;
}
export interface TokenModel {
    'created_by': number;
    'expires_at'?: number | null;
    'id': number;
    'issued_at': number;
    'name': string;
    'permissions'?: Array<Permission>;
    'type': TokenType;
    'user_id': number;
}



export const TokenType = {
    Session: 'session',
    TwoFactor: 'two_factor',
    Pat: 'pat',
    Sat: 'sat',
    Runner: 'runner'
} as const;

export type TokenType = typeof TokenType[keyof typeof TokenType];



export const TriggerEvent = {
    Noop: 'noop',
    BranchProtectionRule: 'branch_protection_rule',
    CheckRun: 'check_run',
    CheckSuite: 'check_suite',
    Branch: 'branch',
    Tag: 'tag',
    PullRequest: 'pull_request',
    Release: 'release',
    Repository: 'repository',
    Schedule: 'schedule',
    Status: 'status',
    WorkflowDispatch: 'workflow_dispatch',
    WorkflowRun: 'workflow_run'
} as const;

export type TriggerEvent = typeof TriggerEvent[keyof typeof TriggerEvent];


export interface TwoFactorCreateInput {
    'passcode': string;
    'secret': string;
}
export interface TwoFactorGetOutput {
    'enabled': boolean;
    'qr_uri': string;
    'secret': string;
}
export interface TwoFactorPasscodeInput {
    'passcode': string;
}
export interface TwoFactorScratchTokenInput {
    'token': string;
}
export interface UserCreateInput {
    'display_name'?: string | null;
    'email': string;
    'name': string;
    'password'?: string | null;
}
export interface UserGroupOwnerEvaluation {
    'evaluations': Array<OwnerEvaluation>;
    'identifier': string;
    'name': string;
}
export interface UserModel {
    'created': number;
    'display_name'?: string | null;
    'email': string;
    'id': number;
    'is_active': boolean;
    'is_admin': boolean;
    'is_blocked': boolean;
    'name': string;
    'parent_id'?: number | null;
    'parent_type'?: ParentResourceType | null;
    'type': UserType;
    'updated': number;
}


export interface UserPatchInput {
    'display_name'?: string | null;
    'email'?: string | null;
    'is_active'?: boolean | null;
    'is_blocked'?: boolean | null;
    'password'?: string | null;
}

export const UserSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Email: 'email',
    Admin: 'admin',
    Created: 'created',
    Updated: 'updated'
} as const;

export type UserSort = typeof UserSort[keyof typeof UserSort];



export const UserType = {
    User: 'user',
    ServiceAccount: 'service_account'
} as const;

export type UserType = typeof UserType[keyof typeof UserType];


export interface VariableCreateInput {
    'data': string;
    'description': string;
    'identifier': string;
    'parent_ref': string;
    'type': VariableType;
}


export interface VariableGroup {
    'group'?: GroupModel | null;
    'model': VariableModel;
}
export interface VariableModel {
    'created': number;
    'created_by': number;
    'data': Array<number>;
    'description': string;
    'id': number;
    'name': string;
    'parent_id': number;
    'scope': Scope;
    'type': VariableType;
    'updated': number;
    'version': number;
}


export interface VariablePatchInput {
    'data'?: string | null;
    'description'?: string | null;
    'identifier'?: string | null;
    'type': VariableType;
}



export const VariableSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Type: 'type',
    Created: 'created',
    Updated: 'updated'
} as const;

export type VariableSort = typeof VariableSort[keyof typeof VariableSort];



export const VariableType = {
    PlainText: 'plain_text',
    SecretText: 'secret_text',
    EnvironmentText: 'environment_text',
    EnvironmentSecret: 'environment_secret'
} as const;

export type VariableType = typeof VariableType[keyof typeof VariableType];


export interface WebhookCreateInput {
    'description': string;
    'display_name': string;
    'enabled': boolean;
    'identifier': string;
    'insecure': boolean;
    'secret': string;
    'triggers': Array<WebhookTrigger>;
    'url': string;
}
export interface WebhookExecutionModel {
    'created': number;
    'duration': number;
    'error': string;
    'id': number;
    'request_body': string;
    'request_headers': string;
    'request_url': string;
    'response_body': string;
    'response_headers': string;
    'response_status': string;
    'response_status_code': number;
    'result': WebhookExecutionResult;
    'retrigger_of'?: number | null;
    'retriggerable': boolean;
    'trigger_id': string;
    'trigger_type': WebhookTrigger;
    'updated': number;
    'webhook_id': number;
}



export const WebhookExecutionResult = {
    Unknown: 'unknown',
    Success: 'success',
    RetriableError: 'retriable_error',
    FatalError: 'fatal_error'
} as const;

export type WebhookExecutionResult = typeof WebhookExecutionResult[keyof typeof WebhookExecutionResult];


export interface WebhookModel {
    'created': number;
    'created_by': number;
    'description': string;
    'display_name': string;
    'enabled': boolean;
    'group_id'?: number | null;
    'id': number;
    'insecure': boolean;
    'internal': boolean;
    'latest_execution_result'?: WebhookExecutionResult | null;
    'name': string;
    'parent_type': WebhookParentType;
    'repo_id'?: number | null;
    'secret': string;
    'triggers': Array<WebhookTrigger>;
    'updated': number;
    'url': string;
    'version': number;
}



export const WebhookParentType = {
    Repository: 'repository',
    Group: 'group'
} as const;

export type WebhookParentType = typeof WebhookParentType[keyof typeof WebhookParentType];


export interface WebhookPatchInput {
    'description'?: string | null;
    'display_name'?: string | null;
    'enabled'?: boolean | null;
    'identifier'?: string | null;
    'insecure'?: boolean | null;
    'secret'?: string | null;
    'triggers'?: Array<WebhookTrigger> | null;
    'url'?: string | null;
}

export const WebhookSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    DisplayName: 'display_name',
    Created: 'created',
    Updated: 'updated'
} as const;

export type WebhookSort = typeof WebhookSort[keyof typeof WebhookSort];



export const WebhookTrigger = {
    Noop: 'noop',
    BranchCreated: 'branch_created',
    BranchUpdated: 'branch_updated',
    BranchDeleted: 'branch_deleted',
    TagCreated: 'tag_created',
    TagUpdated: 'tag_updated',
    TagDeleted: 'tag_deleted',
    PullreqCreated: 'pullreq_created',
    PullreqReopened: 'pullreq_reopened',
    PullreqSynchronize: 'pullreq_synchronize',
    PullreqClosed: 'pullreq_closed',
    PullreqCommented: 'pullreq_commented',
    PullreqMerged: 'pullreq_merged'
} as const;

export type WebhookTrigger = typeof WebhookTrigger[keyof typeof WebhookTrigger];


export interface WorkflowCreateInput {
    'debug': boolean;
    'deploy'?: string | null;
    'deploy_id'?: number | null;
    'params'?: { [key: string]: any; };
    'source_repo_id'?: number | null;
    'source_sha'?: string | null;
}
export interface WorkflowModel {
    'action'?: string | null;
    'action_id': number;
    'after_sha'?: string | null;
    'author_email': string;
    'author_id'?: number | null;
    'author_name': string;
    'before_sha': string;
    'context': object | null;
    'created': number;
    'created_by': number;
    'cron': string;
    'debug': boolean;
    'deploy': string;
    'deploy_id': number;
    'error': string;
    'event': TriggerEvent;
    'finished': number;
    'id': number;
    'link': string;
    'message': string;
    'name': string;
    'number': number;
    'params': { [key: string]: any; };
    'repo_id': number;
    'source_repo_id'?: number | null;
    'source_rev'?: string | null;
    'started': number;
    'status': CIStatus;
    'target_rev': string;
    'title': string;
    'updated': number;
    'version': number;
    'yaml_provider': YamlProvider;
    'yaml_resolved': string;
}


export interface WorkflowStages {
    'model': WorkflowModel;
    'stages': Array<StageSteps>;
}
export interface WorkflowUpdateInput {
    'after'?: string | null;
    'error'?: string | null;
    'finished'?: number | null;
    'started'?: number | null;
    'status'?: CIStatus | null;
}



export const YamlProvider = {
    Unknown: 'unknown',
    Github: 'github',
    Gitlab: 'gitlab'
} as const;

export type YamlProvider = typeof YamlProvider[keyof typeof YamlProvider];



/**
 * AccountsApi - axios parameter creator
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginInput} loginInput Login input
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin: async (loginInput: LoginInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInput' is not null or undefined
            assertParamExists('postLogin', 'loginInput', loginInput)
            const localVarPath = `/account/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterInput} registerInput Register a new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegister: async (registerInput: RegisterInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerInput' is not null or undefined
            assertParamExists('postRegister', 'registerInput', registerInput)
            const localVarPath = `/account/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TwoFactorPasscodeInput} twoFactorPasscodeInput Login with two factor passcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactorPasscode: async (twoFactorPasscodeInput: TwoFactorPasscodeInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorPasscodeInput' is not null or undefined
            assertParamExists('postTwoFactorPasscode', 'twoFactorPasscodeInput', twoFactorPasscodeInput)
            const localVarPath = `/account/two_factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorPasscodeInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TwoFactorScratchTokenInput} twoFactorScratchTokenInput Login with two scratch token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactorScratchToken: async (twoFactorScratchTokenInput: TwoFactorScratchTokenInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorScratchTokenInput' is not null or undefined
            assertParamExists('postTwoFactorScratchToken', 'twoFactorScratchTokenInput', twoFactorScratchTokenInput)
            const localVarPath = `/account/two_factor/scratch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorScratchTokenInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginInput} loginInput Login input
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogin(loginInput: LoginInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLogin(loginInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterInput} registerInput Register a new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegister(registerInput: RegisterInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegister(registerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TwoFactorPasscodeInput} twoFactorPasscodeInput Login with two factor passcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTwoFactorPasscode(twoFactorPasscodeInput: TwoFactorPasscodeInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTwoFactorPasscode(twoFactorPasscodeInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postTwoFactorPasscode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TwoFactorScratchTokenInput} twoFactorScratchTokenInput Login with two scratch token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTwoFactorScratchToken(twoFactorScratchTokenInput: TwoFactorScratchTokenInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTwoFactorScratchToken(twoFactorScratchTokenInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postTwoFactorScratchToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginInput} loginInput Login input
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin(loginInput: LoginInput, options?: RawAxiosRequestConfig): AxiosPromise<LoginOutput> {
            return localVarFp.postLogin(loginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterInput} registerInput Register a new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegister(registerInput: RegisterInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.postRegister(registerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TwoFactorPasscodeInput} twoFactorPasscodeInput Login with two factor passcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactorPasscode(twoFactorPasscodeInput: TwoFactorPasscodeInput, options?: RawAxiosRequestConfig): AxiosPromise<LoginOutput> {
            return localVarFp.postTwoFactorPasscode(twoFactorPasscodeInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TwoFactorScratchTokenInput} twoFactorScratchTokenInput Login with two scratch token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactorScratchToken(twoFactorScratchTokenInput: TwoFactorScratchTokenInput, options?: RawAxiosRequestConfig): AxiosPromise<LoginOutput> {
            return localVarFp.postTwoFactorScratchToken(twoFactorScratchTokenInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @param {LoginInput} loginInput Login input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postLogin(loginInput: LoginInput, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postLogin(loginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postLogout(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterInput} registerInput Register a new user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRegister(registerInput: RegisterInput, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postRegister(registerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TwoFactorPasscodeInput} twoFactorPasscodeInput Login with two factor passcode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTwoFactorPasscode(twoFactorPasscodeInput: TwoFactorPasscodeInput, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postTwoFactorPasscode(twoFactorPasscodeInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TwoFactorScratchTokenInput} twoFactorScratchTokenInput Login with two scratch token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTwoFactorScratchToken(twoFactorScratchTokenInput: TwoFactorScratchTokenInput, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postTwoFactorScratchToken(twoFactorScratchTokenInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ActionsApi - axios parameter creator
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflow: async (repoRef: string, actionIdentifier: string, workflowIdn: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('cancelWorkflow', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('cancelWorkflow', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('cancelWorkflow', 'workflowIdn', workflowIdn)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/cancel`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAction: async (repoRef: string, actionIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteAction', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('deleteAction', 'actionIdentifier', actionIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: async (repoRef: string, actionIdentifier: string, workflowIdn: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteWorkflow', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('deleteWorkflow', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('deleteWorkflow', 'workflowIdn', workflowIdn)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAction: async (repoRef: string, actionIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getAction', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('getAction', 'actionIdentifier', actionIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [latest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions: async (repoRef: string, page?: number, size?: number, query?: string, latest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getActions', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/actions`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (latest !== undefined) {
                localVarQueryParameter['latest'] = latest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStepLogStream: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getStepLogStream', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('getStepLogStream', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('getStepLogStream', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('getStepLogStream', 'stageNumber', stageNumber)
            // verify required parameter 'stepNumber' is not null or undefined
            assertParamExists('getStepLogStream', 'stepNumber', stepNumber)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/logs/{stage_number}/{step_number}/stream`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)))
                .replace(`{${"step_number"}}`, encodeURIComponent(String(stepNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStepLogs: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getStepLogs', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('getStepLogs', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('getStepLogs', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('getStepLogs', 'stageNumber', stageNumber)
            // verify required parameter 'stepNumber' is not null or undefined
            assertParamExists('getStepLogs', 'stepNumber', stepNumber)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/logs/{stage_number}/{step_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)))
                .replace(`{${"step_number"}}`, encodeURIComponent(String(stepNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow: async (repoRef: string, actionIdentifier: string, workflowIdn: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getWorkflow', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('getWorkflow', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('getWorkflow', 'workflowIdn', workflowIdn)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows: async (repoRef: string, actionIdentifier: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getWorkflows', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('getWorkflows', 'actionIdentifier', actionIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {ActionUpdateInput} actionUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAction: async (repoRef: string, actionIdentifier: string, actionUpdateInput: ActionUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchAction', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('patchAction', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'actionUpdateInput' is not null or undefined
            assertParamExists('patchAction', 'actionUpdateInput', actionUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StageUpdateInput} stageUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStage: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stageUpdateInput: StageUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchStage', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('patchStage', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('patchStage', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('patchStage', 'stageNumber', stageNumber)
            // verify required parameter 'stageUpdateInput' is not null or undefined
            assertParamExists('patchStage', 'stageUpdateInput', stageUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/stages/{stage_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stageUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {StepUpdateInput} stepUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStep: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, stepUpdateInput: StepUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchStep', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('patchStep', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('patchStep', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('patchStep', 'stageNumber', stageNumber)
            // verify required parameter 'stepNumber' is not null or undefined
            assertParamExists('patchStep', 'stepNumber', stepNumber)
            // verify required parameter 'stepUpdateInput' is not null or undefined
            assertParamExists('patchStep', 'stepUpdateInput', stepUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/stages/{stage_number}/{step_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)))
                .replace(`{${"step_number"}}`, encodeURIComponent(String(stepNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {WorkflowUpdateInput} workflowUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow: async (repoRef: string, actionIdentifier: string, workflowIdn: number, workflowUpdateInput: WorkflowUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchWorkflow', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('patchWorkflow', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('patchWorkflow', 'workflowIdn', workflowIdn)
            // verify required parameter 'workflowUpdateInput' is not null or undefined
            assertParamExists('patchWorkflow', 'workflowUpdateInput', workflowUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ActionCreateInput} actionCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAction: async (repoRef: string, actionCreateInput: ActionCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postAction', 'repoRef', repoRef)
            // verify required parameter 'actionCreateInput' is not null or undefined
            assertParamExists('postAction', 'actionCreateInput', actionCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StepCreateInput} stepCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStep: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepCreateInput: StepCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postStep', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('postStep', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('postStep', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('postStep', 'stageNumber', stageNumber)
            // verify required parameter 'stepCreateInput' is not null or undefined
            assertParamExists('postStep', 'stepCreateInput', stepCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/stages/{stage_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload workflow step json log
         * @summary Upload step log
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {LiveLogLine} liveLogLine 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStepLog: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, liveLogLine: LiveLogLine, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postStepLog', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('postStepLog', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('postStepLog', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('postStepLog', 'stageNumber', stageNumber)
            // verify required parameter 'stepNumber' is not null or undefined
            assertParamExists('postStepLog', 'stepNumber', stepNumber)
            // verify required parameter 'liveLogLine' is not null or undefined
            assertParamExists('postStepLog', 'liveLogLine', liveLogLine)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/stages/{stage_number}/{step_number}/log`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)))
                .replace(`{${"step_number"}}`, encodeURIComponent(String(stepNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(liveLogLine, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload workflow step json log by stream, unsupported yet.
         * @summary Upload step logstream
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {Array<number>} requestBody Raw bytes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStepLogStream: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, requestBody: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postStepLogStream', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('postStepLogStream', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('postStepLogStream', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('postStepLogStream', 'stageNumber', stageNumber)
            // verify required parameter 'stepNumber' is not null or undefined
            assertParamExists('postStepLogStream', 'stepNumber', stepNumber)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('postStepLogStream', 'requestBody', requestBody)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/stages/{stage_number}/{step_number}/logstream`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)))
                .replace(`{${"step_number"}}`, encodeURIComponent(String(stepNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {WorkflowCreateInput} workflowCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkflow: async (repoRef: string, actionIdentifier: string, workflowCreateInput: WorkflowCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postWorkflow', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('postWorkflow', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowCreateInput' is not null or undefined
            assertParamExists('postWorkflow', 'workflowCreateInput', workflowCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelWorkflow(repoRef, actionIdentifier, workflowIdn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.cancelWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAction(repoRef, actionIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.deleteAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflow(repoRef, actionIdentifier, workflowIdn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.deleteWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAction(repoRef, actionIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [latest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActions(repoRef: string, page?: number, size?: number, query?: string, latest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionWorkflow>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActions(repoRef, page, size, query, latest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getActions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStepLogStream(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveLogLine>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStepLogStream(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getStepLogStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStepLogs(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveLogLine>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStepLogs(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getStepLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflow(repoRef, actionIdentifier, workflowIdn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflows(repoRef: string, actionIdentifier: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflows(repoRef, actionIdentifier, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getWorkflows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {ActionUpdateInput} actionUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAction(repoRef: string, actionIdentifier: string, actionUpdateInput: ActionUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAction(repoRef, actionIdentifier, actionUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.patchAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StageUpdateInput} stageUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStage(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stageUpdateInput: StageUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchStage(repoRef, actionIdentifier, workflowIdn, stageNumber, stageUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.patchStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {StepUpdateInput} stepUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, stepUpdateInput: StepUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, stepUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.patchStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {WorkflowUpdateInput} workflowUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, workflowUpdateInput: WorkflowUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchWorkflow(repoRef, actionIdentifier, workflowIdn, workflowUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.patchWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ActionCreateInput} actionCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAction(repoRef: string, actionCreateInput: ActionCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAction(repoRef, actionCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.postAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StepCreateInput} stepCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepCreateInput: StepCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.postStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload workflow step json log
         * @summary Upload step log
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {LiveLogLine} liveLogLine 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStepLog(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, liveLogLine: LiveLogLine, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postStepLog(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, liveLogLine, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.postStepLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload workflow step json log by stream, unsupported yet.
         * @summary Upload step logstream
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {Array<number>} requestBody Raw bytes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStepLogStream(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, requestBody: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postStepLogStream(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.postStepLogStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {WorkflowCreateInput} workflowCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWorkflow(repoRef: string, actionIdentifier: string, workflowCreateInput: WorkflowCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWorkflow(repoRef, actionIdentifier, workflowCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.postWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActionsApi - factory interface
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowStages> {
            return localVarFp.cancelWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAction(repoRef, actionIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<ActionModel> {
            return localVarFp.getAction(repoRef, actionIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [latest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions(repoRef: string, page?: number, size?: number, query?: string, latest?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ActionWorkflow>> {
            return localVarFp.getActions(repoRef, page, size, query, latest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStepLogStream(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<LiveLogLine>> {
            return localVarFp.getStepLogStream(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStepLogs(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<LiveLogLine>> {
            return localVarFp.getStepLogs(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowStages> {
            return localVarFp.getWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows(repoRef: string, actionIdentifier: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkflowModel>> {
            return localVarFp.getWorkflows(repoRef, actionIdentifier, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {ActionUpdateInput} actionUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAction(repoRef: string, actionIdentifier: string, actionUpdateInput: ActionUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<ActionModel> {
            return localVarFp.patchAction(repoRef, actionIdentifier, actionUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StageUpdateInput} stageUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStage(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stageUpdateInput: StageUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<StageModel> {
            return localVarFp.patchStage(repoRef, actionIdentifier, workflowIdn, stageNumber, stageUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {StepUpdateInput} stepUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, stepUpdateInput: StepUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<StepModel> {
            return localVarFp.patchStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, stepUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {WorkflowUpdateInput} workflowUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, workflowUpdateInput: WorkflowUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowModel> {
            return localVarFp.patchWorkflow(repoRef, actionIdentifier, workflowIdn, workflowUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ActionCreateInput} actionCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAction(repoRef: string, actionCreateInput: ActionCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<ActionModel> {
            return localVarFp.postAction(repoRef, actionCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StepCreateInput} stepCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepCreateInput: StepCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<StepModel> {
            return localVarFp.postStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload workflow step json log
         * @summary Upload step log
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {LiveLogLine} liveLogLine 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStepLog(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, liveLogLine: LiveLogLine, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postStepLog(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, liveLogLine, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload workflow step json log by stream, unsupported yet.
         * @summary Upload step logstream
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {Array<number>} requestBody Raw bytes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStepLogStream(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, requestBody: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postStepLogStream(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {WorkflowCreateInput} workflowCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkflow(repoRef: string, actionIdentifier: string, workflowCreateInput: WorkflowCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postWorkflow(repoRef, actionIdentifier, workflowCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - object-oriented interface
 */
export class ActionsApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).cancelWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).deleteAction(repoRef, actionIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).deleteWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getAction(repoRef, actionIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {boolean} [latest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getActions(repoRef: string, page?: number, size?: number, query?: string, latest?: boolean, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getActions(repoRef, page, size, query, latest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {number} stepNumber Step number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStepLogStream(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getStepLogStream(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {number} stepNumber Step number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStepLogs(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getStepLogs(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWorkflows(repoRef: string, actionIdentifier: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getWorkflows(repoRef, actionIdentifier, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {ActionUpdateInput} actionUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchAction(repoRef: string, actionIdentifier: string, actionUpdateInput: ActionUpdateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).patchAction(repoRef, actionIdentifier, actionUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {StageUpdateInput} stageUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchStage(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stageUpdateInput: StageUpdateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).patchStage(repoRef, actionIdentifier, workflowIdn, stageNumber, stageUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {number} stepNumber Step number
     * @param {StepUpdateInput} stepUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, stepUpdateInput: StepUpdateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).patchStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, stepUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {WorkflowUpdateInput} workflowUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, workflowUpdateInput: WorkflowUpdateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).patchWorkflow(repoRef, actionIdentifier, workflowIdn, workflowUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {ActionCreateInput} actionCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postAction(repoRef: string, actionCreateInput: ActionCreateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).postAction(repoRef, actionCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {StepCreateInput} stepCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepCreateInput: StepCreateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).postStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload workflow step json log
     * @summary Upload step log
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {number} stepNumber Step number
     * @param {LiveLogLine} liveLogLine 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postStepLog(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, liveLogLine: LiveLogLine, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).postStepLog(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, liveLogLine, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload workflow step json log by stream, unsupported yet.
     * @summary Upload step logstream
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {number} stepNumber Step number
     * @param {Array<number>} requestBody Raw bytes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postStepLogStream(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, requestBody: Array<number>, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).postStepLogStream(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {WorkflowCreateInput} workflowCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postWorkflow(repoRef: string, actionIdentifier: string, workflowCreateInput: WorkflowCreateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).postWorkflow(repoRef, actionIdentifier, workflowCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('deleteGroup', 'groupRef', groupRef)
            const localVarPath = `/admin/groups/{group_ref}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner: async (runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('deleteRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/admin/runners/{runner_uuid}`
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('deleteUser', 'userIdentifier', userIdentifier)
            const localVarPath = `/admin/users/{user_identifier}`
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable: async (variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('deleteVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/admin/variables/{variable_identifier}`
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: async (page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResetedRunnerRegisterToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/runners/register_token/reseted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner: async (runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('getRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/admin/runners/{runner_uuid}`
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerRegisterToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/runners/register_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunners: async (page?: number, size?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/runners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('getUser', 'userIdentifier', userIdentifier)
            const localVarPath = `/admin/users/{user_identifier}`
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {OrderOption} [order] 
         * @param {UserSort} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (page?: number, size?: number, query?: string, order?: OrderOption, sort?: UserSort, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariable: async (variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('getVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/admin/variables/{variable_identifier}`
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables: async (page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRunner: async (runnerUuid: string, runnerPatchInput: RunnerPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('patchRunner', 'runnerUuid', runnerUuid)
            // verify required parameter 'runnerPatchInput' is not null or undefined
            assertParamExists('patchRunner', 'runnerPatchInput', runnerPatchInput)
            const localVarPath = `/admin/runners/{runner_uuid}`
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {UserPatchInput} userPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser: async (userIdentifier: string, userPatchInput: UserPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('patchUser', 'userIdentifier', userIdentifier)
            // verify required parameter 'userPatchInput' is not null or undefined
            assertParamExists('patchUser', 'userPatchInput', userPatchInput)
            const localVarPath = `/admin/users/{user_identifier}`
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {AdminPatchInput} adminPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserAdmin: async (userIdentifier: string, adminPatchInput: AdminPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('patchUserAdmin', 'userIdentifier', userIdentifier)
            // verify required parameter 'adminPatchInput' is not null or undefined
            assertParamExists('patchUserAdmin', 'adminPatchInput', adminPatchInput)
            const localVarPath = `/admin/users/{user_identifier}/admin`
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVariable: async (variableIdentifier: string, variablePatchInput: VariablePatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('patchVariable', 'variableIdentifier', variableIdentifier)
            // verify required parameter 'variablePatchInput' is not null or undefined
            assertParamExists('patchVariable', 'variablePatchInput', variablePatchInput)
            const localVarPath = `/admin/variables/{variable_identifier}`
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variablePatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreateInput} userCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser: async (userCreateInput: UserCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateInput' is not null or undefined
            assertParamExists('postUser', 'userCreateInput', userCreateInput)
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariable: async (variableCreateInput: VariableCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableCreateInput' is not null or undefined
            assertParamExists('postVariable', 'variableCreateInput', variableCreateInput)
            const localVarPath = `/admin/variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRunner(runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRunner(runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVariable(variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVariable(variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResetedRunnerRegisterToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResetedRunnerRegisterToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getResetedRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunner(runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunner(runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerRegisterToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerRegisterToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunners(page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunnerCreator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunners(page, size, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getRunners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {OrderOption} [order] 
         * @param {UserSort} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(page?: number, size?: number, query?: string, order?: OrderOption, sort?: UserSort, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(page, size, query, order, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariable(variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariable(variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariables(page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariableGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariables(page, size, query, types, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRunner(runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRunner(runnerUuid, runnerPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.patchRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {UserPatchInput} userPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUser(userIdentifier: string, userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUser(userIdentifier, userPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.patchUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {AdminPatchInput} adminPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserAdmin(userIdentifier: string, adminPatchInput: AdminPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUserAdmin(userIdentifier, adminPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.patchUserAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchVariable(variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchVariable(variableIdentifier, variablePatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.patchVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreateInput} userCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUser(userCreateInput: UserCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUser(userCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.postUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVariable(variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postVariable(variableCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.postVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroup(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner(runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRunner(runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(userIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable(variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVariable(variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupModel>> {
            return localVarFp.getGroups(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResetedRunnerRegisterToken(options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getResetedRunnerRegisterToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner(runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.getRunner(runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerRegisterToken(options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getRunnerRegisterToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunners(page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunnerCreator>> {
            return localVarFp.getRunners(page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: RawAxiosRequestConfig): AxiosPromise<AdminStats> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.getUser(userIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {OrderOption} [order] 
         * @param {UserSort} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(page?: number, size?: number, query?: string, order?: OrderOption, sort?: UserSort, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserModel>> {
            return localVarFp.getUsers(page, size, query, order, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariable(variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.getVariable(variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariableGroup>> {
            return localVarFp.getVariables(page, size, query, types, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRunner(runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.patchRunner(runnerUuid, runnerPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {UserPatchInput} userPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser(userIdentifier: string, userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.patchUser(userIdentifier, userPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {AdminPatchInput} adminPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserAdmin(userIdentifier: string, adminPatchInput: AdminPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.patchUserAdmin(userIdentifier, adminPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVariable(variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.patchVariable(variableIdentifier, variablePatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreateInput} userCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(userCreateInput: UserCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.postUser(userCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariable(variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.postVariable(variableCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @param {string} groupRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteGroup(groupRef: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteGroup(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRunner(runnerUuid: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteRunner(runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUser(userIdentifier: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteUser(userIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteVariable(variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteVariable(variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {GroupSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getGroups(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getResetedRunnerRegisterToken(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getResetedRunnerRegisterToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRunner(runnerUuid: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getRunner(runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRunnerRegisterToken(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getRunnerRegisterToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRunners(page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getRunners(page, size, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStats(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUser(userIdentifier: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUser(userIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {OrderOption} [order] 
     * @param {UserSort} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsers(page?: number, size?: number, query?: string, order?: OrderOption, sort?: UserSort, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUsers(page, size, query, order, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVariable(variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getVariable(variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<VariableType>} [types] 
     * @param {VariableSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVariables(page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getVariables(page, size, query, types, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} runnerUuid 
     * @param {RunnerPatchInput} runnerPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchRunner(runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).patchRunner(runnerUuid, runnerPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userIdentifier 
     * @param {UserPatchInput} userPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchUser(userIdentifier: string, userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).patchUser(userIdentifier, userPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userIdentifier 
     * @param {AdminPatchInput} adminPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchUserAdmin(userIdentifier: string, adminPatchInput: AdminPatchInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).patchUserAdmin(userIdentifier, adminPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} variableIdentifier 
     * @param {VariablePatchInput} variablePatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchVariable(variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).patchVariable(variableIdentifier, variablePatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreateInput} userCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUser(userCreateInput: UserCreateInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).postUser(userCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VariableCreateInput} variableCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postVariable(variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).postVariable(variableCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BootstrapApi - axios parameter creator
 */
export const BootstrapApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} bootstrapRef Group path (eg: \&#39;/group1/group2\&#39;), or repository path (eg: \&#39;/group1/group2/repo\&#39;), or username
         * @param {string | null} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBootstrap: async (bootstrapRef: string, path: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bootstrapRef' is not null or undefined
            assertParamExists('getBootstrap', 'bootstrapRef', bootstrapRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getBootstrap', 'path', path)
            const localVarPath = `/bootstrap/{bootstrap_ref}/+/{path}`
                .replace(`{${"bootstrap_ref"}}`, encodeURIComponent(String(bootstrapRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BootstrapApi - functional programming interface
 */
export const BootstrapApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BootstrapApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} bootstrapRef Group path (eg: \&#39;/group1/group2\&#39;), or repository path (eg: \&#39;/group1/group2/repo\&#39;), or username
         * @param {string | null} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBootstrap(bootstrapRef: string, path: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BootstrapMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBootstrap(bootstrapRef, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BootstrapApi.getBootstrap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BootstrapApi - factory interface
 */
export const BootstrapApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BootstrapApiFp(configuration)
    return {
        /**
         * 
         * @param {string} bootstrapRef Group path (eg: \&#39;/group1/group2\&#39;), or repository path (eg: \&#39;/group1/group2/repo\&#39;), or username
         * @param {string | null} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBootstrap(bootstrapRef: string, path: string | null, options?: RawAxiosRequestConfig): AxiosPromise<BootstrapMetadata> {
            return localVarFp.getBootstrap(bootstrapRef, path, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BootstrapApi - object-oriented interface
 */
export class BootstrapApi extends BaseAPI {
    /**
     * 
     * @param {string} bootstrapRef Group path (eg: \&#39;/group1/group2\&#39;), or repository path (eg: \&#39;/group1/group2/repo\&#39;), or username
     * @param {string | null} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBootstrap(bootstrapRef: string, path: string | null, options?: RawAxiosRequestConfig) {
        return BootstrapApiFp(this.configuration).getBootstrap(bootstrapRef, path, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectorsApi - axios parameter creator
 */
export const ConnectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector: async (connectorRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorRef' is not null or undefined
            assertParamExists('deleteConnector', 'connectorRef', connectorRef)
            const localVarPath = `/connectors/{connector_ref}`
                .replace(`{${"connector_ref"}}`, encodeURIComponent(String(connectorRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: async (connectorRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorRef' is not null or undefined
            assertParamExists('getConnector', 'connectorRef', connectorRef)
            const localVarPath = `/connectors/{connector_ref}`
                .replace(`{${"connector_ref"}}`, encodeURIComponent(String(connectorRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {ConnectorPatchInput} connectorPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnector: async (connectorRef: string, connectorPatchInput: ConnectorPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorRef' is not null or undefined
            assertParamExists('patchConnector', 'connectorRef', connectorRef)
            // verify required parameter 'connectorPatchInput' is not null or undefined
            assertParamExists('patchConnector', 'connectorPatchInput', connectorPatchInput)
            const localVarPath = `/connectors/{connector_ref}`
                .replace(`{${"connector_ref"}}`, encodeURIComponent(String(connectorRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConnectorCreateInput} connectorCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConnector: async (connectorCreateInput: ConnectorCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorCreateInput' is not null or undefined
            assertParamExists('postConnector', 'connectorCreateInput', connectorCreateInput)
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsApi - functional programming interface
 */
export const ConnectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnector(connectorRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnector(connectorRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.deleteConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnector(connectorRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnector(connectorRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {ConnectorPatchInput} connectorPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchConnector(connectorRef: string, connectorPatchInput: ConnectorPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchConnector(connectorRef, connectorPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.patchConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ConnectorCreateInput} connectorCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postConnector(connectorCreateInput: ConnectorCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postConnector(connectorCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.postConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorsApi - factory interface
 */
export const ConnectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector(connectorRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteConnector(connectorRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector(connectorRef: string, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorModel> {
            return localVarFp.getConnector(connectorRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {ConnectorPatchInput} connectorPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnector(connectorRef: string, connectorPatchInput: ConnectorPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorModel> {
            return localVarFp.patchConnector(connectorRef, connectorPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConnectorCreateInput} connectorCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConnector(connectorCreateInput: ConnectorCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorModel> {
            return localVarFp.postConnector(connectorCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorsApi - object-oriented interface
 */
export class ConnectorsApi extends BaseAPI {
    /**
     * 
     * @param {string} connectorRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteConnector(connectorRef: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).deleteConnector(connectorRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectorRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConnector(connectorRef: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnector(connectorRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectorRef 
     * @param {ConnectorPatchInput} connectorPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchConnector(connectorRef: string, connectorPatchInput: ConnectorPatchInput, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).patchConnector(connectorRef, connectorPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConnectorCreateInput} connectorCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postConnector(connectorCreateInput: ConnectorCreateInput, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).postConnector(connectorCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsApi - axios parameter creator
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsRunner: async (groupRef: string, runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('deleteGroupsRunner', 'groupRef', groupRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('deleteGroupsRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/groups/{group_ref}/+/runners/{runner_uuid}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsVariable: async (groupRef: string, variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('deleteGroupsVariable', 'groupRef', groupRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('deleteGroupsVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/groups/{group_ref}/+/variables/{variable_identifier}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (groupRef: string, userIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('deleteMember', 'groupRef', groupRef)
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('deleteMember', 'userIdentifier', userIdentifier)
            const localVarPath = `/groups/{group_ref}/+/members/{user_identifier}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors: async (groupRef: string, page?: number, size?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getConnectors', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/connectors`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getEvents', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/events`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroup', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsResetedRunnerRegisterToken: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsResetedRunnerRegisterToken', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/runners/register_token/reseted`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunner: async (groupRef: string, runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsRunner', 'groupRef', groupRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('getGroupsRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/groups/{group_ref}/+/runners/{runner_uuid}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunnerRegisterToken: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsRunnerRegisterToken', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/runners/register_token`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunners: async (groupRef: string, page?: number, size?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsRunners', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/runners`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsVariable: async (groupRef: string, variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsVariable', 'groupRef', groupRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('getGroupsVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/groups/{group_ref}/+/variables/{variable_identifier}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsVariables: async (groupRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsVariables', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/variables`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers: async (groupRef: string, page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getMembers', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/members`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepos: async (groupRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getRepos', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/repos`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccounts: async (groupRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getServiceAccounts', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/service-accounts`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubGroups: async (groupRef: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getSubGroups', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/groups`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupPatchInput} groupPatchInput Group update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroup: async (groupRef: string, groupPatchInput: GroupPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('patchGroup', 'groupRef', groupRef)
            // verify required parameter 'groupPatchInput' is not null or undefined
            assertParamExists('patchGroup', 'groupPatchInput', groupPatchInput)
            const localVarPath = `/groups/{group_ref}/+`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroupsRunner: async (groupRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('patchGroupsRunner', 'groupRef', groupRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('patchGroupsRunner', 'runnerUuid', runnerUuid)
            // verify required parameter 'runnerPatchInput' is not null or undefined
            assertParamExists('patchGroupsRunner', 'runnerPatchInput', runnerPatchInput)
            const localVarPath = `/groups/{group_ref}/+/runners/{runner_uuid}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroupsVariable: async (groupRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('patchGroupsVariable', 'groupRef', groupRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('patchGroupsVariable', 'variableIdentifier', variableIdentifier)
            // verify required parameter 'variablePatchInput' is not null or undefined
            assertParamExists('patchGroupsVariable', 'variablePatchInput', variablePatchInput)
            const localVarPath = `/groups/{group_ref}/+/variables/{variable_identifier}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variablePatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {GroupMemberUpdateInput} groupMemberUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMember: async (groupRef: string, userIdentifier: string, groupMemberUpdateInput: GroupMemberUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('patchMember', 'groupRef', groupRef)
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('patchMember', 'userIdentifier', userIdentifier)
            // verify required parameter 'groupMemberUpdateInput' is not null or undefined
            assertParamExists('patchMember', 'groupMemberUpdateInput', groupMemberUpdateInput)
            const localVarPath = `/groups/{group_ref}/+/members/{user_identifier}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupMemberUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GroupCreateInput} groupCreateInput Group creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroup: async (groupCreateInput: GroupCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupCreateInput' is not null or undefined
            assertParamExists('postGroup', 'groupCreateInput', groupCreateInput)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsVariable: async (groupRef: string, variableCreateInput: VariableCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postGroupsVariable', 'groupRef', groupRef)
            // verify required parameter 'variableCreateInput' is not null or undefined
            assertParamExists('postGroupsVariable', 'variableCreateInput', variableCreateInput)
            const localVarPath = `/groups/{group_ref}/+/variables`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GroupImportInput} groupImportInput Group import request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImport: async (groupImportInput: GroupImportInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupImportInput' is not null or undefined
            assertParamExists('postImport', 'groupImportInput', groupImportInput)
            const localVarPath = `/groups/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupImportInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupImportReposInput} groupImportReposInput Group import repositories request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImportRepos: async (groupRef: string, groupImportReposInput: GroupImportReposInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postImportRepos', 'groupRef', groupRef)
            // verify required parameter 'groupImportReposInput' is not null or undefined
            assertParamExists('postImportRepos', 'groupImportReposInput', groupImportReposInput)
            const localVarPath = `/groups/{group_ref}/+/import`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupImportReposInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMemberAddInput} groupMemberAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMember: async (groupRef: string, groupMemberAddInput: GroupMemberAddInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postMember', 'groupRef', groupRef)
            // verify required parameter 'groupMemberAddInput' is not null or undefined
            assertParamExists('postMember', 'groupMemberAddInput', groupMemberAddInput)
            const localVarPath = `/groups/{group_ref}/+/members`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupMemberAddInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMoveInput} groupMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMove: async (groupRef: string, groupMoveInput: GroupMoveInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postMove', 'groupRef', groupRef)
            // verify required parameter 'groupMoveInput' is not null or undefined
            assertParamExists('postMove', 'groupMoveInput', groupMoveInput)
            const localVarPath = `/groups/{group_ref}/+/move`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupMoveInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPurge: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postPurge', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/purge`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupRestoreInput} groupRestoreInput Group restore request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRestore: async (groupRef: string, groupRestoreInput: GroupRestoreInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postRestore', 'groupRef', groupRef)
            // verify required parameter 'groupRestoreInput' is not null or undefined
            assertParamExists('postRestore', 'groupRestoreInput', groupRestoreInput)
            const localVarPath = `/groups/{group_ref}/+/restore`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupRestoreInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softDelete: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('softDelete', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupsRunner(groupRef, runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteGroupsRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupsVariable(groupRef, variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteGroupsVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(groupRef: string, userIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(groupRef, userIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectors(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectors(groupRef, page, size, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getConnectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsResetedRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsResetedRunnerRegisterToken(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsResetedRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsRunner(groupRef, runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsRunnerRegisterToken(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsRunners(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunnerCreator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsRunners(groupRef, page, size, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsRunners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsVariable(groupRef, variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsVariables(groupRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariableGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsVariables(groupRef, page, size, query, types, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembers(groupRef: string, page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MembershipUserGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembers(groupRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepos(groupRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoParent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepos(groupRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAccounts(groupRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAccounts(groupRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getServiceAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubGroups(groupRef: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubGroups(groupRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getSubGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupPatchInput} groupPatchInput Group update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchGroup(groupRef: string, groupPatchInput: GroupPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchGroup(groupRef, groupPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.patchGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchGroupsRunner(groupRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchGroupsRunner(groupRef, runnerUuid, runnerPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.patchGroupsRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchGroupsVariable(groupRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchGroupsVariable(groupRef, variableIdentifier, variablePatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.patchGroupsVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {GroupMemberUpdateInput} groupMemberUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMember(groupRef: string, userIdentifier: string, groupMemberUpdateInput: GroupMemberUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MembershipModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMember(groupRef, userIdentifier, groupMemberUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.patchMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GroupCreateInput} groupCreateInput Group creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGroup(groupCreateInput: GroupCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGroup(groupCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGroupsVariable(groupRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGroupsVariable(groupRef, variableCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postGroupsVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GroupImportInput} groupImportInput Group import request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImport(groupImportInput: GroupImportInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postImport(groupImportInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupImportReposInput} groupImportReposInput Group import repositories request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImportRepos(groupRef: string, groupImportReposInput: GroupImportReposInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupImportReposOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postImportRepos(groupRef, groupImportReposInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postImportRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMemberAddInput} groupMemberAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMember(groupRef: string, groupMemberAddInput: GroupMemberAddInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MembershipUserGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMember(groupRef, groupMemberAddInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMoveInput} groupMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMove(groupRef: string, groupMoveInput: GroupMoveInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMove(groupRef, groupMoveInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postMove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPurge(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPurge(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postPurge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupRestoreInput} groupRestoreInput Group restore request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRestore(groupRef: string, groupRestoreInput: GroupRestoreInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRestore(groupRef, groupRestoreInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async softDelete(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.softDelete(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.softDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroupsRunner(groupRef, runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroupsVariable(groupRef, variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(groupRef: string, userIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMember(groupRef, userIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConnectorModel>> {
            return localVarFp.getConnectors(groupRef, page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getEvents(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.getGroup(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsResetedRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getGroupsResetedRunnerRegisterToken(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.getGroupsRunner(groupRef, runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getGroupsRunnerRegisterToken(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunners(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunnerCreator>> {
            return localVarFp.getGroupsRunners(groupRef, page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.getGroupsVariable(groupRef, variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsVariables(groupRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariableGroup>> {
            return localVarFp.getGroupsVariables(groupRef, page, size, query, types, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers(groupRef: string, page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<MembershipUserGroup>> {
            return localVarFp.getMembers(groupRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepos(groupRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepoParent>> {
            return localVarFp.getRepos(groupRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccounts(groupRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserModel>> {
            return localVarFp.getServiceAccounts(groupRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubGroups(groupRef: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupModel>> {
            return localVarFp.getSubGroups(groupRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupPatchInput} groupPatchInput Group update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroup(groupRef: string, groupPatchInput: GroupPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.patchGroup(groupRef, groupPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroupsRunner(groupRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.patchGroupsRunner(groupRef, runnerUuid, runnerPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroupsVariable(groupRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.patchGroupsVariable(groupRef, variableIdentifier, variablePatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {GroupMemberUpdateInput} groupMemberUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMember(groupRef: string, userIdentifier: string, groupMemberUpdateInput: GroupMemberUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<MembershipModel> {
            return localVarFp.patchMember(groupRef, userIdentifier, groupMemberUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GroupCreateInput} groupCreateInput Group creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroup(groupCreateInput: GroupCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.postGroup(groupCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsVariable(groupRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.postGroupsVariable(groupRef, variableCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GroupImportInput} groupImportInput Group import request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImport(groupImportInput: GroupImportInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.postImport(groupImportInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupImportReposInput} groupImportReposInput Group import repositories request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImportRepos(groupRef: string, groupImportReposInput: GroupImportReposInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupImportReposOutput> {
            return localVarFp.postImportRepos(groupRef, groupImportReposInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMemberAddInput} groupMemberAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMember(groupRef: string, groupMemberAddInput: GroupMemberAddInput, options?: RawAxiosRequestConfig): AxiosPromise<MembershipUserGroup> {
            return localVarFp.postMember(groupRef, groupMemberAddInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMoveInput} groupMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMove(groupRef: string, groupMoveInput: GroupMoveInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.postMove(groupRef, groupMoveInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPurge(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postPurge(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupRestoreInput} groupRestoreInput Group restore request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRestore(groupRef: string, groupRestoreInput: GroupRestoreInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.postRestore(groupRef, groupRestoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softDelete(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.softDelete(groupRef, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupsRunner(groupRef, runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupsVariable(groupRef, variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} userIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMember(groupRef: string, userIdentifier: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteMember(groupRef, userIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConnectors(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getConnectors(groupRef, page, size, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getEvents(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getEvents(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroup(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroup(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroupsResetedRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsResetedRunnerRegisterToken(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsRunner(groupRef, runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroupsRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsRunnerRegisterToken(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroupsRunners(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsRunners(groupRef, page, size, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsVariable(groupRef, variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<VariableType>} [types] 
     * @param {VariableSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroupsVariables(groupRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsVariables(groupRef, page, size, query, types, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {MembershipSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMembers(groupRef: string, page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getMembers(groupRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepos(groupRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getRepos(groupRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {UserSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServiceAccounts(groupRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getServiceAccounts(groupRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {GroupSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSubGroups(groupRef: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getSubGroups(groupRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {GroupPatchInput} groupPatchInput Group update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchGroup(groupRef: string, groupPatchInput: GroupPatchInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).patchGroup(groupRef, groupPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} runnerUuid 
     * @param {RunnerPatchInput} runnerPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchGroupsRunner(groupRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).patchGroupsRunner(groupRef, runnerUuid, runnerPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} variableIdentifier 
     * @param {VariablePatchInput} variablePatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchGroupsVariable(groupRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).patchGroupsVariable(groupRef, variableIdentifier, variablePatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} userIdentifier 
     * @param {GroupMemberUpdateInput} groupMemberUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchMember(groupRef: string, userIdentifier: string, groupMemberUpdateInput: GroupMemberUpdateInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).patchMember(groupRef, userIdentifier, groupMemberUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GroupCreateInput} groupCreateInput Group creation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postGroup(groupCreateInput: GroupCreateInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postGroup(groupCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {VariableCreateInput} variableCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postGroupsVariable(groupRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postGroupsVariable(groupRef, variableCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GroupImportInput} groupImportInput Group import request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postImport(groupImportInput: GroupImportInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postImport(groupImportInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {GroupImportReposInput} groupImportReposInput Group import repositories request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postImportRepos(groupRef: string, groupImportReposInput: GroupImportReposInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postImportRepos(groupRef, groupImportReposInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {GroupMemberAddInput} groupMemberAddInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postMember(groupRef: string, groupMemberAddInput: GroupMemberAddInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postMember(groupRef, groupMemberAddInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {GroupMoveInput} groupMoveInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postMove(groupRef: string, groupMoveInput: GroupMoveInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postMove(groupRef, groupMoveInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPurge(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postPurge(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {GroupRestoreInput} groupRestoreInput Group restore request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRestore(groupRef: string, groupRestoreInput: GroupRestoreInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postRestore(groupRef, groupRestoreInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public softDelete(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).softDelete(groupRef, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KeywordSearchApi - axios parameter creator
 */
export const KeywordSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeywordSearchApi - functional programming interface
 */
export const KeywordSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeywordSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordSearchApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KeywordSearchApi - factory interface
 */
export const KeywordSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeywordSearchApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.search(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeywordSearchApi - object-oriented interface
 */
export class KeywordSearchApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public search(options?: RawAxiosRequestConfig) {
        return KeywordSearchApiFp(this.configuration).search(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PullRequestApi - axios parameter creator
 */
export const PullRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment: async (repoRef: string, pullreqNumber: number, pullreqCommentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteComment', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('deleteComment', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqCommentId' is not null or undefined
            assertParamExists('deleteComment', 'pullreqCommentId', pullreqCommentId)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/comments/{pullreq_comment_id}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)))
                .replace(`{${"pullreq_comment_id"}}`, encodeURIComponent(String(pullreqCommentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileView: async (repoRef: string, pullreqNumber: number, path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteFileView', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('deleteFileView', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('deleteFileView', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/file-views/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqReviewerId Pull request reviewer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewer: async (repoRef: string, pullreqNumber: number, pullreqReviewerId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteReviewer', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('deleteReviewer', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqReviewerId' is not null or undefined
            assertParamExists('deleteReviewer', 'pullreqReviewerId', pullreqReviewerId)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/reviewers/{pullreq_reviewer_id}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)))
                .replace(`{${"pullreq_reviewer_id"}}`, encodeURIComponent(String(pullreqReviewerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {number} [after] 
         * @param {number} [before] 
         * @param {Array<PullreqActivityType>} [types] 
         * @param {Array<PullreqActivityKind>} [kinds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities: async (repoRef: string, pullreqNumber: number, page?: number, size?: number, query?: string, after?: number, before?: number, types?: Array<PullreqActivityType>, kinds?: Array<PullreqActivityKind>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getActivities', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getActivities', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/activities`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (kinds) {
                localVarQueryParameter['kinds'] = kinds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeOwners: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCodeOwners', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getCodeOwners', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/codeowners`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileViews: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getFileViews', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getFileViews', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/file-views`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getMetadata', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getMetadata', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/metadata`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequestChecks: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getPullRequestChecks', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getPullRequestChecks', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/checks`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequestCommits: async (repoRef: string, pullreqNumber: number, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getPullRequestCommits', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getPullRequestCommits', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/commits`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullreq: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getPullreq', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getPullreq', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<number>} [createdBy] 
         * @param {string} [sourceRepoRef] 
         * @param {string} [sourceBranch] 
         * @param {string} [targetBranch] 
         * @param {Array<PullreqState>} [states] 
         * @param {PullreqSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {number} [createdGt] 
         * @param {number} [createdLt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullreqs: async (repoRef: string, page?: number, size?: number, query?: string, createdBy?: Array<number>, sourceRepoRef?: string, sourceBranch?: string, targetBranch?: string, states?: Array<PullreqState>, sort?: PullreqSort, order?: OrderOption, createdGt?: number, createdLt?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getPullreqs', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/pullreq`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (createdBy) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (sourceRepoRef !== undefined) {
                localVarQueryParameter['source_repo_ref'] = sourceRepoRef;
            }

            if (sourceBranch !== undefined) {
                localVarQueryParameter['source_branch'] = sourceBranch;
            }

            if (targetBranch !== undefined) {
                localVarQueryParameter['target_branch'] = targetBranch;
            }

            if (states) {
                localVarQueryParameter['states'] = states;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (createdGt !== undefined) {
                localVarQueryParameter['created_gt'] = createdGt;
            }

            if (createdLt !== undefined) {
                localVarQueryParameter['created_lt'] = createdLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewers: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getReviewers', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getReviewers', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/reviewers`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentUpdateInput} pullreqCommentUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchComment: async (repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentUpdateInput: PullreqCommentUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchComment', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('patchComment', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqCommentId' is not null or undefined
            assertParamExists('patchComment', 'pullreqCommentId', pullreqCommentId)
            // verify required parameter 'pullreqCommentUpdateInput' is not null or undefined
            assertParamExists('patchComment', 'pullreqCommentUpdateInput', pullreqCommentUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/comments/{pullreq_comment_id}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)))
                .replace(`{${"pullreq_comment_id"}}`, encodeURIComponent(String(pullreqCommentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqCommentUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqUpdateInput} pullreqUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPullreq: async (repoRef: string, pullreqNumber: number, pullreqUpdateInput: PullreqUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchPullreq', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('patchPullreq', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqUpdateInput' is not null or undefined
            assertParamExists('patchPullreq', 'pullreqUpdateInput', pullreqUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqApplySuggestionsInput} pullreqApplySuggestionsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplySuggestions: async (repoRef: string, pullreqNumber: number, pullreqApplySuggestionsInput: PullreqApplySuggestionsInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postApplySuggestions', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postApplySuggestions', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqApplySuggestionsInput' is not null or undefined
            assertParamExists('postApplySuggestions', 'pullreqApplySuggestionsInput', pullreqApplySuggestionsInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/comments/apply-suggestions`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqApplySuggestionsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqCommentCreateInput} pullreqCommentCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment: async (repoRef: string, pullreqNumber: number, pullreqCommentCreateInput: PullreqCommentCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postComment', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postComment', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqCommentCreateInput' is not null or undefined
            assertParamExists('postComment', 'pullreqCommentCreateInput', pullreqCommentCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/comments`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqCommentCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiff: async (repoRef: string, pullreqNumber: number, commitDiffFile: Array<CommitDiffFile>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postDiff', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postDiff', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'commitDiffFile' is not null or undefined
            assertParamExists('postDiff', 'commitDiffFile', commitDiffFile)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/diff`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commitDiffFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqMergeInput} pullreqMergeInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMerge: async (repoRef: string, pullreqNumber: number, pullreqMergeInput: PullreqMergeInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postMerge', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postMerge', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqMergeInput' is not null or undefined
            assertParamExists('postMerge', 'pullreqMergeInput', pullreqMergeInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/merge`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqMergeInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {PullreqCreateInput} pullreqCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPullreq: async (repoRef: string, pullreqCreateInput: PullreqCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postPullreq', 'repoRef', repoRef)
            // verify required parameter 'pullreqCreateInput' is not null or undefined
            assertParamExists('postPullreq', 'pullreqCreateInput', pullreqCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewSubmitInput} pullreqReviewSubmitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReviews: async (repoRef: string, pullreqNumber: number, pullreqReviewSubmitInput: PullreqReviewSubmitInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postReviews', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postReviews', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqReviewSubmitInput' is not null or undefined
            assertParamExists('postReviews', 'pullreqReviewSubmitInput', pullreqReviewSubmitInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/reviews`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqReviewSubmitInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqStateUpdateInput} pullreqStateUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postState: async (repoRef: string, pullreqNumber: number, pullreqStateUpdateInput: PullreqStateUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postState', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postState', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqStateUpdateInput' is not null or undefined
            assertParamExists('postState', 'pullreqStateUpdateInput', pullreqStateUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/state`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqStateUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentStatusInput} pullreqCommentStatusInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCommentStatus: async (repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentStatusInput: PullreqCommentStatusInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('putCommentStatus', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('putCommentStatus', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqCommentId' is not null or undefined
            assertParamExists('putCommentStatus', 'pullreqCommentId', pullreqCommentId)
            // verify required parameter 'pullreqCommentStatusInput' is not null or undefined
            assertParamExists('putCommentStatus', 'pullreqCommentStatusInput', pullreqCommentStatusInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/comments/{pullreq_comment_id}/status`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)))
                .replace(`{${"pullreq_comment_id"}}`, encodeURIComponent(String(pullreqCommentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqCommentStatusInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqFileViewCreateInput} pullreqFileViewCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileViews: async (repoRef: string, pullreqNumber: number, pullreqFileViewCreateInput: PullreqFileViewCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('putFileViews', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('putFileViews', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqFileViewCreateInput' is not null or undefined
            assertParamExists('putFileViews', 'pullreqFileViewCreateInput', pullreqFileViewCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/file-views`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqFileViewCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewerAddInput} pullreqReviewerAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putReviewer: async (repoRef: string, pullreqNumber: number, pullreqReviewerAddInput: PullreqReviewerAddInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('putReviewer', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('putReviewer', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqReviewerAddInput' is not null or undefined
            assertParamExists('putReviewer', 'pullreqReviewerAddInput', pullreqReviewerAddInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/reviewers`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqReviewerAddInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PullRequestApi - functional programming interface
 */
export const PullRequestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PullRequestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(repoRef, pullreqNumber, pullreqCommentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.deleteComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileView(repoRef: string, pullreqNumber: number, path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileView(repoRef, pullreqNumber, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.deleteFileView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqReviewerId Pull request reviewer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReviewer(repoRef, pullreqNumber, pullreqReviewerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.deleteReviewer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {number} [after] 
         * @param {number} [before] 
         * @param {Array<PullreqActivityType>} [types] 
         * @param {Array<PullreqActivityKind>} [kinds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivities(repoRef: string, pullreqNumber: number, page?: number, size?: number, query?: string, after?: number, before?: number, types?: Array<PullreqActivityType>, kinds?: Array<PullreqActivityKind>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullreqActivityRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(repoRef, pullreqNumber, page, size, query, after, before, types, kinds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodeOwners(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeOwnerEvaluation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodeOwners(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getCodeOwners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileViews(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullreqFileViewModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileViews(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getFileViews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqWithDiffStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullRequestChecks(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqChecksOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullRequestChecks(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getPullRequestChecks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullRequestCommits(repoRef: string, pullreqNumber: number, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Commit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullRequestCommits(repoRef, pullreqNumber, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getPullRequestCommits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullreq(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqWithDiffStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullreq(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getPullreq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<number>} [createdBy] 
         * @param {string} [sourceRepoRef] 
         * @param {string} [sourceBranch] 
         * @param {string} [targetBranch] 
         * @param {Array<PullreqState>} [states] 
         * @param {PullreqSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {number} [createdGt] 
         * @param {number} [createdLt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullreqs(repoRef: string, page?: number, size?: number, query?: string, createdBy?: Array<number>, sourceRepoRef?: string, sourceBranch?: string, targetBranch?: string, states?: Array<PullreqState>, sort?: PullreqSort, order?: OrderOption, createdGt?: number, createdLt?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullreqWithDiffStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullreqs(repoRef, page, size, query, createdBy, sourceRepoRef, sourceBranch, targetBranch, states, sort, order, createdGt, createdLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getPullreqs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewers(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullreqReviewerUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewers(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getReviewers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentUpdateInput} pullreqCommentUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentUpdateInput: PullreqCommentUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqActivityModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchComment(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.patchComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqUpdateInput} pullreqUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchPullreq(repoRef: string, pullreqNumber: number, pullreqUpdateInput: PullreqUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPullreq(repoRef, pullreqNumber, pullreqUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.patchPullreq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqApplySuggestionsInput} pullreqApplySuggestionsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApplySuggestions(repoRef: string, pullreqNumber: number, pullreqApplySuggestionsInput: PullreqApplySuggestionsInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqApplySuggestionsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApplySuggestions(repoRef, pullreqNumber, pullreqApplySuggestionsInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postApplySuggestions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqCommentCreateInput} pullreqCommentCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postComment(repoRef: string, pullreqNumber: number, pullreqCommentCreateInput: PullreqCommentCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqActivityModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postComment(repoRef, pullreqNumber, pullreqCommentCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDiff(repoRef: string, pullreqNumber: number, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDiff(repoRef, pullreqNumber, commitDiffFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postDiff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqMergeInput} pullreqMergeInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMerge(repoRef: string, pullreqNumber: number, pullreqMergeInput: PullreqMergeInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqMergeOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMerge(repoRef, pullreqNumber, pullreqMergeInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postMerge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {PullreqCreateInput} pullreqCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPullreq(repoRef: string, pullreqCreateInput: PullreqCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPullreq(repoRef, pullreqCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postPullreq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewSubmitInput} pullreqReviewSubmitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postReviews(repoRef: string, pullreqNumber: number, pullreqReviewSubmitInput: PullreqReviewSubmitInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqReviewModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postReviews(repoRef, pullreqNumber, pullreqReviewSubmitInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postReviews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqStateUpdateInput} pullreqStateUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postState(repoRef: string, pullreqNumber: number, pullreqStateUpdateInput: PullreqStateUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postState(repoRef, pullreqNumber, pullreqStateUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentStatusInput} pullreqCommentStatusInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCommentStatus(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentStatusInput: PullreqCommentStatusInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqActivityModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCommentStatus(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentStatusInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.putCommentStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqFileViewCreateInput} pullreqFileViewCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFileViews(repoRef: string, pullreqNumber: number, pullreqFileViewCreateInput: PullreqFileViewCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqFileViewModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFileViews(repoRef, pullreqNumber, pullreqFileViewCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.putFileViews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewerAddInput} pullreqReviewerAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerAddInput: PullreqReviewerAddInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqReviewerUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putReviewer(repoRef, pullreqNumber, pullreqReviewerAddInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.putReviewer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PullRequestApi - factory interface
 */
export const PullRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PullRequestApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteComment(repoRef, pullreqNumber, pullreqCommentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileView(repoRef: string, pullreqNumber: number, path: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFileView(repoRef, pullreqNumber, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqReviewerId Pull request reviewer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteReviewer(repoRef, pullreqNumber, pullreqReviewerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {number} [after] 
         * @param {number} [before] 
         * @param {Array<PullreqActivityType>} [types] 
         * @param {Array<PullreqActivityKind>} [kinds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(repoRef: string, pullreqNumber: number, page?: number, size?: number, query?: string, after?: number, before?: number, types?: Array<PullreqActivityType>, kinds?: Array<PullreqActivityKind>, options?: RawAxiosRequestConfig): AxiosPromise<Array<PullreqActivityRelations>> {
            return localVarFp.getActivities(repoRef, pullreqNumber, page, size, query, after, before, types, kinds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeOwners(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<CodeOwnerEvaluation> {
            return localVarFp.getCodeOwners(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileViews(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PullreqFileViewModel>> {
            return localVarFp.getFileViews(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<PullreqWithDiffStats> {
            return localVarFp.getMetadata(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequestChecks(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<PullreqChecksOutput> {
            return localVarFp.getPullRequestChecks(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequestCommits(repoRef: string, pullreqNumber: number, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Commit>> {
            return localVarFp.getPullRequestCommits(repoRef, pullreqNumber, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullreq(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<PullreqWithDiffStats> {
            return localVarFp.getPullreq(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<number>} [createdBy] 
         * @param {string} [sourceRepoRef] 
         * @param {string} [sourceBranch] 
         * @param {string} [targetBranch] 
         * @param {Array<PullreqState>} [states] 
         * @param {PullreqSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {number} [createdGt] 
         * @param {number} [createdLt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullreqs(repoRef: string, page?: number, size?: number, query?: string, createdBy?: Array<number>, sourceRepoRef?: string, sourceBranch?: string, targetBranch?: string, states?: Array<PullreqState>, sort?: PullreqSort, order?: OrderOption, createdGt?: number, createdLt?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PullreqWithDiffStats>> {
            return localVarFp.getPullreqs(repoRef, page, size, query, createdBy, sourceRepoRef, sourceBranch, targetBranch, states, sort, order, createdGt, createdLt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewers(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PullreqReviewerUser>> {
            return localVarFp.getReviewers(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentUpdateInput} pullreqCommentUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentUpdateInput: PullreqCommentUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqActivityModel> {
            return localVarFp.patchComment(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqUpdateInput} pullreqUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPullreq(repoRef: string, pullreqNumber: number, pullreqUpdateInput: PullreqUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqModel> {
            return localVarFp.patchPullreq(repoRef, pullreqNumber, pullreqUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqApplySuggestionsInput} pullreqApplySuggestionsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplySuggestions(repoRef: string, pullreqNumber: number, pullreqApplySuggestionsInput: PullreqApplySuggestionsInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqApplySuggestionsOutput> {
            return localVarFp.postApplySuggestions(repoRef, pullreqNumber, pullreqApplySuggestionsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqCommentCreateInput} pullreqCommentCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment(repoRef: string, pullreqNumber: number, pullreqCommentCreateInput: PullreqCommentCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqActivityModel> {
            return localVarFp.postComment(repoRef, pullreqNumber, pullreqCommentCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiff(repoRef: string, pullreqNumber: number, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.postDiff(repoRef, pullreqNumber, commitDiffFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqMergeInput} pullreqMergeInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMerge(repoRef: string, pullreqNumber: number, pullreqMergeInput: PullreqMergeInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqMergeOutput> {
            return localVarFp.postMerge(repoRef, pullreqNumber, pullreqMergeInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {PullreqCreateInput} pullreqCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPullreq(repoRef: string, pullreqCreateInput: PullreqCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqModel> {
            return localVarFp.postPullreq(repoRef, pullreqCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewSubmitInput} pullreqReviewSubmitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReviews(repoRef: string, pullreqNumber: number, pullreqReviewSubmitInput: PullreqReviewSubmitInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqReviewModel> {
            return localVarFp.postReviews(repoRef, pullreqNumber, pullreqReviewSubmitInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqStateUpdateInput} pullreqStateUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postState(repoRef: string, pullreqNumber: number, pullreqStateUpdateInput: PullreqStateUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqModel> {
            return localVarFp.postState(repoRef, pullreqNumber, pullreqStateUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentStatusInput} pullreqCommentStatusInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCommentStatus(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentStatusInput: PullreqCommentStatusInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqActivityModel> {
            return localVarFp.putCommentStatus(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentStatusInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqFileViewCreateInput} pullreqFileViewCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileViews(repoRef: string, pullreqNumber: number, pullreqFileViewCreateInput: PullreqFileViewCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqFileViewModel> {
            return localVarFp.putFileViews(repoRef, pullreqNumber, pullreqFileViewCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewerAddInput} pullreqReviewerAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerAddInput: PullreqReviewerAddInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqReviewerUser> {
            return localVarFp.putReviewer(repoRef, pullreqNumber, pullreqReviewerAddInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PullRequestApi - object-oriented interface
 */
export class PullRequestApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} pullreqCommentId Pull request comment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).deleteComment(repoRef, pullreqNumber, pullreqCommentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFileView(repoRef: string, pullreqNumber: number, path: string, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).deleteFileView(repoRef, pullreqNumber, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} pullreqReviewerId Pull request reviewer id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerId: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).deleteReviewer(repoRef, pullreqNumber, pullreqReviewerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {number} [after] 
     * @param {number} [before] 
     * @param {Array<PullreqActivityType>} [types] 
     * @param {Array<PullreqActivityKind>} [kinds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getActivities(repoRef: string, pullreqNumber: number, page?: number, size?: number, query?: string, after?: number, before?: number, types?: Array<PullreqActivityType>, kinds?: Array<PullreqActivityKind>, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getActivities(repoRef, pullreqNumber, page, size, query, after, before, types, kinds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCodeOwners(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getCodeOwners(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFileViews(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getFileViews(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMetadata(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getMetadata(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPullRequestChecks(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getPullRequestChecks(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPullRequestCommits(repoRef: string, pullreqNumber: number, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getPullRequestCommits(repoRef, pullreqNumber, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPullreq(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getPullreq(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<number>} [createdBy] 
     * @param {string} [sourceRepoRef] 
     * @param {string} [sourceBranch] 
     * @param {string} [targetBranch] 
     * @param {Array<PullreqState>} [states] 
     * @param {PullreqSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {number} [createdGt] 
     * @param {number} [createdLt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPullreqs(repoRef: string, page?: number, size?: number, query?: string, createdBy?: Array<number>, sourceRepoRef?: string, sourceBranch?: string, targetBranch?: string, states?: Array<PullreqState>, sort?: PullreqSort, order?: OrderOption, createdGt?: number, createdLt?: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getPullreqs(repoRef, page, size, query, createdBy, sourceRepoRef, sourceBranch, targetBranch, states, sort, order, createdGt, createdLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReviewers(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getReviewers(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} pullreqCommentId Pull request comment id
     * @param {PullreqCommentUpdateInput} pullreqCommentUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentUpdateInput: PullreqCommentUpdateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).patchComment(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqUpdateInput} pullreqUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchPullreq(repoRef: string, pullreqNumber: number, pullreqUpdateInput: PullreqUpdateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).patchPullreq(repoRef, pullreqNumber, pullreqUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqApplySuggestionsInput} pullreqApplySuggestionsInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postApplySuggestions(repoRef: string, pullreqNumber: number, pullreqApplySuggestionsInput: PullreqApplySuggestionsInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postApplySuggestions(repoRef, pullreqNumber, pullreqApplySuggestionsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqCommentCreateInput} pullreqCommentCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postComment(repoRef: string, pullreqNumber: number, pullreqCommentCreateInput: PullreqCommentCreateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postComment(repoRef, pullreqNumber, pullreqCommentCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {Array<CommitDiffFile>} commitDiffFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postDiff(repoRef: string, pullreqNumber: number, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postDiff(repoRef, pullreqNumber, commitDiffFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqMergeInput} pullreqMergeInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postMerge(repoRef: string, pullreqNumber: number, pullreqMergeInput: PullreqMergeInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postMerge(repoRef, pullreqNumber, pullreqMergeInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {PullreqCreateInput} pullreqCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPullreq(repoRef: string, pullreqCreateInput: PullreqCreateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postPullreq(repoRef, pullreqCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqReviewSubmitInput} pullreqReviewSubmitInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postReviews(repoRef: string, pullreqNumber: number, pullreqReviewSubmitInput: PullreqReviewSubmitInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postReviews(repoRef, pullreqNumber, pullreqReviewSubmitInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqStateUpdateInput} pullreqStateUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postState(repoRef: string, pullreqNumber: number, pullreqStateUpdateInput: PullreqStateUpdateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postState(repoRef, pullreqNumber, pullreqStateUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} pullreqCommentId Pull request comment id
     * @param {PullreqCommentStatusInput} pullreqCommentStatusInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putCommentStatus(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentStatusInput: PullreqCommentStatusInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).putCommentStatus(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentStatusInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqFileViewCreateInput} pullreqFileViewCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFileViews(repoRef: string, pullreqNumber: number, pullreqFileViewCreateInput: PullreqFileViewCreateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).putFileViews(repoRef, pullreqNumber, pullreqFileViewCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqReviewerAddInput} pullreqReviewerAddInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerAddInput: PullreqReviewerAddInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).putReviewer(repoRef, pullreqNumber, pullreqReviewerAddInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReleaseUploadApi - axios parameter creator
 */
export const ReleaseUploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUpload: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteUpload', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('deleteUpload', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getAssets', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('getAssets', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases/assets/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getDownload', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('getDownload', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/download/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestore: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRestore', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('getRestore', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headOffset: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('headOffset', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchChunks: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchChunks', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('patchChunks', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpload: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postUpload', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('postUpload', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReleaseUploadApi - functional programming interface
 */
export const ReleaseUploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReleaseUploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUpload(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.deleteUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssets(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssets(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.getAssets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownload(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.getDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRestore(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRestore(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.getRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headOffset(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.headOffset(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.headOffset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchChunks(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchChunks(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.patchChunks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUpload(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.postUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReleaseUploadApi - factory interface
 */
export const ReleaseUploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReleaseUploadApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUpload(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getAssets(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getDownload(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestore(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getRestore(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headOffset(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.headOffset(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchChunks(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.patchChunks(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postUpload(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReleaseUploadApi - object-oriented interface
 */
export class ReleaseUploadApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).deleteUpload(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAssets(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).getAssets(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDownload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).getDownload(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRestore(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).getRestore(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public headOffset(repoRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).headOffset(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchChunks(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).patchChunks(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).postUpload(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoryApi - axios parameter creator
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {CommitFilesInput} commitFilesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitFiles: async (repoRef: string, commitFilesInput: CommitFilesInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('commitFiles', 'repoRef', repoRef)
            // verify required parameter 'commitFilesInput' is not null or undefined
            assertParamExists('commitFiles', 'commitFilesInput', commitFilesInput)
            const localVarPath = `/repos/{repo_ref}/+/commits`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commitFilesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoCommitDivergencesInput} repoCommitDivergencesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsCalculateDivergence: async (repoRef: string, repoCommitDivergencesInput: RepoCommitDivergencesInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('commitsCalculateDivergence', 'repoRef', repoRef)
            // verify required parameter 'repoCommitDivergencesInput' is not null or undefined
            assertParamExists('commitsCalculateDivergence', 'repoCommitDivergencesInput', repoCommitDivergencesInput)
            const localVarPath = `/repos/{repo_ref}/+/commits/calculate-divergence`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoCommitDivergencesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch: async (repoRef: string, branchName: string, bypassRules?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteBranch', 'repoRef', repoRef)
            // verify required parameter 'branchName' is not null or undefined
            assertParamExists('deleteBranch', 'branchName', branchName)
            const localVarPath = `/repos/{repo_ref}/+/branches/{branch_name}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"branch_name"}}`, encodeURIComponent(String(branchName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (bypassRules !== undefined) {
                localVarQueryParameter['bypass_rules'] = bypassRules;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelease: async (repoRef: string, tagRef: string, bypassRules?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteRelease', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('deleteRelease', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (bypassRules !== undefined) {
                localVarQueryParameter['bypass_rules'] = bypassRules;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryRunner: async (repoRef: string, runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteRepositoryRunner', 'repoRef', repoRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('deleteRepositoryRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/repos/{repo_ref}/+/runners/{runner_uuid}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryVariable: async (repoRef: string, variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteRepositoryVariable', 'repoRef', repoRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('deleteRepositoryVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/variables/{variable_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (repoRef: string, tagName: string, bypassRules?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteTag', 'repoRef', repoRef)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteTag', 'tagName', tagName)
            const localVarPath = `/repos/{repo_ref}/+/tags/{tag_name}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (bypassRules !== undefined) {
                localVarQueryParameter['bypass_rules'] = bypassRules;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {GeneralSettings} generalSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalUpdate: async (repoRef: string, generalSettings: GeneralSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('generalUpdate', 'repoRef', repoRef)
            // verify required parameter 'generalSettings' is not null or undefined
            assertParamExists('generalUpdate', 'generalSettings', generalSettings)
            const localVarPath = `/repos/{repo_ref}/+/settings/general`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generalSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} archiveRef 
         * @param {string} [prefix] 
         * @param {ArchiveAttribute} [attributes] 
         * @param {Array<string>} [paths] 
         * @param {number} [timestamp] 
         * @param {number} [compression] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchive: async (repoRef: string, archiveRef: string, prefix?: string, attributes?: ArchiveAttribute, paths?: Array<string>, timestamp?: number, compression?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getArchive', 'repoRef', repoRef)
            // verify required parameter 'archiveRef' is not null or undefined
            assertParamExists('getArchive', 'archiveRef', archiveRef)
            const localVarPath = `/repos/{repo_ref}/+/archive/{archive_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"archive_ref"}}`, encodeURIComponent(String(archiveRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = attributes;
            }

            if (paths) {
                localVarQueryParameter['paths'] = paths;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (compression !== undefined) {
                localVarQueryParameter['compression'] = compression;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] The git reference (branch / tag / commitID) that will be used to retrieve the data. If no value is provided the default branch of the repository is used.         Default value : {Repository Default Branch}
         * @param {number} [lineFrom] 
         * @param {number} [lineTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlame: async (repoRef: string, path: string, gitRef?: string, lineFrom?: number, lineTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getBlame', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getBlame', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/blame/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }

            if (lineFrom !== undefined) {
                localVarQueryParameter['line_from'] = lineFrom;
            }

            if (lineTo !== undefined) {
                localVarQueryParameter['line_to'] = lineTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranch: async (repoRef: string, branchName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getBranch', 'repoRef', repoRef)
            // verify required parameter 'branchName' is not null or undefined
            assertParamExists('getBranch', 'branchName', branchName)
            const localVarPath = `/repos/{repo_ref}/+/branches/{branch_name}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"branch_name"}}`, encodeURIComponent(String(branchName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranches: async (repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getBranches', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/branches`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (includeCommit !== undefined) {
                localVarQueryParameter['include_commit'] = includeCommit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeownersValidate: async (repoRef: string, gitRef?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCodeownersValidate', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/codeowners/validate`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommit: async (repoRef: string, commitSha: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCommit', 'repoRef', repoRef)
            // verify required parameter 'commitSha' is not null or undefined
            assertParamExists('getCommit', 'commitSha', commitSha)
            const localVarPath = `/repos/{repo_ref}/+/commits/{commit_sha}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"commit_sha"}}`, encodeURIComponent(String(commitSha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitDiff: async (repoRef: string, commitSha: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCommitDiff', 'repoRef', repoRef)
            // verify required parameter 'commitSha' is not null or undefined
            assertParamExists('getCommitDiff', 'commitSha', commitSha)
            const localVarPath = `/repos/{repo_ref}/+/commits/{commit_sha}/diff`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"commit_sha"}}`, encodeURIComponent(String(commitSha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {string} filePath 
         * @param {string} hunkHeader 
         * @param {boolean} expandUp 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitFileContent: async (repoRef: string, commitSha: string, filePath: string, hunkHeader: string, expandUp: boolean, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCommitFileContent', 'repoRef', repoRef)
            // verify required parameter 'commitSha' is not null or undefined
            assertParamExists('getCommitFileContent', 'commitSha', commitSha)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getCommitFileContent', 'filePath', filePath)
            // verify required parameter 'hunkHeader' is not null or undefined
            assertParamExists('getCommitFileContent', 'hunkHeader', hunkHeader)
            // verify required parameter 'expandUp' is not null or undefined
            assertParamExists('getCommitFileContent', 'expandUp', expandUp)
            const localVarPath = `/repos/{repo_ref}/+/commits/{commit_sha}/content`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"commit_sha"}}`, encodeURIComponent(String(commitSha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['file_path'] = filePath;
            }

            if (hunkHeader !== undefined) {
                localVarQueryParameter['hunk_header'] = hunkHeader;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (expandUp !== undefined) {
                localVarQueryParameter['expand_up'] = expandUp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [after] 
         * @param {string} [path] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {string} [author] 
         * @param {boolean} [includeStats] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommits: async (repoRef: string, gitRef?: string, page?: number, size?: number, after?: string, path?: string, since?: number, until?: number, author?: string, includeStats?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCommits', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/commits`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (includeStats !== undefined) {
                localVarQueryParameter['include_stats'] = includeStats;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent: async (repoRef: string, path: string, gitRef?: string, includeCommit?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getContent', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getContent', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/content/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }

            if (includeCommit !== undefined) {
                localVarQueryParameter['include_commit'] = includeCommit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContributors: async (repoRef: string, gitRef?: string, since?: number, until?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getContributors', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/contributors`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiffStats: async (repoRef: string, path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getDiffStats', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getDiffStats', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/diff-stats/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiffs: async (repoRef: string, path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getDiffs', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getDiffs', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/diff/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForks: async (repoRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getForks', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/forks`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneral: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getGeneral', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/settings/general`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHasStarred: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getHasStarred', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/stars/has_starred`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportProgress: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getImportProgress', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/import-progress`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {boolean} [includeDirectories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaths: async (repoRef: string, gitRef?: string, includeDirectories?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getPaths', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/paths`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }

            if (includeDirectories !== undefined) {
                localVarQueryParameter['include_directories'] = includeDirectories;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaw: async (repoRef: string, path: string, gitRef?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRaw', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getRaw', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/raw/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelease: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRelease', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('getRelease', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {ReleaseSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleases: async (repoRef: string, page?: number, size?: number, query?: string, sort?: ReleaseSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getReleases', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/releases`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepo: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepo', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryResetedRunnerRegisterToken: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryResetedRunnerRegisterToken', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/runners/register_token/reseted`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunner: async (repoRef: string, runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryRunner', 'repoRef', repoRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('getRepositoryRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/repos/{repo_ref}/+/runners/{runner_uuid}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunnerRegisterToken: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryRunnerRegisterToken', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/runners/register_token`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunners: async (repoRef: string, page?: number, size?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryRunners', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/runners`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryServiceAccounts: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryServiceAccounts', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/service-accounts`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryStats: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryStats', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/stats`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryVariable: async (repoRef: string, variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryVariable', 'repoRef', repoRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('getRepositoryVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/variables/{variable_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryVariables: async (repoRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryVariables', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/variables`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getSecurity', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/settings/security`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStars: async (repoRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getStars', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/stars`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getTags', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/tags`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (includeCommit !== undefined) {
                localVarQueryParameter['include_commit'] = includeCommit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateInput} repoUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepo: async (repoRef: string, repoUpdateInput: RepoUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchRepo', 'repoRef', repoRef)
            // verify required parameter 'repoUpdateInput' is not null or undefined
            assertParamExists('patchRepo', 'repoUpdateInput', repoUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepositoryRunner: async (repoRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchRepositoryRunner', 'repoRef', repoRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('patchRepositoryRunner', 'runnerUuid', runnerUuid)
            // verify required parameter 'runnerPatchInput' is not null or undefined
            assertParamExists('patchRepositoryRunner', 'runnerPatchInput', runnerPatchInput)
            const localVarPath = `/repos/{repo_ref}/+/runners/{runner_uuid}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepositoryVariable: async (repoRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchRepositoryVariable', 'repoRef', repoRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('patchRepositoryVariable', 'variableIdentifier', variableIdentifier)
            // verify required parameter 'variablePatchInput' is not null or undefined
            assertParamExists('patchRepositoryVariable', 'variablePatchInput', variablePatchInput)
            const localVarPath = `/repos/{repo_ref}/+/variables/{variable_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variablePatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {SecuritySettings} securitySettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSecurity: async (repoRef: string, securitySettings: SecuritySettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchSecurity', 'repoRef', repoRef)
            // verify required parameter 'securitySettings' is not null or undefined
            assertParamExists('patchSecurity', 'securitySettings', securitySettings)
            const localVarPath = `/repos/{repo_ref}/+/settings/security`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(securitySettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoStarsInput} repoStarsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStars: async (repoRef: string, repoStarsInput: RepoStarsInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchStars', 'repoRef', repoRef)
            // verify required parameter 'repoStarsInput' is not null or undefined
            assertParamExists('patchStars', 'repoStarsInput', repoStarsInput)
            const localVarPath = `/repos/{repo_ref}/+/stars`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoStarsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchCreateInput} branchCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBranch: async (repoRef: string, branchCreateInput: BranchCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postBranch', 'repoRef', repoRef)
            // verify required parameter 'branchCreateInput' is not null or undefined
            assertParamExists('postBranch', 'branchCreateInput', branchCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/branches`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(branchCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateDefaultBranchInput} repoUpdateDefaultBranchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDefaultBranch: async (repoRef: string, repoUpdateDefaultBranchInput: RepoUpdateDefaultBranchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postDefaultBranch', 'repoRef', repoRef)
            // verify required parameter 'repoUpdateDefaultBranchInput' is not null or undefined
            assertParamExists('postDefaultBranch', 'repoUpdateDefaultBranchInput', repoUpdateDefaultBranchInput)
            const localVarPath = `/repos/{repo_ref}/+/default-branch`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoUpdateDefaultBranchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} path2 
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiffs: async (repoRef: string, path: string, path2: string, commitDiffFile: Array<CommitDiffFile>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postDiffs', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('postDiffs', 'path', path)
            // verify required parameter 'path2' is not null or undefined
            assertParamExists('postDiffs', 'path2', path2)
            // verify required parameter 'commitDiffFile' is not null or undefined
            assertParamExists('postDiffs', 'commitDiffFile', commitDiffFile)
            const localVarPath = `/repos/{repo_ref}/+/diff/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commitDiffFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {RepoMergeCheckInput} repoMergeCheckInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMergeCheck: async (repoRef: string, path: string, repoMergeCheckInput: RepoMergeCheckInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postMergeCheck', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('postMergeCheck', 'path', path)
            // verify required parameter 'repoMergeCheckInput' is not null or undefined
            assertParamExists('postMergeCheck', 'repoMergeCheckInput', repoMergeCheckInput)
            const localVarPath = `/repos/{repo_ref}/+/merge-check/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoMergeCheckInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {Array<string>} requestBody 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPathDetails: async (repoRef: string, requestBody: Array<string>, gitRef?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postPathDetails', 'repoRef', repoRef)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('postPathDetails', 'requestBody', requestBody)
            const localVarPath = `/repos/{repo_ref}/+/path-details`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ReleaseCreateInput} releaseCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRelease: async (repoRef: string, releaseCreateInput: ReleaseCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRelease', 'repoRef', repoRef)
            // verify required parameter 'releaseCreateInput' is not null or undefined
            assertParamExists('postRelease', 'releaseCreateInput', releaseCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/releases`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(releaseCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RepoCreateInput} repoCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepo: async (repoCreateInput: RepoCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoCreateInput' is not null or undefined
            assertParamExists('postRepo', 'repoCreateInput', repoCreateInput)
            const localVarPath = `/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RepoImportInput} repoImportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryImport: async (repoImportInput: RepoImportInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoImportInput' is not null or undefined
            assertParamExists('postRepositoryImport', 'repoImportInput', repoImportInput)
            const localVarPath = `/repos/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoImportInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoMoveInput} repoMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryMove: async (repoRef: string, repoMoveInput: RepoMoveInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRepositoryMove', 'repoRef', repoRef)
            // verify required parameter 'repoMoveInput' is not null or undefined
            assertParamExists('postRepositoryMove', 'repoMoveInput', repoMoveInput)
            const localVarPath = `/repos/{repo_ref}/+/move`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoMoveInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryPurge: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRepositoryPurge', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/purge`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryVariable: async (repoRef: string, variableCreateInput: VariableCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRepositoryVariable', 'repoRef', repoRef)
            // verify required parameter 'variableCreateInput' is not null or undefined
            assertParamExists('postRepositoryVariable', 'variableCreateInput', variableCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/variables`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {TagCreateInput} tagCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTag: async (repoRef: string, tagCreateInput: TagCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postTag', 'repoRef', repoRef)
            // verify required parameter 'tagCreateInput' is not null or undefined
            assertParamExists('postTag', 'tagCreateInput', tagCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/tags`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchRenameInput} branchRenameInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameBranch: async (repoRef: string, branchRenameInput: BranchRenameInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('renameBranch', 'repoRef', repoRef)
            // verify required parameter 'branchRenameInput' is not null or undefined
            assertParamExists('renameBranch', 'branchRenameInput', branchRenameInput)
            const localVarPath = `/repos/{repo_ref}/+/branches`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(branchRenameInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoRestoreInput} repoRestoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoRestore: async (repoRef: string, repoRestoreInput: RepoRestoreInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('repoRestore', 'repoRef', repoRef)
            // verify required parameter 'repoRestoreInput' is not null or undefined
            assertParamExists('repoRestore', 'repoRestoreInput', repoRestoreInput)
            const localVarPath = `/repos/{repo_ref}/+/restore`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoRestoreInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softRepositoryDelete: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('softRepositoryDelete', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {CommitFilesInput} commitFilesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitFiles(repoRef: string, commitFilesInput: CommitFilesInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitFilesOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commitFiles(repoRef, commitFilesInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.commitFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoCommitDivergencesInput} repoCommitDivergencesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitsCalculateDivergence(repoRef: string, repoCommitDivergencesInput: RepoCommitDivergencesInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitDivergence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commitsCalculateDivergence(repoRef, repoCommitDivergencesInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.commitsCalculateDivergence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBranch(repoRef: string, branchName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBranch(repoRef, branchName, bypassRules, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.deleteBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelease(repoRef: string, tagRef: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelease(repoRef, tagRef, bypassRules, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.deleteRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryRunner(repoRef, runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.deleteRepositoryRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryVariable(repoRef, variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.deleteRepositoryVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(repoRef: string, tagName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(repoRef, tagName, bypassRules, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.deleteTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {GeneralSettings} generalSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generalUpdate(repoRef: string, generalSettings: GeneralSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generalUpdate(repoRef, generalSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.generalUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} archiveRef 
         * @param {string} [prefix] 
         * @param {ArchiveAttribute} [attributes] 
         * @param {Array<string>} [paths] 
         * @param {number} [timestamp] 
         * @param {number} [compression] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArchive(repoRef: string, archiveRef: string, prefix?: string, attributes?: ArchiveAttribute, paths?: Array<string>, timestamp?: number, compression?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArchive(repoRef, archiveRef, prefix, attributes, paths, timestamp, compression, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] The git reference (branch / tag / commitID) that will be used to retrieve the data. If no value is provided the default branch of the repository is used.         Default value : {Repository Default Branch}
         * @param {number} [lineFrom] 
         * @param {number} [lineTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlame(repoRef: string, path: string, gitRef?: string, lineFrom?: number, lineTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlamePart>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlame(repoRef, path, gitRef, lineFrom, lineTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getBlame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranch(repoRef: string, branchName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitBranch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranch(repoRef, branchName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranches(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitBranch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranches(repoRef, page, size, query, includeCommit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodeownersValidate(repoRef: string, gitRef?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeOwnersValidation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodeownersValidate(repoRef, gitRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getCodeownersValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommit(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommit(repoRef, commitSha, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getCommit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommitDiff(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommitDiff(repoRef, commitSha, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getCommitDiff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {string} filePath 
         * @param {string} hunkHeader 
         * @param {boolean} expandUp 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommitFileContent(repoRef: string, commitSha: string, filePath: string, hunkHeader: string, expandUp: boolean, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiffFileContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommitFileContent(repoRef, commitSha, filePath, hunkHeader, expandUp, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getCommitFileContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [after] 
         * @param {string} [path] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {string} [author] 
         * @param {boolean} [includeStats] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommits(repoRef: string, gitRef?: string, page?: number, size?: number, after?: string, path?: string, since?: number, until?: number, author?: string, includeStats?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitWithPathRenameDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommits(repoRef, gitRef, page, size, after, path, since, until, author, includeStats, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getCommits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContent(repoRef: string, path: string, gitRef?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoContentOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContent(repoRef, path, gitRef, includeCommit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContributors(repoRef: string, gitRef?: string, since?: number, until?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contributor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContributors(repoRef, gitRef, since, until, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getContributors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiffStats(repoRef: string, path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiffStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiffStats(repoRef, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getDiffStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiffs(repoRef: string, path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiffs(repoRef, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getDiffs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForks(repoRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForks(repoRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getForks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneral(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneral(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getGeneral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHasStarred(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryStarModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHasStarred(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getHasStarred']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportProgress(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobProgress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportProgress(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getImportProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {boolean} [includeDirectories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaths(repoRef: string, gitRef?: string, includeDirectories?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoPathsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaths(repoRef, gitRef, includeDirectories, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getPaths']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaw(repoRef: string, path: string, gitRef?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaw(repoRef, path, gitRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelease(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseCreator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelease(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {ReleaseSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReleases(repoRef: string, page?: number, size?: number, query?: string, sort?: ReleaseSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReleaseCreator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReleases(repoRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getReleases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepo(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoParent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepo(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryResetedRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryResetedRunnerRegisterToken(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryResetedRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryRunner(repoRef, runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryRunnerRegisterToken(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryRunners(repoRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunnerCreator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryRunners(repoRef, page, size, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryRunners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryServiceAccounts(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryServiceAccounts(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryServiceAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryStats(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoStatsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryStats(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryVariable(repoRef, variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryVariables(repoRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariableGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryVariables(repoRef, page, size, query, types, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecurity(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecuritySettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecurity(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStars(repoRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStars(repoRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getStars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(repoRef, page, size, query, includeCommit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateInput} repoUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRepo(repoRef: string, repoUpdateInput: RepoUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRepo(repoRef, repoUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.patchRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRepositoryRunner(repoRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRepositoryRunner(repoRef, runnerUuid, runnerPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.patchRepositoryRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRepositoryVariable(repoRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRepositoryVariable(repoRef, variableIdentifier, variablePatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.patchRepositoryVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {SecuritySettings} securitySettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchSecurity(repoRef: string, securitySettings: SecuritySettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecuritySettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSecurity(repoRef, securitySettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.patchSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoStarsInput} repoStarsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStars(repoRef: string, repoStarsInput: RepoStarsInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchStars(repoRef, repoStarsInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.patchStars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchCreateInput} branchCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBranch(repoRef: string, branchCreateInput: BranchCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitBranch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBranch(repoRef, branchCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateDefaultBranchInput} repoUpdateDefaultBranchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDefaultBranch(repoRef: string, repoUpdateDefaultBranchInput: RepoUpdateDefaultBranchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDefaultBranch(repoRef, repoUpdateDefaultBranchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postDefaultBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} path2 
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDiffs(repoRef: string, path: string, path2: string, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDiffs(repoRef, path, path2, commitDiffFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postDiffs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {RepoMergeCheckInput} repoMergeCheckInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMergeCheck(repoRef: string, path: string, repoMergeCheckInput: RepoMergeCheckInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoMergeCheckOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMergeCheck(repoRef, path, repoMergeCheckInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postMergeCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {Array<string>} requestBody 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPathDetails(repoRef: string, requestBody: Array<string>, gitRef?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PathDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPathDetails(repoRef, requestBody, gitRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postPathDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ReleaseCreateInput} releaseCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRelease(repoRef: string, releaseCreateInput: ReleaseCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRelease(repoRef, releaseCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RepoCreateInput} repoCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepo(repoCreateInput: RepoCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepo(repoCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RepoImportInput} repoImportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepositoryImport(repoImportInput: RepoImportInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepositoryImport(repoImportInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRepositoryImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoMoveInput} repoMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepositoryMove(repoRef: string, repoMoveInput: RepoMoveInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepositoryMove(repoRef, repoMoveInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRepositoryMove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepositoryPurge(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepositoryPurge(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRepositoryPurge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepositoryVariable(repoRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepositoryVariable(repoRef, variableCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRepositoryVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {TagCreateInput} tagCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTag(repoRef: string, tagCreateInput: TagCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTag(repoRef, tagCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchRenameInput} branchRenameInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameBranch(repoRef: string, branchRenameInput: BranchRenameInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitBranch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameBranch(repoRef, branchRenameInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.renameBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoRestoreInput} repoRestoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoRestore(repoRef: string, repoRestoreInput: RepoRestoreInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoRestore(repoRef, repoRestoreInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.repoRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async softRepositoryDelete(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.softRepositoryDelete(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.softRepositoryDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RepositoryApi - factory interface
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {CommitFilesInput} commitFilesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitFiles(repoRef: string, commitFilesInput: CommitFilesInput, options?: RawAxiosRequestConfig): AxiosPromise<CommitFilesOutput> {
            return localVarFp.commitFiles(repoRef, commitFilesInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoCommitDivergencesInput} repoCommitDivergencesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsCalculateDivergence(repoRef: string, repoCommitDivergencesInput: RepoCommitDivergencesInput, options?: RawAxiosRequestConfig): AxiosPromise<Array<CommitDivergence>> {
            return localVarFp.commitsCalculateDivergence(repoRef, repoCommitDivergencesInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch(repoRef: string, branchName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBranch(repoRef, branchName, bypassRules, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelease(repoRef: string, tagRef: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRelease(repoRef, tagRef, bypassRules, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryRunner(repoRef, runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryVariable(repoRef, variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(repoRef: string, tagName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTag(repoRef, tagName, bypassRules, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {GeneralSettings} generalSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalUpdate(repoRef: string, generalSettings: GeneralSettings, options?: RawAxiosRequestConfig): AxiosPromise<GeneralSettings> {
            return localVarFp.generalUpdate(repoRef, generalSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} archiveRef 
         * @param {string} [prefix] 
         * @param {ArchiveAttribute} [attributes] 
         * @param {Array<string>} [paths] 
         * @param {number} [timestamp] 
         * @param {number} [compression] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchive(repoRef: string, archiveRef: string, prefix?: string, attributes?: ArchiveAttribute, paths?: Array<string>, timestamp?: number, compression?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getArchive(repoRef, archiveRef, prefix, attributes, paths, timestamp, compression, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] The git reference (branch / tag / commitID) that will be used to retrieve the data. If no value is provided the default branch of the repository is used.         Default value : {Repository Default Branch}
         * @param {number} [lineFrom] 
         * @param {number} [lineTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlame(repoRef: string, path: string, gitRef?: string, lineFrom?: number, lineTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<BlamePart>> {
            return localVarFp.getBlame(repoRef, path, gitRef, lineFrom, lineTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranch(repoRef: string, branchName: string, options?: RawAxiosRequestConfig): AxiosPromise<CommitBranch> {
            return localVarFp.getBranch(repoRef, branchName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranches(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<CommitBranch>> {
            return localVarFp.getBranches(repoRef, page, size, query, includeCommit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeownersValidate(repoRef: string, gitRef?: string, options?: RawAxiosRequestConfig): AxiosPromise<CodeOwnersValidation> {
            return localVarFp.getCodeownersValidate(repoRef, gitRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommit(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig): AxiosPromise<Commit> {
            return localVarFp.getCommit(repoRef, commitSha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitDiff(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getCommitDiff(repoRef, commitSha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {string} filePath 
         * @param {string} hunkHeader 
         * @param {boolean} expandUp 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitFileContent(repoRef: string, commitSha: string, filePath: string, hunkHeader: string, expandUp: boolean, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<DiffFileContent> {
            return localVarFp.getCommitFileContent(repoRef, commitSha, filePath, hunkHeader, expandUp, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [after] 
         * @param {string} [path] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {string} [author] 
         * @param {boolean} [includeStats] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommits(repoRef: string, gitRef?: string, page?: number, size?: number, after?: string, path?: string, since?: number, until?: number, author?: string, includeStats?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<CommitWithPathRenameDetails>> {
            return localVarFp.getCommits(repoRef, gitRef, page, size, after, path, since, until, author, includeStats, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent(repoRef: string, path: string, gitRef?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<RepoContentOutput> {
            return localVarFp.getContent(repoRef, path, gitRef, includeCommit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContributors(repoRef: string, gitRef?: string, since?: number, until?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Contributor>> {
            return localVarFp.getContributors(repoRef, gitRef, since, until, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiffStats(repoRef: string, path: string, options?: RawAxiosRequestConfig): AxiosPromise<DiffStats> {
            return localVarFp.getDiffStats(repoRef, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiffs(repoRef: string, path: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getDiffs(repoRef, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForks(repoRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepositoryModel>> {
            return localVarFp.getForks(repoRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneral(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<GeneralSettings> {
            return localVarFp.getGeneral(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHasStarred(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryStarModel> {
            return localVarFp.getHasStarred(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportProgress(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<JobProgress> {
            return localVarFp.getImportProgress(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {boolean} [includeDirectories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaths(repoRef: string, gitRef?: string, includeDirectories?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<RepoPathsOutput> {
            return localVarFp.getPaths(repoRef, gitRef, includeDirectories, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaw(repoRef: string, path: string, gitRef?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getRaw(repoRef, path, gitRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelease(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<ReleaseCreator> {
            return localVarFp.getRelease(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {ReleaseSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleases(repoRef: string, page?: number, size?: number, query?: string, sort?: ReleaseSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReleaseCreator>> {
            return localVarFp.getReleases(repoRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepo(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RepoParent> {
            return localVarFp.getRepo(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryResetedRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getRepositoryResetedRunnerRegisterToken(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.getRepositoryRunner(repoRef, runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getRepositoryRunnerRegisterToken(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunners(repoRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunnerCreator>> {
            return localVarFp.getRepositoryRunners(repoRef, page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryServiceAccounts(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserModel>> {
            return localVarFp.getRepositoryServiceAccounts(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryStats(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RepoStatsOutput> {
            return localVarFp.getRepositoryStats(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.getRepositoryVariable(repoRef, variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryVariables(repoRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariableGroup>> {
            return localVarFp.getRepositoryVariables(repoRef, page, size, query, types, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<SecuritySettings> {
            return localVarFp.getSecurity(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStars(repoRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserModel>> {
            return localVarFp.getStars(repoRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<CommitTag>> {
            return localVarFp.getTags(repoRef, page, size, query, includeCommit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateInput} repoUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepo(repoRef: string, repoUpdateInput: RepoUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.patchRepo(repoRef, repoUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepositoryRunner(repoRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.patchRepositoryRunner(repoRef, runnerUuid, runnerPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepositoryVariable(repoRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.patchRepositoryVariable(repoRef, variableIdentifier, variablePatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {SecuritySettings} securitySettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSecurity(repoRef: string, securitySettings: SecuritySettings, options?: RawAxiosRequestConfig): AxiosPromise<SecuritySettings> {
            return localVarFp.patchSecurity(repoRef, securitySettings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoStarsInput} repoStarsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStars(repoRef: string, repoStarsInput: RepoStarsInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.patchStars(repoRef, repoStarsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchCreateInput} branchCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBranch(repoRef: string, branchCreateInput: BranchCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<CommitBranch> {
            return localVarFp.postBranch(repoRef, branchCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateDefaultBranchInput} repoUpdateDefaultBranchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDefaultBranch(repoRef: string, repoUpdateDefaultBranchInput: RepoUpdateDefaultBranchInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.postDefaultBranch(repoRef, repoUpdateDefaultBranchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} path2 
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiffs(repoRef: string, path: string, path2: string, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.postDiffs(repoRef, path, path2, commitDiffFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {RepoMergeCheckInput} repoMergeCheckInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMergeCheck(repoRef: string, path: string, repoMergeCheckInput: RepoMergeCheckInput, options?: RawAxiosRequestConfig): AxiosPromise<RepoMergeCheckOutput> {
            return localVarFp.postMergeCheck(repoRef, path, repoMergeCheckInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {Array<string>} requestBody 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPathDetails(repoRef: string, requestBody: Array<string>, gitRef?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PathDetails>> {
            return localVarFp.postPathDetails(repoRef, requestBody, gitRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ReleaseCreateInput} releaseCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRelease(repoRef: string, releaseCreateInput: ReleaseCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<ReleaseModel> {
            return localVarFp.postRelease(repoRef, releaseCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RepoCreateInput} repoCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepo(repoCreateInput: RepoCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.postRepo(repoCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RepoImportInput} repoImportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryImport(repoImportInput: RepoImportInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.postRepositoryImport(repoImportInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoMoveInput} repoMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryMove(repoRef: string, repoMoveInput: RepoMoveInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.postRepositoryMove(repoRef, repoMoveInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryPurge(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postRepositoryPurge(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryVariable(repoRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.postRepositoryVariable(repoRef, variableCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {TagCreateInput} tagCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTag(repoRef: string, tagCreateInput: TagCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<CommitTag> {
            return localVarFp.postTag(repoRef, tagCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchRenameInput} branchRenameInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameBranch(repoRef: string, branchRenameInput: BranchRenameInput, options?: RawAxiosRequestConfig): AxiosPromise<CommitBranch> {
            return localVarFp.renameBranch(repoRef, branchRenameInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoRestoreInput} repoRestoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoRestore(repoRef: string, repoRestoreInput: RepoRestoreInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.repoRestore(repoRef, repoRestoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softRepositoryDelete(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.softRepositoryDelete(repoRef, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 */
export class RepositoryApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {CommitFilesInput} commitFilesInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public commitFiles(repoRef: string, commitFilesInput: CommitFilesInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).commitFiles(repoRef, commitFilesInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoCommitDivergencesInput} repoCommitDivergencesInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public commitsCalculateDivergence(repoRef: string, repoCommitDivergencesInput: RepoCommitDivergencesInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).commitsCalculateDivergence(repoRef, repoCommitDivergencesInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} branchName 
     * @param {boolean} [bypassRules] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteBranch(repoRef: string, branchName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteBranch(repoRef, branchName, bypassRules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {boolean} [bypassRules] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRelease(repoRef: string, tagRef: string, bypassRules?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteRelease(repoRef, tagRef, bypassRules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteRepositoryRunner(repoRef, runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteRepositoryVariable(repoRef, variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagName 
     * @param {boolean} [bypassRules] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTag(repoRef: string, tagName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteTag(repoRef, tagName, bypassRules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {GeneralSettings} generalSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generalUpdate(repoRef: string, generalSettings: GeneralSettings, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).generalUpdate(repoRef, generalSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} archiveRef 
     * @param {string} [prefix] 
     * @param {ArchiveAttribute} [attributes] 
     * @param {Array<string>} [paths] 
     * @param {number} [timestamp] 
     * @param {number} [compression] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getArchive(repoRef: string, archiveRef: string, prefix?: string, attributes?: ArchiveAttribute, paths?: Array<string>, timestamp?: number, compression?: number, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getArchive(repoRef, archiveRef, prefix, attributes, paths, timestamp, compression, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {string} [gitRef] The git reference (branch / tag / commitID) that will be used to retrieve the data. If no value is provided the default branch of the repository is used.         Default value : {Repository Default Branch}
     * @param {number} [lineFrom] 
     * @param {number} [lineTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBlame(repoRef: string, path: string, gitRef?: string, lineFrom?: number, lineTo?: number, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getBlame(repoRef, path, gitRef, lineFrom, lineTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} branchName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBranch(repoRef: string, branchName: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getBranch(repoRef, branchName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {boolean} [includeCommit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBranches(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getBranches(repoRef, page, size, query, includeCommit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} [gitRef] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCodeownersValidate(repoRef: string, gitRef?: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getCodeownersValidate(repoRef, gitRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} commitSha 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommit(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getCommit(repoRef, commitSha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} commitSha 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommitDiff(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getCommitDiff(repoRef, commitSha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} commitSha 
     * @param {string} filePath 
     * @param {string} hunkHeader 
     * @param {boolean} expandUp 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommitFileContent(repoRef: string, commitSha: string, filePath: string, hunkHeader: string, expandUp: boolean, size?: number, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getCommitFileContent(repoRef, commitSha, filePath, hunkHeader, expandUp, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} [gitRef] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [after] 
     * @param {string} [path] 
     * @param {number} [since] 
     * @param {number} [until] 
     * @param {string} [author] 
     * @param {boolean} [includeStats] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommits(repoRef: string, gitRef?: string, page?: number, size?: number, after?: string, path?: string, since?: number, until?: number, author?: string, includeStats?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getCommits(repoRef, gitRef, page, size, after, path, since, until, author, includeStats, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {string} [gitRef] 
     * @param {boolean} [includeCommit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContent(repoRef: string, path: string, gitRef?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getContent(repoRef, path, gitRef, includeCommit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} [gitRef] 
     * @param {number} [since] 
     * @param {number} [until] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContributors(repoRef: string, gitRef?: string, since?: number, until?: number, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getContributors(repoRef, gitRef, since, until, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDiffStats(repoRef: string, path: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getDiffStats(repoRef, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDiffs(repoRef: string, path: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getDiffs(repoRef, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getForks(repoRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getForks(repoRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGeneral(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getGeneral(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHasStarred(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getHasStarred(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getImportProgress(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getImportProgress(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} [gitRef] 
     * @param {boolean} [includeDirectories] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPaths(repoRef: string, gitRef?: string, includeDirectories?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getPaths(repoRef, gitRef, includeDirectories, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {string} [gitRef] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRaw(repoRef: string, path: string, gitRef?: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRaw(repoRef, path, gitRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRelease(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRelease(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {ReleaseSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReleases(repoRef: string, page?: number, size?: number, query?: string, sort?: ReleaseSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getReleases(repoRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepo(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepo(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryResetedRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryResetedRunnerRegisterToken(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryRunner(repoRef, runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryRunnerRegisterToken(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryRunners(repoRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryRunners(repoRef, page, size, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryServiceAccounts(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryServiceAccounts(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryStats(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryStats(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryVariable(repoRef, variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<VariableType>} [types] 
     * @param {VariableSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRepositoryVariables(repoRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryVariables(repoRef, page, size, query, types, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSecurity(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getSecurity(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {UserSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStars(repoRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getStars(repoRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {boolean} [includeCommit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTags(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getTags(repoRef, page, size, query, includeCommit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoUpdateInput} repoUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchRepo(repoRef: string, repoUpdateInput: RepoUpdateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).patchRepo(repoRef, repoUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} runnerUuid 
     * @param {RunnerPatchInput} runnerPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchRepositoryRunner(repoRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).patchRepositoryRunner(repoRef, runnerUuid, runnerPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} variableIdentifier 
     * @param {VariablePatchInput} variablePatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchRepositoryVariable(repoRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).patchRepositoryVariable(repoRef, variableIdentifier, variablePatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {SecuritySettings} securitySettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchSecurity(repoRef: string, securitySettings: SecuritySettings, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).patchSecurity(repoRef, securitySettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoStarsInput} repoStarsInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchStars(repoRef: string, repoStarsInput: RepoStarsInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).patchStars(repoRef, repoStarsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {BranchCreateInput} branchCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postBranch(repoRef: string, branchCreateInput: BranchCreateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postBranch(repoRef, branchCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoUpdateDefaultBranchInput} repoUpdateDefaultBranchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postDefaultBranch(repoRef: string, repoUpdateDefaultBranchInput: RepoUpdateDefaultBranchInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postDefaultBranch(repoRef, repoUpdateDefaultBranchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {string} path2 
     * @param {Array<CommitDiffFile>} commitDiffFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postDiffs(repoRef: string, path: string, path2: string, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postDiffs(repoRef, path, path2, commitDiffFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {RepoMergeCheckInput} repoMergeCheckInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postMergeCheck(repoRef: string, path: string, repoMergeCheckInput: RepoMergeCheckInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postMergeCheck(repoRef, path, repoMergeCheckInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {Array<string>} requestBody 
     * @param {string} [gitRef] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPathDetails(repoRef: string, requestBody: Array<string>, gitRef?: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postPathDetails(repoRef, requestBody, gitRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {ReleaseCreateInput} releaseCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRelease(repoRef: string, releaseCreateInput: ReleaseCreateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRelease(repoRef, releaseCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RepoCreateInput} repoCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRepo(repoCreateInput: RepoCreateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRepo(repoCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RepoImportInput} repoImportInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRepositoryImport(repoImportInput: RepoImportInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRepositoryImport(repoImportInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoMoveInput} repoMoveInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRepositoryMove(repoRef: string, repoMoveInput: RepoMoveInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRepositoryMove(repoRef, repoMoveInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRepositoryPurge(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRepositoryPurge(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {VariableCreateInput} variableCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRepositoryVariable(repoRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRepositoryVariable(repoRef, variableCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {TagCreateInput} tagCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTag(repoRef: string, tagCreateInput: TagCreateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postTag(repoRef, tagCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {BranchRenameInput} branchRenameInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public renameBranch(repoRef: string, branchRenameInput: BranchRenameInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).renameBranch(repoRef, branchRenameInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoRestoreInput} repoRestoreInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public repoRestore(repoRef: string, repoRestoreInput: RepoRestoreInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoRestore(repoRef, repoRestoreInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public softRepositoryDelete(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).softRepositoryDelete(repoRef, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourcesApi - axios parameter creator
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitignores: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/gitignore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitignores(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitignores(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getGitignores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<License>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getLicenses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourcesApi - factory interface
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitignores(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getGitignores(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenses(options?: RawAxiosRequestConfig): AxiosPromise<Array<License>> {
            return localVarFp.getLicenses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 */
export class ResourcesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGitignores(options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getGitignores(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLicenses(options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getLicenses(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RulesApi - axios parameter creator
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (repoRef: string, ruleIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteRule', 'repoRef', repoRef)
            // verify required parameter 'ruleIdentifier' is not null or undefined
            assertParamExists('deleteRule', 'ruleIdentifier', ruleIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/rules/{rule_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"rule_identifier"}}`, encodeURIComponent(String(ruleIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: async (repoRef: string, ruleIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRule', 'repoRef', repoRef)
            // verify required parameter 'ruleIdentifier' is not null or undefined
            assertParamExists('getRule', 'ruleIdentifier', ruleIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/rules/{rule_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"rule_identifier"}}`, encodeURIComponent(String(ruleIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<RuleState>} [states] 
         * @param {RuleSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules: async (repoRef: string, page?: number, size?: number, query?: string, states?: Array<RuleState>, sort?: RuleSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRules', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/rules`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (states) {
                localVarQueryParameter['states'] = states;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {RulePatchInput} rulePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRule: async (repoRef: string, ruleIdentifier: string, rulePatchInput: RulePatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchRule', 'repoRef', repoRef)
            // verify required parameter 'ruleIdentifier' is not null or undefined
            assertParamExists('patchRule', 'ruleIdentifier', ruleIdentifier)
            // verify required parameter 'rulePatchInput' is not null or undefined
            assertParamExists('patchRule', 'rulePatchInput', rulePatchInput)
            const localVarPath = `/repos/{repo_ref}/+/rules/{rule_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"rule_identifier"}}`, encodeURIComponent(String(ruleIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rulePatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RuleCreateInput} ruleCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRule: async (repoRef: string, ruleCreateInput: RuleCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRule', 'repoRef', repoRef)
            // verify required parameter 'ruleCreateInput' is not null or undefined
            assertParamExists('postRule', 'ruleCreateInput', ruleCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/rules`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(repoRef, ruleIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.deleteRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRule(repoRef, ruleIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.getRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<RuleState>} [states] 
         * @param {RuleSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRules(repoRef: string, page?: number, size?: number, query?: string, states?: Array<RuleState>, sort?: RuleSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRules(repoRef, page, size, query, states, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.getRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {RulePatchInput} rulePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRule(repoRef: string, ruleIdentifier: string, rulePatchInput: RulePatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRule(repoRef, ruleIdentifier, rulePatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.patchRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RuleCreateInput} ruleCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRule(repoRef: string, ruleCreateInput: RuleCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRule(repoRef, ruleCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.postRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RulesApi - factory interface
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRule(repoRef, ruleIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<RuleModel> {
            return localVarFp.getRule(repoRef, ruleIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<RuleState>} [states] 
         * @param {RuleSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules(repoRef: string, page?: number, size?: number, query?: string, states?: Array<RuleState>, sort?: RuleSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RuleModel>> {
            return localVarFp.getRules(repoRef, page, size, query, states, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {RulePatchInput} rulePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRule(repoRef: string, ruleIdentifier: string, rulePatchInput: RulePatchInput, options?: RawAxiosRequestConfig): AxiosPromise<RuleModel> {
            return localVarFp.patchRule(repoRef, ruleIdentifier, rulePatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RuleCreateInput} ruleCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRule(repoRef: string, ruleCreateInput: RuleCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<RuleModel> {
            return localVarFp.postRule(repoRef, ruleCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 */
export class RulesApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} ruleIdentifier Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteRule(repoRef, ruleIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} ruleIdentifier Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).getRule(repoRef, ruleIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<RuleState>} [states] 
     * @param {RuleSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRules(repoRef: string, page?: number, size?: number, query?: string, states?: Array<RuleState>, sort?: RuleSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).getRules(repoRef, page, size, query, states, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} ruleIdentifier Rule identifier
     * @param {RulePatchInput} rulePatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchRule(repoRef: string, ruleIdentifier: string, rulePatchInput: RulePatchInput, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).patchRule(repoRef, ruleIdentifier, rulePatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RuleCreateInput} ruleCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRule(repoRef: string, ruleCreateInput: RuleCreateInput, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).postRule(repoRef, ruleCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunnersApi - axios parameter creator
 */
export const RunnersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RunnerContext} runnerContext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollStage: async (runnerContext: RunnerContext, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerContext' is not null or undefined
            assertParamExists('pollStage', 'runnerContext', runnerContext)
            const localVarPath = `/runners/poll_stage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerContext, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RunnerPostInput} runnerPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRunnersRegister: async (runnerPostInput: RunnerPostInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerPostInput' is not null or undefined
            assertParamExists('postRunnersRegister', 'runnerPostInput', runnerPostInput)
            const localVarPath = `/runners/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerPostInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunnersApi - functional programming interface
 */
export const RunnersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunnersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RunnerContext} runnerContext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollStage(runnerContext: RunnerContext, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerStageOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollStage(runnerContext, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnersApi.pollStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RunnerPostInput} runnerPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRunnersRegister(runnerPostInput: RunnerPostInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenCreateOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRunnersRegister(runnerPostInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnersApi.postRunnersRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunnersApi - factory interface
 */
export const RunnersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunnersApiFp(configuration)
    return {
        /**
         * 
         * @param {RunnerContext} runnerContext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollStage(runnerContext: RunnerContext, options?: RawAxiosRequestConfig): AxiosPromise<RunnerStageOutput> {
            return localVarFp.pollStage(runnerContext, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RunnerPostInput} runnerPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRunnersRegister(runnerPostInput: RunnerPostInput, options?: RawAxiosRequestConfig): AxiosPromise<TokenCreateOutput> {
            return localVarFp.postRunnersRegister(runnerPostInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunnersApi - object-oriented interface
 */
export class RunnersApi extends BaseAPI {
    /**
     * 
     * @param {RunnerContext} runnerContext 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pollStage(runnerContext: RunnerContext, options?: RawAxiosRequestConfig) {
        return RunnersApiFp(this.configuration).pollStage(runnerContext, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RunnerPostInput} runnerPostInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRunnersRegister(runnerPostInput: RunnerPostInput, options?: RawAxiosRequestConfig) {
        return RunnersApiFp(this.configuration).postRunnersRegister(runnerPostInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceAccountsApi - axios parameter creator
 */
export const ServiceAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccount: async (saIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('deleteServiceAccount', 'saIdentifier', saIdentifier)
            const localVarPath = `/service-accounts/{sa_identifier}`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccountToken: async (saIdentifier: string, tokenName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('deleteServiceAccountToken', 'saIdentifier', saIdentifier)
            // verify required parameter 'tokenName' is not null or undefined
            assertParamExists('deleteServiceAccountToken', 'tokenName', tokenName)
            const localVarPath = `/service-accounts/{sa_identifier}/tokens/{token_name}`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)))
                .replace(`{${"token_name"}}`, encodeURIComponent(String(tokenName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccount: async (saIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('getServiceAccount', 'saIdentifier', saIdentifier)
            const localVarPath = `/service-accounts/{sa_identifier}`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountTokens: async (saIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('getServiceAccountTokens', 'saIdentifier', saIdentifier)
            const localVarPath = `/service-accounts/{sa_identifier}/tokens`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postServiceAccount: async (saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('postServiceAccount', 'saIdentifier', saIdentifier)
            // verify required parameter 'serviceAccountCreateInput' is not null or undefined
            assertParamExists('postServiceAccount', 'serviceAccountCreateInput', serviceAccountCreateInput)
            const localVarPath = `/service-accounts/{sa_identifier}`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceAccountCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postServiceAccountToken: async (saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('postServiceAccountToken', 'saIdentifier', saIdentifier)
            // verify required parameter 'serviceAccountCreateInput' is not null or undefined
            assertParamExists('postServiceAccountToken', 'serviceAccountCreateInput', serviceAccountCreateInput)
            const localVarPath = `/service-accounts/{sa_identifier}/tokens`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceAccountCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceAccountsApi - functional programming interface
 */
export const ServiceAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAccount(saIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.deleteServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAccountToken(saIdentifier: string, tokenName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAccountToken(saIdentifier, tokenName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.deleteServiceAccountToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAccount(saIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.getServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAccountTokens(saIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAccountTokens(saIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.getServiceAccountTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postServiceAccount(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postServiceAccount(saIdentifier, serviceAccountCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.postServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postServiceAccountToken(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccountTokenOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postServiceAccountToken(saIdentifier, serviceAccountCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.postServiceAccountToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceAccountsApi - factory interface
 */
export const ServiceAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceAccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteServiceAccount(saIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccountToken(saIdentifier: string, tokenName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteServiceAccountToken(saIdentifier, tokenName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.getServiceAccount(saIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountTokens(saIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenModel>> {
            return localVarFp.getServiceAccountTokens(saIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postServiceAccount(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.postServiceAccount(saIdentifier, serviceAccountCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postServiceAccountToken(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<ServiceAccountTokenOutput> {
            return localVarFp.postServiceAccountToken(saIdentifier, serviceAccountCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceAccountsApi - object-oriented interface
 */
export class ServiceAccountsApi extends BaseAPI {
    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).deleteServiceAccount(saIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {string} tokenName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteServiceAccountToken(saIdentifier: string, tokenName: string, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).deleteServiceAccountToken(saIdentifier, tokenName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).getServiceAccount(saIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServiceAccountTokens(saIdentifier: string, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).getServiceAccountTokens(saIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postServiceAccount(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).postServiceAccount(saIdentifier, serviceAccountCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postServiceAccountToken(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).postServiceAccountToken(saIdentifier, serviceAccountCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusCheckApi - axios parameter creator
 */
export const StatusCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChecks: async (repoRef: string, commitSha: string, page?: number, size?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getChecks', 'repoRef', repoRef)
            // verify required parameter 'commitSha' is not null or undefined
            assertParamExists('getChecks', 'commitSha', commitSha)
            const localVarPath = `/repos/{repo_ref}/+/checks/commits/{commit_sha}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"commit_sha"}}`, encodeURIComponent(String(commitSha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [query] 
         * @param {number} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent: async (repoRef: string, query?: string, since?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRecent', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/checks/recent`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {CheckReportInput} checkReportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCheckReport: async (repoRef: string, commitSha: string, checkReportInput: CheckReportInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('putCheckReport', 'repoRef', repoRef)
            // verify required parameter 'commitSha' is not null or undefined
            assertParamExists('putCheckReport', 'commitSha', commitSha)
            // verify required parameter 'checkReportInput' is not null or undefined
            assertParamExists('putCheckReport', 'checkReportInput', checkReportInput)
            const localVarPath = `/repos/{repo_ref}/+/checks/commits/{commit_sha}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"commit_sha"}}`, encodeURIComponent(String(commitSha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkReportInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusCheckApi - functional programming interface
 */
export const StatusCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChecks(repoRef: string, commitSha: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CheckModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChecks(repoRef, commitSha, page, size, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusCheckApi.getChecks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [query] 
         * @param {number} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecent(repoRef: string, query?: string, since?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecent(repoRef, query, since, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusCheckApi.getRecent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {CheckReportInput} checkReportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCheckReport(repoRef: string, commitSha: string, checkReportInput: CheckReportInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCheckReport(repoRef, commitSha, checkReportInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusCheckApi.putCheckReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusCheckApi - factory interface
 */
export const StatusCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusCheckApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChecks(repoRef: string, commitSha: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CheckModel>> {
            return localVarFp.getChecks(repoRef, commitSha, page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [query] 
         * @param {number} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent(repoRef: string, query?: string, since?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getRecent(repoRef, query, since, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {CheckReportInput} checkReportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCheckReport(repoRef: string, commitSha: string, checkReportInput: CheckReportInput, options?: RawAxiosRequestConfig): AxiosPromise<CheckModel> {
            return localVarFp.putCheckReport(repoRef, commitSha, checkReportInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusCheckApi - object-oriented interface
 */
export class StatusCheckApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} commitSha 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChecks(repoRef: string, commitSha: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig) {
        return StatusCheckApiFp(this.configuration).getChecks(repoRef, commitSha, page, size, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} [query] 
     * @param {number} [since] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRecent(repoRef: string, query?: string, since?: number, options?: RawAxiosRequestConfig) {
        return StatusCheckApiFp(this.configuration).getRecent(repoRef, query, since, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} commitSha 
     * @param {CheckReportInput} checkReportInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putCheckReport(repoRef: string, commitSha: string, checkReportInput: CheckReportInput, options?: RawAxiosRequestConfig) {
        return StatusCheckApiFp(this.configuration).putCheckReport(repoRef, commitSha, checkReportInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: RawAxiosRequestConfig): AxiosPromise<SystemConfig> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConfig(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHealth(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVersion(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} publicKeyName Public key name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (publicKeyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicKeyName' is not null or undefined
            assertParamExists('deletePublicKey', 'publicKeyName', publicKeyName)
            const localVarPath = `/user/keys/{public_key_name}`
                .replace(`{${"public_key_name"}}`, encodeURIComponent(String(publicKeyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession: async (sessionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionName' is not null or undefined
            assertParamExists('deleteSession', 'sessionName', sessionName)
            const localVarPath = `/user/sessions/{session_name}`
                .replace(`{${"session_name"}}`, encodeURIComponent(String(sessionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (tokenName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenName' is not null or undefined
            assertParamExists('deleteToken', 'tokenName', tokenName)
            const localVarPath = `/user/tokens/{token_name}`
                .replace(`{${"token_name"}}`, encodeURIComponent(String(tokenName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwoFactor: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/security/two_factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeds: async (page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHasPerm: async (repoRef: string, perm: Permission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getHasPerm', 'repoRef', repoRef)
            // verify required parameter 'perm' is not null or undefined
            assertParamExists('getHasPerm', 'perm', perm)
            const localVarPath = `/user/{repo_ref}/+/has_perm`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (perm !== undefined) {
                localVarQueryParameter['perm'] = perm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeatmap: async (before?: number, after?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/heatmap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberships: async (page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {PublicKeySort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (page?: number, size?: number, query?: string, sort?: PublicKeySort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwoFactor: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/security/two_factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: async (page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepos: async (page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStars: async (page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/stars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTwoFactor: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/security/two_factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserPatchInput} userPatchInput Update user infomation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserUser: async (userPatchInput: UserPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPatchInput' is not null or undefined
            assertParamExists('patchUserUser', 'userPatchInput', userPatchInput)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PublicKeyCreateInput} publicKeyCreateInput Create a new SSH public key for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPublicKey: async (publicKeyCreateInput: PublicKeyCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicKeyCreateInput' is not null or undefined
            assertParamExists('postPublicKey', 'publicKeyCreateInput', publicKeyCreateInput)
            const localVarPath = `/user/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenCreateInput} tokenCreateInput User access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postToken: async (tokenCreateInput: TokenCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenCreateInput' is not null or undefined
            assertParamExists('postToken', 'tokenCreateInput', tokenCreateInput)
            const localVarPath = `/user/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TwoFactorCreateInput} twoFactorCreateInput Two-factor creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactor: async (twoFactorCreateInput: TwoFactorCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorCreateInput' is not null or undefined
            assertParamExists('postTwoFactor', 'twoFactorCreateInput', twoFactorCreateInput)
            const localVarPath = `/user/security/two_factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} publicKeyName Public key name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(publicKeyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(publicKeyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deletePublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSession(sessionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(sessionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(tokenName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(tokenName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTwoFactor(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTwoFactor(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeds(page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeedRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeeds(page, size, order, type, before, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getFeeds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHasPerm(repoRef: string, perm: Permission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHasPerm(repoRef, perm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getHasPerm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHeatmap(before?: number, after?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Heatmap>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHeatmap(before, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getHeatmap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberships(page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MembershipGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberships(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getMemberships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {PublicKeySort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(page?: number, size?: number, query?: string, sort?: PublicKeySort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getPublicKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTwoFactor(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFactorGetOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTwoFactor(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroups(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepos(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoParent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepos(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStars(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoParent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStars(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserStars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTwoFactor(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTwoFactor(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.patchTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserPatchInput} userPatchInput Update user infomation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserUser(userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUserUser(userPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.patchUserUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PublicKeyCreateInput} publicKeyCreateInput Create a new SSH public key for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPublicKey(publicKeyCreateInput: PublicKeyCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPublicKey(publicKeyCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.postPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TokenCreateInput} tokenCreateInput User access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postToken(tokenCreateInput: TokenCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenCreateOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postToken(tokenCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.postToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TwoFactorCreateInput} twoFactorCreateInput Two-factor creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTwoFactor(twoFactorCreateInput: TwoFactorCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTwoFactor(twoFactorCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.postTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {string} publicKeyName Public key name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(publicKeyName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePublicKey(publicKeyName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(sessionName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSession(sessionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(tokenName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteToken(tokenName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwoFactor(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTwoFactor(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeds(page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FeedRelations>> {
            return localVarFp.getFeeds(page, size, order, type, before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHasPerm(repoRef: string, perm: Permission, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.getHasPerm(repoRef, perm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeatmap(before?: number, after?: number, options?: RawAxiosRequestConfig): AxiosPromise<Heatmap> {
            return localVarFp.getHeatmap(before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberships(page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<MembershipGroup>> {
            return localVarFp.getMemberships(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {PublicKeySort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(page?: number, size?: number, query?: string, sort?: PublicKeySort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<PublicKeyModel>> {
            return localVarFp.getPublicKeys(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenModel>> {
            return localVarFp.getSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenModel>> {
            return localVarFp.getTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwoFactor(options?: RawAxiosRequestConfig): AxiosPromise<TwoFactorGetOutput> {
            return localVarFp.getTwoFactor(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupModel>> {
            return localVarFp.getUserGroups(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepos(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepoParent>> {
            return localVarFp.getUserRepos(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStars(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepoParent>> {
            return localVarFp.getUserStars(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUser(options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.getUserUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTwoFactor(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.patchTwoFactor(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserPatchInput} userPatchInput Update user infomation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserUser(userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.patchUserUser(userPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PublicKeyCreateInput} publicKeyCreateInput Create a new SSH public key for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPublicKey(publicKeyCreateInput: PublicKeyCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<PublicKeyModel> {
            return localVarFp.postPublicKey(publicKeyCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TokenCreateInput} tokenCreateInput User access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postToken(tokenCreateInput: TokenCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<TokenCreateOutput> {
            return localVarFp.postToken(tokenCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TwoFactorCreateInput} twoFactorCreateInput Two-factor creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactor(twoFactorCreateInput: TwoFactorCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postTwoFactor(twoFactorCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {string} publicKeyName Public key name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePublicKey(publicKeyName: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deletePublicKey(publicKeyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSession(sessionName: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteSession(sessionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tokenName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteToken(tokenName: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteToken(tokenName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTwoFactor(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteTwoFactor(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {OrderOption} [order] 
     * @param {FeedType} [type] 
     * @param {number} [before] 
     * @param {number} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeeds(page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getFeeds(page, size, order, type, before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef 
     * @param {Permission} perm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHasPerm(repoRef: string, perm: Permission, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getHasPerm(repoRef, perm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [before] 
     * @param {number} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHeatmap(before?: number, after?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getHeatmap(before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {MembershipSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMemberships(page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getMemberships(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {PublicKeySort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPublicKeys(page?: number, size?: number, query?: string, sort?: PublicKeySort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getPublicKeys(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessions(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTokens(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTwoFactor(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getTwoFactor(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {GroupSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserGroups(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserRepos(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserRepos(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserStars(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserStars(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserUser(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchTwoFactor(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).patchTwoFactor(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserPatchInput} userPatchInput Update user infomation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchUserUser(userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).patchUserUser(userPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PublicKeyCreateInput} publicKeyCreateInput Create a new SSH public key for the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPublicKey(publicKeyCreateInput: PublicKeyCreateInput, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).postPublicKey(publicKeyCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TokenCreateInput} tokenCreateInput User access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postToken(tokenCreateInput: TokenCreateInput, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).postToken(tokenCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TwoFactorCreateInput} twoFactorCreateInput Two-factor creation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTwoFactor(twoFactorCreateInput: TwoFactorCreateInput, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).postTwoFactor(twoFactorCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileGroups: async (identifier: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getProfileGroups', 'identifier', identifier)
            const localVarPath = `/users/{identifier}/groups`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileRepos: async (identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getProfileRepos', 'identifier', identifier)
            const localVarPath = `/users/{identifier}/repos`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFeeds: async (identifier: string, page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUsersFeeds', 'identifier', identifier)
            const localVarPath = `/users/{identifier}/feeds`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHasPerm: async (identifier: string, repoRef: string, perm: Permission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUsersHasPerm', 'identifier', identifier)
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getUsersHasPerm', 'repoRef', repoRef)
            // verify required parameter 'perm' is not null or undefined
            assertParamExists('getUsersHasPerm', 'perm', perm)
            const localVarPath = `/users/{identifier}/{repo_ref}/+/has_perm`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perm !== undefined) {
                localVarQueryParameter['perm'] = perm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHeatmap: async (identifier: string, before?: number, after?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUsersHeatmap', 'identifier', identifier)
            const localVarPath = `/users/{identifier}/heatmap`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersStars: async (identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUsersStars', 'identifier', identifier)
            const localVarPath = `/users/{identifier}/stars`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUser: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUsersUser', 'identifier', identifier)
            const localVarPath = `/users/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<UserType>} [types] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsers: async (page?: number, size?: number, query?: string, types?: Array<UserType>, sort?: UserSort, order?: OrderOption, admin?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileGroups(identifier: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileGroups(identifier, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getProfileGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileRepos(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoParent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileRepos(identifier, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getProfileRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersFeeds(identifier: string, page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeedRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersFeeds(identifier, page, size, order, type, before, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersFeeds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersHasPerm(identifier: string, repoRef: string, perm: Permission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersHasPerm(identifier, repoRef, perm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersHasPerm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersHeatmap(identifier: string, before?: number, after?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Heatmap>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersHeatmap(identifier, before, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersHeatmap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersStars(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoParent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersStars(identifier, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersStars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUser(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUser(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<UserType>} [types] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUsers(page?: number, size?: number, query?: string, types?: Array<UserType>, sort?: UserSort, order?: OrderOption, admin?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUsers(page, size, query, types, sort, order, admin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileGroups(identifier: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupModel>> {
            return localVarFp.getProfileGroups(identifier, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileRepos(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepoParent>> {
            return localVarFp.getProfileRepos(identifier, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFeeds(identifier: string, page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FeedRelations>> {
            return localVarFp.getUsersFeeds(identifier, page, size, order, type, before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHasPerm(identifier: string, repoRef: string, perm: Permission, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.getUsersHasPerm(identifier, repoRef, perm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHeatmap(identifier: string, before?: number, after?: number, options?: RawAxiosRequestConfig): AxiosPromise<Heatmap> {
            return localVarFp.getUsersHeatmap(identifier, before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersStars(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepoParent>> {
            return localVarFp.getUsersStars(identifier, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUser(identifier: string, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.getUsersUser(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<UserType>} [types] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsers(page?: number, size?: number, query?: string, types?: Array<UserType>, sort?: UserSort, order?: OrderOption, admin?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserModel>> {
            return localVarFp.getUsersUsers(page, size, query, types, sort, order, admin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {GroupSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProfileGroups(identifier: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getProfileGroups(identifier, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProfileRepos(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getProfileRepos(identifier, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {OrderOption} [order] 
     * @param {FeedType} [type] 
     * @param {number} [before] 
     * @param {number} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersFeeds(identifier: string, page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersFeeds(identifier, page, size, order, type, before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {string} repoRef 
     * @param {Permission} perm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersHasPerm(identifier: string, repoRef: string, perm: Permission, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersHasPerm(identifier, repoRef, perm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {number} [before] 
     * @param {number} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersHeatmap(identifier: string, before?: number, after?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersHeatmap(identifier, before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersStars(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersStars(identifier, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersUser(identifier: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersUser(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<UserType>} [types] 
     * @param {UserSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersUsers(page?: number, size?: number, query?: string, types?: Array<UserType>, sort?: UserSort, order?: OrderOption, admin?: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersUsers(page, size, query, types, sort, order, admin, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (repoRef: string, webhookIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteWebhook', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookIdentifier', webhookIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecution: async (repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getExecution', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('getExecution', 'webhookIdentifier', webhookIdentifier)
            // verify required parameter 'webhookExecutionId' is not null or undefined
            assertParamExists('getExecution', 'webhookExecutionId', webhookExecutionId)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}/executions/{webhook_execution_id}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)))
                .replace(`{${"webhook_execution_id"}}`, encodeURIComponent(String(webhookExecutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutions: async (repoRef: string, webhookIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getExecutions', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('getExecutions', 'webhookIdentifier', webhookIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}/executions`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (repoRef: string, webhookIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getWebhook', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('getWebhook', 'webhookIdentifier', webhookIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {WebhookSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: async (repoRef: string, page?: number, size?: number, query?: string, sort?: WebhookSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getWebhooks', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/webhooks`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {WebhookPatchInput} webhookPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWebhook: async (repoRef: string, webhookIdentifier: string, webhookPatchInput: WebhookPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchWebhook', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('patchWebhook', 'webhookIdentifier', webhookIdentifier)
            // verify required parameter 'webhookPatchInput' is not null or undefined
            assertParamExists('patchWebhook', 'webhookPatchInput', webhookPatchInput)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRetrigger: async (repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRetrigger', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('postRetrigger', 'webhookIdentifier', webhookIdentifier)
            // verify required parameter 'webhookExecutionId' is not null or undefined
            assertParamExists('postRetrigger', 'webhookExecutionId', webhookExecutionId)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}/executions/{webhook_execution_id}/retrigger`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)))
                .replace(`{${"webhook_execution_id"}}`, encodeURIComponent(String(webhookExecutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {WebhookCreateInput} webhookCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook: async (repoRef: string, webhookCreateInput: WebhookCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postWebhook', 'repoRef', repoRef)
            // verify required parameter 'webhookCreateInput' is not null or undefined
            assertParamExists('postWebhook', 'webhookCreateInput', webhookCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/webhooks`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(repoRef, webhookIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecution(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookExecutionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExecution(repoRef, webhookIdentifier, webhookExecutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getExecution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutions(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookExecutionModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExecutions(repoRef, webhookIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(repoRef, webhookIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {WebhookSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooks(repoRef: string, page?: number, size?: number, query?: string, sort?: WebhookSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks(repoRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {WebhookPatchInput} webhookPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWebhook(repoRef: string, webhookIdentifier: string, webhookPatchInput: WebhookPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchWebhook(repoRef, webhookIdentifier, webhookPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.patchWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRetrigger(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookExecutionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRetrigger(repoRef, webhookIdentifier, webhookExecutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postRetrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {WebhookCreateInput} webhookCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhook(repoRef: string, webhookCreateInput: WebhookCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhook(repoRef, webhookCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhook(repoRef, webhookIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecution(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig): AxiosPromise<WebhookExecutionModel> {
            return localVarFp.getExecution(repoRef, webhookIdentifier, webhookExecutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutions(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookExecutionModel>> {
            return localVarFp.getExecutions(repoRef, webhookIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookModel> {
            return localVarFp.getWebhook(repoRef, webhookIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {WebhookSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(repoRef: string, page?: number, size?: number, query?: string, sort?: WebhookSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookModel>> {
            return localVarFp.getWebhooks(repoRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {WebhookPatchInput} webhookPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWebhook(repoRef: string, webhookIdentifier: string, webhookPatchInput: WebhookPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<WebhookModel> {
            return localVarFp.patchWebhook(repoRef, webhookIdentifier, webhookPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRetrigger(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig): AxiosPromise<WebhookExecutionModel> {
            return localVarFp.postRetrigger(repoRef, webhookIdentifier, webhookExecutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {WebhookCreateInput} webhookCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(repoRef: string, webhookCreateInput: WebhookCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<WebhookModel> {
            return localVarFp.postWebhook(repoRef, webhookCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 */
export class WebhooksApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(repoRef, webhookIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {number} webhookExecutionId Webhook execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getExecution(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getExecution(repoRef, webhookIdentifier, webhookExecutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getExecutions(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getExecutions(repoRef, webhookIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhook(repoRef, webhookIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {WebhookSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWebhooks(repoRef: string, page?: number, size?: number, query?: string, sort?: WebhookSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhooks(repoRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {WebhookPatchInput} webhookPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchWebhook(repoRef: string, webhookIdentifier: string, webhookPatchInput: WebhookPatchInput, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).patchWebhook(repoRef, webhookIdentifier, webhookPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {number} webhookExecutionId Webhook execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRetrigger(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postRetrigger(repoRef, webhookIdentifier, webhookExecutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {WebhookCreateInput} webhookCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postWebhook(repoRef: string, webhookCreateInput: WebhookCreateInput, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhook(repoRef, webhookCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



