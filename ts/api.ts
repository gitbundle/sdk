/* tslint:disable */
/* eslint-disable */
/**
 * GitBundle API
 * GitBundle API documentation.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActionCreateInput
 */
export interface ActionCreateInput {
    /**
     * 
     * @type {string}
     * @memberof ActionCreateInput
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ActionCreateInput
     */
    'disabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof ActionCreateInput
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof ActionCreateInput
     */
    'yaml_path': string;
}
/**
 * 
 * @export
 * @interface ActionModel
 */
export interface ActionModel {
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ActionModel
     */
    'disabled': boolean;
    /**
     * 
     * @type {TriggerEvent}
     * @memberof ActionModel
     */
    'event'?: TriggerEvent | null;
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'repo_id': number;
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'seq': number;
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof ActionModel
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof ActionModel
     */
    'yaml_path': string;
    /**
     * 
     * @type {YamlProvider}
     * @memberof ActionModel
     */
    'yaml_provider': YamlProvider;
}


/**
 * 
 * @export
 * @interface ActionUpdateInput
 */
export interface ActionUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof ActionUpdateInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ActionUpdateInput
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ActionUpdateInput
     */
    'identifier'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionUpdateInput
     */
    'yaml_path'?: string | null;
}
/**
 * 
 * @export
 * @interface ActionWorkflow
 */
export interface ActionWorkflow {
    /**
     * 
     * @type {ActionModel}
     * @memberof ActionWorkflow
     */
    'model': ActionModel;
    /**
     * 
     * @type {WorkflowModel}
     * @memberof ActionWorkflow
     */
    'workflow'?: WorkflowModel | null;
}
/**
 * 
 * @export
 * @interface AdminPatchInput
 */
export interface AdminPatchInput {
    /**
     * 
     * @type {boolean}
     * @memberof AdminPatchInput
     */
    'admin': boolean;
}
/**
 * 
 * @export
 * @interface AdminStats
 */
export interface AdminStats {
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'total_groups': number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'total_users': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ArchiveAttribute = {
    ExportIgnore: 'export_ignore',
    ExportSubst: 'export_subst'
} as const;

export type ArchiveAttribute = typeof ArchiveAttribute[keyof typeof ArchiveAttribute];


/**
 * 
 * @export
 * @interface BlamePart
 */
export interface BlamePart {
    /**
     * 
     * @type {Commit}
     * @memberof BlamePart
     */
    'commit': Commit;
    /**
     * 
     * @type {Array<string>}
     * @memberof BlamePart
     */
    'lines': Array<string>;
}
/**
 * 
 * @export
 * @interface BootstrapMetadata
 */
export interface BootstrapMetadata {
    /**
     * 
     * @type {GroupModel}
     * @memberof BootstrapMetadata
     */
    'group'?: GroupModel | null;
    /**
     * 
     * @type {PathRefInfo}
     * @memberof BootstrapMetadata
     */
    'path_ref'?: PathRefInfo | null;
    /**
     * 
     * @type {RepoParent}
     * @memberof BootstrapMetadata
     */
    'repo'?: RepoParent | null;
    /**
     * 
     * @type {UserModel}
     * @memberof BootstrapMetadata
     */
    'user'?: UserModel | null;
}
/**
 * 
 * @export
 * @interface BranchCreateInput
 */
export interface BranchCreateInput {
    /**
     * 
     * @type {boolean}
     * @memberof BranchCreateInput
     */
    'bypass_rules': boolean;
    /**
     * 
     * @type {string}
     * @memberof BranchCreateInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BranchCreateInput
     */
    'target'?: string | null;
}
/**
 * 
 * @export
 * @interface BranchRenameInput
 */
export interface BranchRenameInput {
    /**
     * 
     * @type {boolean}
     * @memberof BranchRenameInput
     */
    'bypass_rules': boolean;
    /**
     * 
     * @type {string}
     * @memberof BranchRenameInput
     */
    'new_name': string;
    /**
     * 
     * @type {string}
     * @memberof BranchRenameInput
     */
    'old_name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CIStatus = {
    Pending: 'pending',
    Initializing: 'initializing',
    Skipped: 'skipped',
    Blocked: 'blocked',
    Declined: 'declined',
    Running: 'running',
    Success: 'success',
    Failure: 'failure',
    Killed: 'killed',
    Error: 'error'
} as const;

export type CIStatus = typeof CIStatus[keyof typeof CIStatus];


/**
 * 
 * @export
 * @interface CheckModel
 */
export interface CheckModel {
    /**
     * 
     * @type {string}
     * @memberof CheckModel
     */
    'commit_sha': string;
    /**
     * 
     * @type {number}
     * @memberof CheckModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof CheckModel
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof CheckModel
     */
    'ended': number;
    /**
     * 
     * @type {number}
     * @memberof CheckModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CheckModel
     */
    'link': string;
    /**
     * 
     * @type {any}
     * @memberof CheckModel
     */
    'metadata': any;
    /**
     * 
     * @type {string}
     * @memberof CheckModel
     */
    'name': string;
    /**
     * 
     * @type {CheckPayload}
     * @memberof CheckModel
     */
    'payload': CheckPayload;
    /**
     * 
     * @type {CheckPayloadKind}
     * @memberof CheckModel
     */
    'payload_kind': CheckPayloadKind;
    /**
     * 
     * @type {string}
     * @memberof CheckModel
     */
    'payload_version': string;
    /**
     * 
     * @type {number}
     * @memberof CheckModel
     */
    'repo_id': number;
    /**
     * 
     * @type {number}
     * @memberof CheckModel
     */
    'started': number;
    /**
     * 
     * @type {CheckStatus}
     * @memberof CheckModel
     */
    'status': CheckStatus;
    /**
     * 
     * @type {string}
     * @memberof CheckModel
     */
    'summary': string;
    /**
     * 
     * @type {number}
     * @memberof CheckModel
     */
    'updated': number;
}


/**
 * 
 * @export
 * @interface CheckPayload
 */
export interface CheckPayload {
    /**
     * 
     * @type {any}
     * @memberof CheckPayload
     */
    'data': any;
    /**
     * 
     * @type {CheckPayloadKind}
     * @memberof CheckPayload
     */
    'kind': CheckPayloadKind;
    /**
     * 
     * @type {string}
     * @memberof CheckPayload
     */
    'version': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CheckPayloadKind = {
    Empty: 'empty',
    Raw: 'raw',
    Markdown: 'markdown',
    Action: 'action'
} as const;

export type CheckPayloadKind = typeof CheckPayloadKind[keyof typeof CheckPayloadKind];


/**
 * 
 * @export
 * @interface CheckReportInput
 */
export interface CheckReportInput {
    /**
     * 
     * @type {number}
     * @memberof CheckReportInput
     */
    'ended': number;
    /**
     * 
     * @type {string}
     * @memberof CheckReportInput
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof CheckReportInput
     */
    'name': string;
    /**
     * 
     * @type {CheckPayload}
     * @memberof CheckReportInput
     */
    'payload': CheckPayload;
    /**
     * 
     * @type {number}
     * @memberof CheckReportInput
     */
    'started': number;
    /**
     * 
     * @type {CheckStatus}
     * @memberof CheckReportInput
     */
    'status': CheckStatus;
    /**
     * 
     * @type {string}
     * @memberof CheckReportInput
     */
    'summary': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CheckStatus = {
    Pending: 'pending',
    Running: 'running',
    Success: 'success',
    Failure: 'failure',
    Error: 'error'
} as const;

export type CheckStatus = typeof CheckStatus[keyof typeof CheckStatus];


/**
 * 
 * @export
 * @interface CodeOwnerEvaluation
 */
export interface CodeOwnerEvaluation {
    /**
     * 
     * @type {Array<CodeOwnerEvaluationEntry>}
     * @memberof CodeOwnerEvaluation
     */
    'evaluation_entries': Array<CodeOwnerEvaluationEntry>;
    /**
     * 
     * @type {string}
     * @memberof CodeOwnerEvaluation
     */
    'file_sha': string;
}
/**
 * 
 * @export
 * @interface CodeOwnerEvaluationEntry
 */
export interface CodeOwnerEvaluationEntry {
    /**
     * 
     * @type {Array<OwnerEvaluation>}
     * @memberof CodeOwnerEvaluationEntry
     */
    'owner_evaluations': Array<OwnerEvaluation>;
    /**
     * 
     * @type {string}
     * @memberof CodeOwnerEvaluationEntry
     */
    'pattern': string;
    /**
     * 
     * @type {Array<UserGroupOwnerEvaluation>}
     * @memberof CodeOwnerEvaluationEntry
     */
    'usergroup_owner_evaluations': Array<UserGroupOwnerEvaluation>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CodeOwnerViolationCode = {
    Noop: 'noop',
    UserNotFound: 'user_not_found',
    PatternInvalid: 'pattern_invalid',
    PatternEmpty: 'pattern_empty'
} as const;

export type CodeOwnerViolationCode = typeof CodeOwnerViolationCode[keyof typeof CodeOwnerViolationCode];


/**
 * 
 * @export
 * @interface CodeOwnersValidation
 */
export interface CodeOwnersValidation {
    /**
     * 
     * @type {Array<CodeOwnersViolation>}
     * @memberof CodeOwnersValidation
     */
    'violations': Array<CodeOwnersViolation>;
}
/**
 * 
 * @export
 * @interface CodeOwnersViolation
 */
export interface CodeOwnersViolation {
    /**
     * 
     * @type {CodeOwnerViolationCode}
     * @memberof CodeOwnersViolation
     */
    'code': CodeOwnerViolationCode;
    /**
     * 
     * @type {string}
     * @memberof CodeOwnersViolation
     */
    'message': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof CodeOwnersViolation
     */
    'params': Array<any>;
}


/**
 * 
 * @export
 * @interface Commit
 */
export interface Commit {
    /**
     * 
     * @type {Identity}
     * @memberof Commit
     */
    'author': Identity;
    /**
     * 
     * @type {Identity}
     * @memberof Commit
     */
    'committer': Identity;
    /**
     * 
     * @type {Array<CommitFileStats>}
     * @memberof Commit
     */
    'file_stats': Array<CommitFileStats>;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'message': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Commit
     */
    'parent_shas': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'sha': string;
    /**
     * 
     * @type {CommitGPGSignature}
     * @memberof Commit
     */
    'signature'?: CommitGPGSignature | null;
    /**
     * 
     * @type {string}
     * @memberof Commit
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface CommitBranch
 */
export interface CommitBranch {
    /**
     * 
     * @type {Commit}
     * @memberof CommitBranch
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {string}
     * @memberof CommitBranch
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CommitBranch
     */
    'sha': string;
}
/**
 * 
 * @export
 * @interface CommitDiffFile
 */
export interface CommitDiffFile {
    /**
     * 
     * @type {number}
     * @memberof CommitDiffFile
     */
    'end_line'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommitDiffFile
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommitDiffFile
     */
    'start_line'?: number;
}
/**
 * 
 * @export
 * @interface CommitDivergence
 */
export interface CommitDivergence {
    /**
     * 
     * @type {number}
     * @memberof CommitDivergence
     */
    'ahead': number;
    /**
     * 
     * @type {number}
     * @memberof CommitDivergence
     */
    'behind': number;
}
/**
 * 
 * @export
 * @interface CommitDivergenceRequest
 */
export interface CommitDivergenceRequest {
    /**
     * 
     * @type {string}
     * @memberof CommitDivergenceRequest
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof CommitDivergenceRequest
     */
    'to': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CommitFileActionType = {
    Create: 'create',
    Update: 'update',
    Delete: 'delete',
    Move: 'move',
    PatchText: 'patch_text'
} as const;

export type CommitFileActionType = typeof CommitFileActionType[keyof typeof CommitFileActionType];


/**
 * 
 * @export
 * @interface CommitFileStats
 */
export interface CommitFileStats {
    /**
     * 
     * @type {FileDiffStatus}
     * @memberof CommitFileStats
     */
    'change_type': FileDiffStatus;
    /**
     * 
     * @type {number}
     * @memberof CommitFileStats
     */
    'deletions': number;
    /**
     * 
     * @type {number}
     * @memberof CommitFileStats
     */
    'insertions': number;
    /**
     * 
     * @type {string}
     * @memberof CommitFileStats
     */
    'old_path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CommitFileStats
     */
    'path': string;
}


/**
 * 
 * @export
 * @interface CommitFilesInput
 */
export interface CommitFilesInput {
    /**
     * 
     * @type {Array<RepoCommitFileAction>}
     * @memberof CommitFilesInput
     */
    'actions': Array<RepoCommitFileAction>;
    /**
     * 
     * @type {string}
     * @memberof CommitFilesInput
     */
    'branch': string;
    /**
     * 
     * @type {boolean}
     * @memberof CommitFilesInput
     */
    'bypass_rules'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CommitFilesInput
     */
    'dry_run_rules'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CommitFilesInput
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CommitFilesInput
     */
    'new_branch': string;
    /**
     * 
     * @type {string}
     * @memberof CommitFilesInput
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface CommitFilesOutput
 */
export interface CommitFilesOutput {
    /**
     * 
     * @type {string}
     * @memberof CommitFilesOutput
     */
    'commit_sha': string;
    /**
     * 
     * @type {boolean}
     * @memberof CommitFilesOutput
     */
    'dry_run_rules': boolean;
    /**
     * 
     * @type {Array<RuleCheckResult>}
     * @memberof CommitFilesOutput
     */
    'rule_checks': Array<RuleCheckResult>;
}
/**
 * 
 * @export
 * @interface CommitGPGSignature
 */
export interface CommitGPGSignature {
    /**
     * 
     * @type {string}
     * @memberof CommitGPGSignature
     */
    'payload': string;
    /**
     * 
     * @type {string}
     * @memberof CommitGPGSignature
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface CommitTag
 */
export interface CommitTag {
    /**
     * 
     * @type {Commit}
     * @memberof CommitTag
     */
    'commit'?: Commit | null;
    /**
     * 
     * @type {boolean}
     * @memberof CommitTag
     */
    'is_annotated': boolean;
    /**
     * 
     * @type {string}
     * @memberof CommitTag
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CommitTag
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CommitTag
     */
    'sha': string;
    /**
     * 
     * @type {Identity}
     * @memberof CommitTag
     */
    'tagger'?: Identity | null;
    /**
     * 
     * @type {string}
     * @memberof CommitTag
     */
    'title'?: string | null;
}
/**
 * 
 * @export
 * @interface CommitWithPathRenameDetails
 */
export interface CommitWithPathRenameDetails {
    /**
     * 
     * @type {Commit}
     * @memberof CommitWithPathRenameDetails
     */
    'commit': Commit;
    /**
     * 
     * @type {PathRenameDetails}
     * @memberof CommitWithPathRenameDetails
     */
    'path_rename_details'?: PathRenameDetails | null;
}
/**
 * 
 * @export
 * @interface ConnectorCreateInput
 */
export interface ConnectorCreateInput {
    /**
     * 
     * @type {string}
     * @memberof ConnectorCreateInput
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorCreateInput
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorCreateInput
     */
    'group_ref': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorCreateInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorCreateInput
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ConnectorModel
 */
export interface ConnectorModel {
    /**
     * 
     * @type {number}
     * @memberof ConnectorModel
     */
    'created': number;
    /**
     * 
     * @type {string}
     * @memberof ConnectorModel
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorModel
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof ConnectorModel
     */
    'group_id': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ConnectorModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorModel
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof ConnectorModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof ConnectorModel
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface ConnectorPatchInput
 */
export interface ConnectorPatchInput {
    /**
     * 
     * @type {string}
     * @memberof ConnectorPatchInput
     */
    'data'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorPatchInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorPatchInput
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface Contributor
 */
export interface Contributor {
    /**
     * 
     * @type {string}
     * @memberof Contributor
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contributor
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof Contributor
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Contributor
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Contributor
     */
    'num_commits': number;
}
/**
 * 
 * @export
 * @interface CreatedOption
 */
export interface CreatedOption {
    /**
     * 
     * @type {number}
     * @memberof CreatedOption
     */
    'created_gt'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreatedOption
     */
    'created_lt'?: number | null;
}
/**
 * 
 * @export
 * @interface DefApprovals
 */
export interface DefApprovals {
    /**
     * 
     * @type {boolean}
     * @memberof DefApprovals
     */
    'require_code_owners'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DefApprovals
     */
    'require_latest_commit'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DefApprovals
     */
    'require_minimum_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DefApprovals
     */
    'require_no_change_request'?: boolean;
}
/**
 * 
 * @export
 * @interface DefBypass
 */
export interface DefBypass {
    /**
     * 
     * @type {boolean}
     * @memberof DefBypass
     */
    'repo_owners'?: boolean;
    /**
     * 
     * @type {Array<UserModel>}
     * @memberof DefBypass
     */
    'users'?: Array<UserModel>;
}
/**
 * 
 * @export
 * @interface DefComments
 */
export interface DefComments {
    /**
     * 
     * @type {boolean}
     * @memberof DefComments
     */
    'require_resolve_all'?: boolean;
}
/**
 * 
 * @export
 * @interface DefLifecycle
 */
export interface DefLifecycle {
    /**
     * 
     * @type {boolean}
     * @memberof DefLifecycle
     */
    'create_forbidden'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DefLifecycle
     */
    'delete_forbidden'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DefLifecycle
     */
    'update_forbidden'?: boolean;
}
/**
 * 
 * @export
 * @interface DefMerge
 */
export interface DefMerge {
    /**
     * 
     * @type {boolean}
     * @memberof DefMerge
     */
    'delete_branch'?: boolean;
    /**
     * 
     * @type {Array<PullreqMergeMethod>}
     * @memberof DefMerge
     */
    'strategies_allowed'?: Array<PullreqMergeMethod>;
}
/**
 * 
 * @export
 * @interface DefPullreq
 */
export interface DefPullreq {
    /**
     * 
     * @type {DefApprovals}
     * @memberof DefPullreq
     */
    'approvals'?: DefApprovals;
    /**
     * 
     * @type {DefComments}
     * @memberof DefPullreq
     */
    'comments'?: DefComments;
    /**
     * 
     * @type {DefMerge}
     * @memberof DefPullreq
     */
    'merge'?: DefMerge;
    /**
     * 
     * @type {DefStatusChecks}
     * @memberof DefPullreq
     */
    'status_checks'?: DefStatusChecks;
}
/**
 * 
 * @export
 * @interface DefStatusChecks
 */
export interface DefStatusChecks {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefStatusChecks
     */
    'require_uids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DiffFileContent
 */
export interface DiffFileContent {
    /**
     * 
     * @type {string}
     * @memberof DiffFileContent
     */
    'header'?: string | null;
    /**
     * 
     * @type {HunkHeader}
     * @memberof DiffFileContent
     */
    'hunk'?: HunkHeader | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DiffFileContent
     */
    'lines': Array<string>;
}
/**
 * 
 * @export
 * @interface DiffStats
 */
export interface DiffStats {
    /**
     * 
     * @type {number}
     * @memberof DiffStats
     */
    'commits'?: number;
    /**
     * 
     * @type {number}
     * @memberof DiffStats
     */
    'files_changed'?: number;
}
/**
 * 
 * @export
 * @interface FeedModel
 */
export interface FeedModel {
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'date_contribution'?: number | null;
    /**
     * 
     * @type {FeedType}
     * @memberof FeedModel
     */
    'feed_type': FeedType;
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof FeedModel
     */
    'is_private': boolean;
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'num_contributions'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof FeedModel
     */
    'payload': any;
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'pullreq_activity_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'pullreq_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'pullreq_review_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'release_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'repo_id': number;
    /**
     * 
     * @type {number}
     * @memberof FeedModel
     */
    'updated': number;
}


/**
 * 
 * @export
 * @interface FeedRelations
 */
export interface FeedRelations {
    /**
     * 
     * @type {UserModel}
     * @memberof FeedRelations
     */
    'creator'?: UserModel | null;
    /**
     * 
     * @type {FeedModel}
     * @memberof FeedRelations
     */
    'model': FeedModel;
    /**
     * 
     * @type {PullreqAuthor}
     * @memberof FeedRelations
     */
    'pullreq'?: PullreqAuthor | null;
    /**
     * 
     * @type {PullreqActivityCreator}
     * @memberof FeedRelations
     */
    'pullreq_activity'?: PullreqActivityCreator | null;
    /**
     * 
     * @type {PullreqReviewCreator}
     * @memberof FeedRelations
     */
    'pullreq_review'?: PullreqReviewCreator | null;
    /**
     * 
     * @type {ReleaseCreator}
     * @memberof FeedRelations
     */
    'release'?: ReleaseCreator | null;
    /**
     * 
     * @type {RepositoryModel}
     * @memberof FeedRelations
     */
    'repo'?: RepositoryModel | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FeedType = {
    Noop: 'noop',
    RepoCreated: 'repo_created',
    RepoImported: 'repo_imported',
    RepoDeleted: 'repo_deleted',
    RepoForked: 'repo_forked',
    RepoRenamed: 'repo_renamed',
    RepoTransferred: 'repo_transferred',
    RepoRestored: 'repo_restored',
    BranchCreated: 'branch_created',
    BranchRenamed: 'branch_renamed',
    BranchDeleted: 'branch_deleted',
    TagCreated: 'tag_created',
    TagDeleted: 'tag_deleted',
    CommitsPushed: 'commits_pushed',
    PullRequestCreated: 'pull_request_created',
    PullRequestClosed: 'pull_request_closed',
    PullRequestReopened: 'pull_request_reopened',
    PullRequestMerged: 'pull_request_merged',
    PullRequestReviewed: 'pull_request_reviewed',
    PullRequestCommented: 'pull_request_commented',
    ReleaseCreated: 'release_created',
    ReleaseDeleted: 'release_deleted'
} as const;

export type FeedType = typeof FeedType[keyof typeof FeedType];


/**
 * 
 * @export
 * @enum {string}
 */

export const FileDiffStatus = {
    Undefined: 'undefined',
    Added: 'added',
    Deleted: 'deleted',
    Modified: 'modified',
    Renamed: 'renamed',
    Copied: 'copied'
} as const;

export type FileDiffStatus = typeof FileDiffStatus[keyof typeof FileDiffStatus];


/**
 * 
 * @export
 * @interface GeneralSettings
 */
export interface GeneralSettings {
    /**
     * 
     * @type {number}
     * @memberof GeneralSettings
     */
    'file_size_limit': number;
}
/**
 * 
 * @export
 * @interface GroupCreateInput
 */
export interface GroupCreateInput {
    /**
     * 
     * @type {string}
     * @memberof GroupCreateInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupCreateInput
     */
    'identifier': string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupCreateInput
     */
    'is_public': boolean;
    /**
     * 
     * @type {string}
     * @memberof GroupCreateInput
     */
    'parent_ref': string;
}
/**
 * 
 * @export
 * @interface GroupImportInput
 */
export interface GroupImportInput {
    /**
     * 
     * @type {string}
     * @memberof GroupImportInput
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupImportInput
     */
    'identifier': string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupImportInput
     */
    'is_public': boolean;
    /**
     * 
     * @type {string}
     * @memberof GroupImportInput
     */
    'parent_ref': string;
    /**
     * 
     * @type {RepoProvider}
     * @memberof GroupImportInput
     */
    'provider': RepoProvider;
    /**
     * 
     * @type {string}
     * @memberof GroupImportInput
     */
    'provider_group': string;
}
/**
 * 
 * @export
 * @interface GroupImportReposInput
 */
export interface GroupImportReposInput {
    /**
     * 
     * @type {RepoProvider}
     * @memberof GroupImportReposInput
     */
    'provider': RepoProvider;
    /**
     * 
     * @type {string}
     * @memberof GroupImportReposInput
     */
    'provider_group': string;
}
/**
 * 
 * @export
 * @interface GroupImportReposOutput
 */
export interface GroupImportReposOutput {
    /**
     * 
     * @type {Array<Array<any>>}
     * @memberof GroupImportReposOutput
     */
    'failed_repos': Array<Array<any>>;
    /**
     * 
     * @type {Array<RepositoryModel>}
     * @memberof GroupImportReposOutput
     */
    'succeed_repos': Array<RepositoryModel>;
}
/**
 * 
 * @export
 * @interface GroupMemberAddInput
 */
export interface GroupMemberAddInput {
    /**
     * 
     * @type {MembershipRole}
     * @memberof GroupMemberAddInput
     */
    'role': MembershipRole;
    /**
     * 
     * @type {string}
     * @memberof GroupMemberAddInput
     */
    'user_identifier': string;
}


/**
 * 
 * @export
 * @interface GroupMemberUpdateInput
 */
export interface GroupMemberUpdateInput {
    /**
     * 
     * @type {MembershipRole}
     * @memberof GroupMemberUpdateInput
     */
    'role': MembershipRole;
}


/**
 * 
 * @export
 * @interface GroupModel
 */
export interface GroupModel {
    /**
     * 
     * @type {number}
     * @memberof GroupModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof GroupModel
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof GroupModel
     */
    'deleted'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GroupModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GroupModel
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof GroupModel
     */
    'is_public': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GroupModel
     */
    'is_user_home': boolean;
    /**
     * 
     * @type {string}
     * @memberof GroupModel
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GroupModel
     */
    'parent_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GroupModel
     */
    'path'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GroupModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof GroupModel
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface GroupMoveInput
 */
export interface GroupMoveInput {
    /**
     * 
     * @type {string}
     * @memberof GroupMoveInput
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface GroupPatchInput
 */
export interface GroupPatchInput {
    /**
     * 
     * @type {string}
     * @memberof GroupPatchInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GroupPatchInput
     */
    'is_public'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GroupProviderInput
 */
export interface GroupProviderInput {
    /**
     * 
     * @type {RepoProvider}
     * @memberof GroupProviderInput
     */
    'provider': RepoProvider;
    /**
     * 
     * @type {string}
     * @memberof GroupProviderInput
     */
    'provider_group': string;
}
/**
 * 
 * @export
 * @interface GroupRestoreInput
 */
export interface GroupRestoreInput {
    /**
     * 
     * @type {string}
     * @memberof GroupRestoreInput
     */
    'new_identifier'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupRestoreInput
     */
    'new_parent_ref'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GroupSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Created: 'created',
    Updated: 'updated'
} as const;

export type GroupSort = typeof GroupSort[keyof typeof GroupSort];


/**
 * 
 * @export
 * @interface Heatmap
 */
export interface Heatmap {
    /**
     * 
     * @type {Array<NumContributonWithDate>}
     * @memberof Heatmap
     */
    'contributions': Array<NumContributonWithDate>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Heatmap
     */
    'years': Array<number>;
}
/**
 * 
 * @export
 * @interface HunkHeader
 */
export interface HunkHeader {
    /**
     * 
     * @type {number}
     * @memberof HunkHeader
     */
    'new_line': number;
    /**
     * 
     * @type {number}
     * @memberof HunkHeader
     */
    'new_span': number;
    /**
     * 
     * @type {number}
     * @memberof HunkHeader
     */
    'old_line': number;
    /**
     * 
     * @type {number}
     * @memberof HunkHeader
     */
    'old_span': number;
    /**
     * 
     * @type {string}
     * @memberof HunkHeader
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof Identity
     */
    'existing'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Identity
     */
    'when'?: number | null;
}
/**
 * 
 * @export
 * @interface JobProgress
 */
export interface JobProgress {
    /**
     * 
     * @type {string}
     * @memberof JobProgress
     */
    'failure': string;
    /**
     * 
     * @type {number}
     * @memberof JobProgress
     */
    'progress': number;
    /**
     * 
     * @type {string}
     * @memberof JobProgress
     */
    'result': string;
    /**
     * 
     * @type {JobState}
     * @memberof JobProgress
     */
    'state': JobState;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const JobState = {
    Pending: 'pending',
    Scheduled: 'scheduled',
    Running: 'running',
    Finished: 'finished',
    Failed: 'failed',
    Canceled: 'canceled'
} as const;

export type JobState = typeof JobState[keyof typeof JobState];


/**
 * 
 * @export
 * @interface JsonErrorResponseNull
 */
export interface JsonErrorResponseNull {
    /**
     * 
     * @type {number}
     * @memberof JsonErrorResponseNull
     */
    'code': number;
    /**
     * 
     * @type {any}
     * @memberof JsonErrorResponseNull
     */
    'data'?: any;
    /**
     * 
     * @type {string}
     * @memberof JsonErrorResponseNull
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface License
 */
export interface License {
    /**
     * 
     * @type {string}
     * @memberof License
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof License
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface LiveLogLine
 */
export interface LiveLogLine {
    /**
     * 
     * @type {string}
     * @memberof LiveLogLine
     */
    'command'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LiveLogLine
     */
    'out': string;
    /**
     * 
     * @type {number}
     * @memberof LiveLogLine
     */
    'pos': number;
    /**
     * 
     * @type {number}
     * @memberof LiveLogLine
     */
    'time': number;
}
/**
 * 
 * @export
 * @interface LoginInput
 */
export interface LoginInput {
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginOutput
 */
export interface LoginOutput {
    /**
     * 
     * @type {string}
     * @memberof LoginOutput
     */
    'access_token': string;
    /**
     * 
     * @type {number}
     * @memberof LoginOutput
     */
    'expires_at'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof LoginOutput
     */
    'two_factor_enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface MembershipGroup
 */
export interface MembershipGroup {
    /**
     * 
     * @type {Array<GroupModel>}
     * @memberof MembershipGroup
     */
    'groups': Array<GroupModel>;
    /**
     * 
     * @type {MembershipModel}
     * @memberof MembershipGroup
     */
    'model': MembershipModel;
}
/**
 * 
 * @export
 * @interface MembershipModel
 */
export interface MembershipModel {
    /**
     * 
     * @type {number}
     * @memberof MembershipModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof MembershipModel
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof MembershipModel
     */
    'group_id': number;
    /**
     * 
     * @type {number}
     * @memberof MembershipModel
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof MembershipModel
     */
    'removeable': boolean;
    /**
     * 
     * @type {MembershipRole}
     * @memberof MembershipModel
     */
    'role': MembershipRole;
    /**
     * 
     * @type {number}
     * @memberof MembershipModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof MembershipModel
     */
    'user_id': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MembershipRole = {
    Reader: 'reader',
    Executor: 'executor',
    Contributor: 'contributor',
    Owner: 'owner'
} as const;

export type MembershipRole = typeof MembershipRole[keyof typeof MembershipRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const MembershipSort = {
    Noop: 'noop',
    Id: 'id',
    Created: 'created'
} as const;

export type MembershipSort = typeof MembershipSort[keyof typeof MembershipSort];


/**
 * 
 * @export
 * @interface MembershipUserGroup
 */
export interface MembershipUserGroup {
    /**
     * 
     * @type {GroupModel}
     * @memberof MembershipUserGroup
     */
    'group'?: GroupModel | null;
    /**
     * 
     * @type {MembershipModel}
     * @memberof MembershipUserGroup
     */
    'model': MembershipModel;
    /**
     * 
     * @type {UserModel}
     * @memberof MembershipUserGroup
     */
    'user'?: UserModel | null;
}
/**
 * 
 * @export
 * @interface NumContributonWithDate
 */
export interface NumContributonWithDate {
    /**
     * 
     * @type {number}
     * @memberof NumContributonWithDate
     */
    'date_contribution': number;
    /**
     * 
     * @type {number}
     * @memberof NumContributonWithDate
     */
    'num_contributions': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderOption = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type OrderOption = typeof OrderOption[keyof typeof OrderOption];


/**
 * 
 * @export
 * @interface OwnerEvaluation
 */
export interface OwnerEvaluation {
    /**
     * 
     * @type {UserModel}
     * @memberof OwnerEvaluation
     */
    'owner'?: UserModel | null;
    /**
     * 
     * @type {PullreqReviewDecision}
     * @memberof OwnerEvaluation
     */
    'review_decision': PullreqReviewDecision;
    /**
     * 
     * @type {string}
     * @memberof OwnerEvaluation
     */
    'review_sha': string;
}


/**
 * 
 * @export
 * @interface PageOption
 */
export interface PageOption {
    /**
     * 
     * @type {number}
     * @memberof PageOption
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageOption
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ParentResourceType = {
    Group: 'group',
    Repository: 'repository'
} as const;

export type ParentResourceType = typeof ParentResourceType[keyof typeof ParentResourceType];


/**
 * 
 * @export
 * @interface PathDetails
 */
export interface PathDetails {
    /**
     * 
     * @type {Commit}
     * @memberof PathDetails
     */
    'last_commit': Commit;
    /**
     * 
     * @type {string}
     * @memberof PathDetails
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface PathRefInfo
 */
export interface PathRefInfo {
    /**
     * 
     * @type {string}
     * @memberof PathRefInfo
     */
    'ref_name': string;
    /**
     * 
     * @type {PathRefType}
     * @memberof PathRefInfo
     */
    'ref_type': PathRefType;
    /**
     * 
     * @type {string}
     * @memberof PathRefInfo
     */
    'repo_path': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PathRefType = {
    Branch: 'branch',
    Tag: 'tag',
    Commit: 'commit'
} as const;

export type PathRefType = typeof PathRefType[keyof typeof PathRefType];


/**
 * 
 * @export
 * @interface PathRenameDetails
 */
export interface PathRenameDetails {
    /**
     * 
     * @type {string}
     * @memberof PathRenameDetails
     */
    'commit_sha_after'?: string;
    /**
     * 
     * @type {string}
     * @memberof PathRenameDetails
     */
    'commit_sha_before'?: string;
    /**
     * 
     * @type {string}
     * @memberof PathRenameDetails
     */
    'old_path': string;
    /**
     * 
     * @type {string}
     * @memberof PathRenameDetails
     */
    'path': string;
}
/**
 * Permission represents the different types of permissions a principal can have.
 * @export
 * @enum {string}
 */

export const Permission = {
    GroupView: 'group_view',
    GroupEdit: 'group_edit',
    GroupDelete: 'group_delete',
    RepoView: 'repo_view',
    RepoEdit: 'repo_edit',
    RepoDelete: 'repo_delete',
    RepoPush: 'repo_push',
    RepoReportCommitCheck: 'repo_report_commit_check',
    UserView: 'user_view',
    UserEdit: 'user_edit',
    UserDelete: 'user_delete',
    UserEditAdmin: 'user_edit_admin',
    ServiceAccountView: 'service_account_view',
    ServiceAccountEdit: 'service_account_edit',
    ServiceAccountDelete: 'service_account_delete',
    ServiceView: 'service_view',
    ServiceEdit: 'service_edit',
    ServiceDelete: 'service_delete',
    ServiceEditAdmin: 'service_edit_admin',
    ActionView: 'action_view',
    ActionEdit: 'action_edit',
    ActionDelete: 'action_delete',
    ActionExecute: 'action_execute',
    VariableView: 'variable_view',
    VariableEdit: 'variable_edit',
    VariableDelete: 'variable_delete',
    VariableAccess: 'variable_access',
    ConnectorView: 'connector_view',
    ConnectorEdit: 'connector_edit',
    ConnectorDelete: 'connector_delete',
    ConnectorAccess: 'connector_access',
    TemplateView: 'template_view',
    TemplateEdit: 'template_edit',
    TemplateDelete: 'template_delete',
    TemplateAccess: 'template_access',
    RunnerView: 'runner_view',
    RunnerAdd: 'runner_add',
    RunnerDelete: 'runner_delete',
    RunnerEdit: 'runner_edit',
    RunnerAccess: 'runner_access'
} as const;

export type Permission = typeof Permission[keyof typeof Permission];


/**
 * 
 * @export
 * @interface ProtectionBranch
 */
export interface ProtectionBranch {
    /**
     * 
     * @type {DefBypass}
     * @memberof ProtectionBranch
     */
    'bypass'?: DefBypass;
    /**
     * 
     * @type {DefLifecycle}
     * @memberof ProtectionBranch
     */
    'lifecycle'?: DefLifecycle;
    /**
     * 
     * @type {DefPullreq}
     * @memberof ProtectionBranch
     */
    'pullreq'?: DefPullreq;
}
/**
 * 
 * @export
 * @interface ProtectionDefinition
 */
export interface ProtectionDefinition {
    /**
     * 
     * @type {ProtectionBranch}
     * @memberof ProtectionDefinition
     */
    'branch': ProtectionBranch;
}
/**
 * 
 * @export
 * @interface ProtectionPattern
 */
export interface ProtectionPattern {
    /**
     * 
     * @type {boolean}
     * @memberof ProtectionPattern
     */
    'default'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProtectionPattern
     */
    'exclude'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProtectionPattern
     */
    'include'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PublicKeyCreateInput
 */
export interface PublicKeyCreateInput {
    /**
     * 
     * @type {string}
     * @memberof PublicKeyCreateInput
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyCreateInput
     */
    'name'?: string | null;
    /**
     * 
     * @type {PublicKeyUsage}
     * @memberof PublicKeyCreateInput
     */
    'usage': PublicKeyUsage;
}


/**
 * 
 * @export
 * @interface PublicKeyModel
 */
export interface PublicKeyModel {
    /**
     * 
     * @type {string}
     * @memberof PublicKeyModel
     */
    'comment': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PublicKeyModel
     */
    'content': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof PublicKeyModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof PublicKeyModel
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyModel
     */
    'fingerprint': string;
    /**
     * 
     * @type {number}
     * @memberof PublicKeyModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyModel
     */
    'type': string;
    /**
     * 
     * @type {PublicKeyUsage}
     * @memberof PublicKeyModel
     */
    'usage': PublicKeyUsage;
    /**
     * 
     * @type {number}
     * @memberof PublicKeyModel
     */
    'verified'?: number | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PublicKeySort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Created: 'created'
} as const;

export type PublicKeySort = typeof PublicKeySort[keyof typeof PublicKeySort];


/**
 * 
 * @export
 * @enum {string}
 */

export const PublicKeyUsage = {
    Auth: 'auth',
    Sign: 'sign'
} as const;

export type PublicKeyUsage = typeof PublicKeyUsage[keyof typeof PublicKeyUsage];


/**
 * 
 * @export
 * @interface PullreqActivityCreator
 */
export interface PullreqActivityCreator {
    /**
     * 
     * @type {UserModel}
     * @memberof PullreqActivityCreator
     */
    'creator'?: UserModel | null;
    /**
     * 
     * @type {PullreqActivityModel}
     * @memberof PullreqActivityCreator
     */
    'model': PullreqActivityModel;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PullreqActivityKind = {
    System: 'system',
    Comment: 'comment',
    ChangeComment: 'change_comment'
} as const;

export type PullreqActivityKind = typeof PullreqActivityKind[keyof typeof PullreqActivityKind];


/**
 * 
 * @export
 * @interface PullreqActivityMetadata
 */
export interface PullreqActivityMetadata {
    /**
     * 
     * @type {PullreqActivitySuggestionsMetadata}
     * @memberof PullreqActivityMetadata
     */
    'suggestions'?: PullreqActivitySuggestionsMetadata | null;
}
/**
 * 
 * @export
 * @interface PullreqActivityModel
 */
export interface PullreqActivityModel {
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'code_comment_line_new'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'code_comment_line_old'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PullreqActivityModel
     */
    'code_comment_merge_base_sha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PullreqActivityModel
     */
    'code_comment_path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PullreqActivityModel
     */
    'code_comment_source_sha'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'code_comment_span_new'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'code_comment_span_old'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'deleted'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'edited': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'id': number;
    /**
     * 
     * @type {PullreqActivityKind}
     * @memberof PullreqActivityModel
     */
    'kind': PullreqActivityKind;
    /**
     * 
     * @type {PullreqActivityMetadata}
     * @memberof PullreqActivityModel
     */
    'metadata'?: PullreqActivityMetadata | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'order': number;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqActivityModel
     */
    'outdated'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'parent_id'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof PullreqActivityModel
     */
    'payload': any;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'pullreq_id': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'reply_seq': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'repo_id': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'resolved'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'resolved_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'sub_order': number;
    /**
     * 
     * @type {string}
     * @memberof PullreqActivityModel
     */
    'text': string;
    /**
     * 
     * @type {PullreqActivityType}
     * @memberof PullreqActivityModel
     */
    'type': PullreqActivityType;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqActivityModel
     */
    'version': number;
}


/**
 * 
 * @export
 * @interface PullreqActivityRelations
 */
export interface PullreqActivityRelations {
    /**
     * 
     * @type {Array<PullreqActivityModel>}
     * @memberof PullreqActivityRelations
     */
    'children': Array<PullreqActivityModel>;
    /**
     * 
     * @type {UserModel}
     * @memberof PullreqActivityRelations
     */
    'creator'?: UserModel | null;
    /**
     * 
     * @type {PullreqActivityModel}
     * @memberof PullreqActivityRelations
     */
    'model': PullreqActivityModel;
    /**
     * 
     * @type {UserModel}
     * @memberof PullreqActivityRelations
     */
    'resolver'?: UserModel | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PullreqActivityStatus = {
    Active: 'active',
    Resolved: 'resolved'
} as const;

export type PullreqActivityStatus = typeof PullreqActivityStatus[keyof typeof PullreqActivityStatus];


/**
 * 
 * @export
 * @interface PullreqActivitySuggestionsMetadata
 */
export interface PullreqActivitySuggestionsMetadata {
    /**
     * 
     * @type {string}
     * @memberof PullreqActivitySuggestionsMetadata
     */
    'applied_check_sum': string;
    /**
     * 
     * @type {string}
     * @memberof PullreqActivitySuggestionsMetadata
     */
    'applied_commit_sha': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PullreqActivitySuggestionsMetadata
     */
    'check_sums': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PullreqActivityType = {
    Comment: 'comment',
    CodeComment: 'code_comment',
    TitleChange: 'title_change',
    StateChange: 'state_change',
    ReviewSubmit: 'review_submit',
    BranchUpdate: 'branch_update',
    BranchDelete: 'branch_delete',
    Merge: 'merge'
} as const;

export type PullreqActivityType = typeof PullreqActivityType[keyof typeof PullreqActivityType];


/**
 * 
 * @export
 * @interface PullreqApplySuggestionsInput
 */
export interface PullreqApplySuggestionsInput {
    /**
     * 
     * @type {boolean}
     * @memberof PullreqApplySuggestionsInput
     */
    'bypass_rules': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqApplySuggestionsInput
     */
    'dry_run_rules': boolean;
    /**
     * 
     * @type {string}
     * @memberof PullreqApplySuggestionsInput
     */
    'message': string;
    /**
     * 
     * @type {Array<PullreqSuggestionReference>}
     * @memberof PullreqApplySuggestionsInput
     */
    'suggestions': Array<PullreqSuggestionReference>;
    /**
     * 
     * @type {string}
     * @memberof PullreqApplySuggestionsInput
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PullreqApplySuggestionsOutput
 */
export interface PullreqApplySuggestionsOutput {
    /**
     * 
     * @type {string}
     * @memberof PullreqApplySuggestionsOutput
     */
    'commit_sha'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqApplySuggestionsOutput
     */
    'dry_run_rules': boolean;
    /**
     * 
     * @type {Array<RuleCheckResult>}
     * @memberof PullreqApplySuggestionsOutput
     */
    'rule_checks': Array<RuleCheckResult>;
}
/**
 * 
 * @export
 * @interface PullreqAuthor
 */
export interface PullreqAuthor {
    /**
     * 
     * @type {UserModel}
     * @memberof PullreqAuthor
     */
    'author'?: UserModel | null;
    /**
     * 
     * @type {PullreqModel}
     * @memberof PullreqAuthor
     */
    'model': PullreqModel;
}
/**
 * 
 * @export
 * @interface PullreqCheck
 */
export interface PullreqCheck {
    /**
     * 
     * @type {boolean}
     * @memberof PullreqCheck
     */
    'bypassable': boolean;
    /**
     * 
     * @type {CheckModel}
     * @memberof PullreqCheck
     */
    'model': CheckModel;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqCheck
     */
    'required': boolean;
}
/**
 * 
 * @export
 * @interface PullreqChecksOutput
 */
export interface PullreqChecksOutput {
    /**
     * 
     * @type {Array<PullreqCheck>}
     * @memberof PullreqChecksOutput
     */
    'checks': Array<PullreqCheck>;
    /**
     * 
     * @type {string}
     * @memberof PullreqChecksOutput
     */
    'commit_sha': string;
}
/**
 * 
 * @export
 * @interface PullreqCommentCreateInput
 */
export interface PullreqCommentCreateInput {
    /**
     * 
     * @type {number}
     * @memberof PullreqCommentCreateInput
     */
    'line_end': number;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqCommentCreateInput
     */
    'line_end_new': boolean;
    /**
     * 
     * @type {number}
     * @memberof PullreqCommentCreateInput
     */
    'line_start': number;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqCommentCreateInput
     */
    'line_start_new': boolean;
    /**
     * 
     * @type {number}
     * @memberof PullreqCommentCreateInput
     */
    'parent_id': number;
    /**
     * 
     * @type {string}
     * @memberof PullreqCommentCreateInput
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof PullreqCommentCreateInput
     */
    'source_commit_sha': string;
    /**
     * 
     * @type {string}
     * @memberof PullreqCommentCreateInput
     */
    'target_commit_sha': string;
    /**
     * 
     * @type {string}
     * @memberof PullreqCommentCreateInput
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface PullreqCommentStatusInput
 */
export interface PullreqCommentStatusInput {
    /**
     * 
     * @type {PullreqActivityStatus}
     * @memberof PullreqCommentStatusInput
     */
    'status': PullreqActivityStatus;
}


/**
 * 
 * @export
 * @interface PullreqCommentUpdateInput
 */
export interface PullreqCommentUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof PullreqCommentUpdateInput
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface PullreqCreateInput
 */
export interface PullreqCreateInput {
    /**
     * 
     * @type {string}
     * @memberof PullreqCreateInput
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqCreateInput
     */
    'is_draft': boolean;
    /**
     * 
     * @type {string}
     * @memberof PullreqCreateInput
     */
    'source_branch': string;
    /**
     * 
     * @type {string}
     * @memberof PullreqCreateInput
     */
    'source_repo_ref': string;
    /**
     * 
     * @type {string}
     * @memberof PullreqCreateInput
     */
    'target_branch': string;
    /**
     * 
     * @type {string}
     * @memberof PullreqCreateInput
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PullreqFileViewCreateInput
 */
export interface PullreqFileViewCreateInput {
    /**
     * 
     * @type {string}
     * @memberof PullreqFileViewCreateInput
     */
    'commit_sha': string;
    /**
     * 
     * @type {string}
     * @memberof PullreqFileViewCreateInput
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface PullreqFileViewModel
 */
export interface PullreqFileViewModel {
    /**
     * 
     * @type {number}
     * @memberof PullreqFileViewModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqFileViewModel
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqFileViewModel
     */
    'obsolete': boolean;
    /**
     * 
     * @type {string}
     * @memberof PullreqFileViewModel
     */
    'path': string;
    /**
     * 
     * @type {number}
     * @memberof PullreqFileViewModel
     */
    'pullreq_id': number;
    /**
     * 
     * @type {string}
     * @memberof PullreqFileViewModel
     */
    'sha': string;
    /**
     * 
     * @type {number}
     * @memberof PullreqFileViewModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqFileViewModel
     */
    'user_id': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PullreqMergeCheckStatus = {
    Unchecked: 'unchecked',
    Conflict: 'conflict',
    Mergeable: 'mergeable'
} as const;

export type PullreqMergeCheckStatus = typeof PullreqMergeCheckStatus[keyof typeof PullreqMergeCheckStatus];


/**
 * 
 * @export
 * @interface PullreqMergeInput
 */
export interface PullreqMergeInput {
    /**
     * 
     * @type {boolean}
     * @memberof PullreqMergeInput
     */
    'bypass_rules': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqMergeInput
     */
    'delete_source_branch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqMergeInput
     */
    'dry_run': boolean;
    /**
     * 
     * @type {string}
     * @memberof PullreqMergeInput
     */
    'message': string;
    /**
     * 
     * @type {PullreqMergeMethod}
     * @memberof PullreqMergeInput
     */
    'method'?: PullreqMergeMethod | null;
    /**
     * 
     * @type {string}
     * @memberof PullreqMergeInput
     */
    'source_sha': string;
    /**
     * 
     * @type {string}
     * @memberof PullreqMergeInput
     */
    'title': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PullreqMergeMethod = {
    Merge: 'merge',
    Squash: 'squash',
    Rebase: 'rebase'
} as const;

export type PullreqMergeMethod = typeof PullreqMergeMethod[keyof typeof PullreqMergeMethod];


/**
 * 
 * @export
 * @interface PullreqMergeOutput
 */
export interface PullreqMergeOutput {
    /**
     * 
     * @type {Array<PullreqMergeMethod>}
     * @memberof PullreqMergeOutput
     */
    'allowed_methods'?: Array<PullreqMergeMethod> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqMergeOutput
     */
    'branch_deleted'?: boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PullreqMergeOutput
     */
    'conflict_files': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqMergeOutput
     */
    'dry_run'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqMergeOutput
     */
    'minimum_required_approvals_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqMergeOutput
     */
    'minimum_required_approvals_count_latest'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqMergeOutput
     */
    'requires_code_owners_approval'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqMergeOutput
     */
    'requires_code_owners_approval_latest'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqMergeOutput
     */
    'requires_comment_resolution'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqMergeOutput
     */
    'requires_no_change_requests'?: boolean | null;
    /**
     * 
     * @type {Array<RuleCheckResult>}
     * @memberof PullreqMergeOutput
     */
    'rule_checks': Array<RuleCheckResult>;
    /**
     * 
     * @type {string}
     * @memberof PullreqMergeOutput
     */
    'sha'?: string | null;
}
/**
 * 
 * @export
 * @interface PullreqModel
 */
export interface PullreqModel {
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'activity_seq'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'closed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'comment_count': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'commit_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof PullreqModel
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'edited': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'file_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof PullreqModel
     */
    'is_draft': boolean;
    /**
     * 
     * @type {string}
     * @memberof PullreqModel
     */
    'merge_base_sha': string;
    /**
     * 
     * @type {PullreqMergeCheckStatus}
     * @memberof PullreqModel
     */
    'merge_check_status': PullreqMergeCheckStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof PullreqModel
     */
    'merge_conflicts'?: Array<string>;
    /**
     * 
     * @type {PullreqMergeMethod}
     * @memberof PullreqModel
     */
    'merge_method'?: PullreqMergeMethod | null;
    /**
     * 
     * @type {string}
     * @memberof PullreqModel
     */
    'merge_sha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PullreqModel
     */
    'merge_target_sha'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'merged'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'merged_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'number': number;
    /**
     * 
     * @type {string}
     * @memberof PullreqModel
     */
    'source_branch': string;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'source_repo_id': number;
    /**
     * 
     * @type {string}
     * @memberof PullreqModel
     */
    'source_sha': string;
    /**
     * 
     * @type {PullreqState}
     * @memberof PullreqModel
     */
    'state': PullreqState;
    /**
     * 
     * @type {string}
     * @memberof PullreqModel
     */
    'target_branch': string;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'target_repo_id': number;
    /**
     * 
     * @type {string}
     * @memberof PullreqModel
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'unresolved_count': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqModel
     */
    'version': number;
}


/**
 * 
 * @export
 * @interface PullreqReviewCreator
 */
export interface PullreqReviewCreator {
    /**
     * 
     * @type {UserModel}
     * @memberof PullreqReviewCreator
     */
    'creator'?: UserModel | null;
    /**
     * 
     * @type {PullreqReviewModel}
     * @memberof PullreqReviewCreator
     */
    'model': PullreqReviewModel;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PullreqReviewDecision = {
    Pending: 'pending',
    Reviewed: 'reviewed',
    Approved: 'approved',
    Changereq: 'changereq'
} as const;

export type PullreqReviewDecision = typeof PullreqReviewDecision[keyof typeof PullreqReviewDecision];


/**
 * 
 * @export
 * @interface PullreqReviewModel
 */
export interface PullreqReviewModel {
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewModel
     */
    'created_by': number;
    /**
     * 
     * @type {PullreqReviewDecision}
     * @memberof PullreqReviewModel
     */
    'decision': PullreqReviewDecision;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewModel
     */
    'pullreq_id': number;
    /**
     * 
     * @type {string}
     * @memberof PullreqReviewModel
     */
    'sha': string;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewModel
     */
    'updated': number;
}


/**
 * 
 * @export
 * @interface PullreqReviewSubmitInput
 */
export interface PullreqReviewSubmitInput {
    /**
     * 
     * @type {string}
     * @memberof PullreqReviewSubmitInput
     */
    'commit_sha': string;
    /**
     * 
     * @type {PullreqReviewDecision}
     * @memberof PullreqReviewSubmitInput
     */
    'decision': PullreqReviewDecision;
}


/**
 * 
 * @export
 * @interface PullreqReviewerAddInput
 */
export interface PullreqReviewerAddInput {
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewerAddInput
     */
    'reviewer_id': number;
}
/**
 * 
 * @export
 * @interface PullreqReviewerModel
 */
export interface PullreqReviewerModel {
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewerModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewerModel
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewerModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewerModel
     */
    'latest_review_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewerModel
     */
    'pullreq_id': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewerModel
     */
    'repo_id': number;
    /**
     * 
     * @type {PullreqReviewDecision}
     * @memberof PullreqReviewerModel
     */
    'review_decision': PullreqReviewDecision;
    /**
     * 
     * @type {string}
     * @memberof PullreqReviewerModel
     */
    'sha': string;
    /**
     * 
     * @type {PullreqReviewerType}
     * @memberof PullreqReviewerModel
     */
    'type': PullreqReviewerType;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewerModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof PullreqReviewerModel
     */
    'user_id': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PullreqReviewerType = {
    SelfAssigned: 'self_assigned',
    Requested: 'requested',
    Assigned: 'assigned'
} as const;

export type PullreqReviewerType = typeof PullreqReviewerType[keyof typeof PullreqReviewerType];


/**
 * 
 * @export
 * @interface PullreqReviewerUser
 */
export interface PullreqReviewerUser {
    /**
     * 
     * @type {PullreqReviewerModel}
     * @memberof PullreqReviewerUser
     */
    'model': PullreqReviewerModel;
    /**
     * 
     * @type {UserModel}
     * @memberof PullreqReviewerUser
     */
    'user'?: UserModel | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PullreqSort = {
    Noop: 'noop',
    Number: 'number',
    Created: 'created',
    Edited: 'edited',
    Merged: 'merged',
    Updated: 'updated'
} as const;

export type PullreqSort = typeof PullreqSort[keyof typeof PullreqSort];


/**
 * 
 * @export
 * @enum {string}
 */

export const PullreqState = {
    Open: 'open',
    Merged: 'merged',
    Closed: 'closed'
} as const;

export type PullreqState = typeof PullreqState[keyof typeof PullreqState];


/**
 * 
 * @export
 * @interface PullreqStateUpdateInput
 */
export interface PullreqStateUpdateInput {
    /**
     * 
     * @type {boolean}
     * @memberof PullreqStateUpdateInput
     */
    'is_draft': boolean;
    /**
     * 
     * @type {PullreqState}
     * @memberof PullreqStateUpdateInput
     */
    'state': PullreqState;
}


/**
 * 
 * @export
 * @interface PullreqSuggestionReference
 */
export interface PullreqSuggestionReference {
    /**
     * 
     * @type {string}
     * @memberof PullreqSuggestionReference
     */
    'check_sum': string;
    /**
     * 
     * @type {number}
     * @memberof PullreqSuggestionReference
     */
    'comment_id': number;
}
/**
 * 
 * @export
 * @interface PullreqUpdateInput
 */
export interface PullreqUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof PullreqUpdateInput
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PullreqUpdateInput
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PullreqWithDiffStats
 */
export interface PullreqWithDiffStats {
    /**
     * 
     * @type {UserModel}
     * @memberof PullreqWithDiffStats
     */
    'author'?: UserModel | null;
    /**
     * 
     * @type {DiffStats}
     * @memberof PullreqWithDiffStats
     */
    'diff_stats': DiffStats;
    /**
     * 
     * @type {UserModel}
     * @memberof PullreqWithDiffStats
     */
    'merger'?: UserModel | null;
    /**
     * 
     * @type {PullreqModel}
     * @memberof PullreqWithDiffStats
     */
    'model': PullreqModel;
}
/**
 * 
 * @export
 * @interface QueryOption
 */
export interface QueryOption {
    /**
     * 
     * @type {number}
     * @memberof QueryOption
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryOption
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryOption
     */
    'query'?: string;
}
/**
 * 
 * @export
 * @interface RegisterInput
 */
export interface RegisterInput {
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface RegisterTokenModel
 */
export interface RegisterTokenModel {
    /**
     * 
     * @type {number}
     * @memberof RegisterTokenModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof RegisterTokenModel
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof RegisterTokenModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof RegisterTokenModel
     */
    'parent_id'?: number | null;
    /**
     * 
     * @type {Scope}
     * @memberof RegisterTokenModel
     */
    'scope': Scope;
    /**
     * 
     * @type {string}
     * @memberof RegisterTokenModel
     */
    'token': string;
    /**
     * 
     * @type {number}
     * @memberof RegisterTokenModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof RegisterTokenModel
     */
    'version': number;
}


/**
 * 
 * @export
 * @interface ReleaseCreateInput
 */
export interface ReleaseCreateInput {
    /**
     * 
     * @type {boolean}
     * @memberof ReleaseCreateInput
     */
    'bypass_rules': boolean;
    /**
     * 
     * @type {string}
     * @memberof ReleaseCreateInput
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ReleaseCreateInput
     */
    'is_draft': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReleaseCreateInput
     */
    'is_prerelease': boolean;
    /**
     * 
     * @type {string}
     * @memberof ReleaseCreateInput
     */
    'tag_name': string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseCreateInput
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseCreateInput
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ReleaseCreator
 */
export interface ReleaseCreator {
    /**
     * 
     * @type {UserModel}
     * @memberof ReleaseCreator
     */
    'creator'?: UserModel | null;
    /**
     * 
     * @type {ReleaseModel}
     * @memberof ReleaseCreator
     */
    'model': ReleaseModel;
}
/**
 * 
 * @export
 * @interface ReleaseModel
 */
export interface ReleaseModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof ReleaseModel
     */
    'assets'?: Array<string>;
    /**
     * 
     * @type {Array<Contributor>}
     * @memberof ReleaseModel
     */
    'contributors'?: Array<Contributor>;
    /**
     * 
     * @type {number}
     * @memberof ReleaseModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseModel
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseModel
     */
    'deleted'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ReleaseModel
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof ReleaseModel
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof ReleaseModel
     */
    'is_draft': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReleaseModel
     */
    'is_latest'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ReleaseModel
     */
    'is_prerelease': boolean;
    /**
     * 
     * @type {number}
     * @memberof ReleaseModel
     */
    'num_commits': number;
    /**
     * 
     * @type {string}
     * @memberof ReleaseModel
     */
    'origin_author'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ReleaseModel
     */
    'origin_author_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ReleaseModel
     */
    'repo_id': number;
    /**
     * 
     * @type {string}
     * @memberof ReleaseModel
     */
    'sha1': string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseModel
     */
    'tag_name': string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseModel
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof ReleaseModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof ReleaseModel
     */
    'version': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ReleaseSort = {
    Noop: 'noop',
    Id: 'id',
    Created: 'created',
    Updated: 'updated'
} as const;

export type ReleaseSort = typeof ReleaseSort[keyof typeof ReleaseSort];


/**
 * 
 * @export
 * @interface RepoCommitDivergencesInput
 */
export interface RepoCommitDivergencesInput {
    /**
     * 
     * @type {number}
     * @memberof RepoCommitDivergencesInput
     */
    'max_count': number;
    /**
     * 
     * @type {Array<CommitDivergenceRequest>}
     * @memberof RepoCommitDivergencesInput
     */
    'requests': Array<CommitDivergenceRequest>;
}
/**
 * 
 * @export
 * @interface RepoCommitFileAction
 */
export interface RepoCommitFileAction {
    /**
     * 
     * @type {CommitFileActionType}
     * @memberof RepoCommitFileAction
     */
    'action': CommitFileActionType;
    /**
     * 
     * @type {RepoFileContentEncodingType}
     * @memberof RepoCommitFileAction
     */
    'encoding'?: RepoFileContentEncodingType;
    /**
     * 
     * @type {string}
     * @memberof RepoCommitFileAction
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof RepoCommitFileAction
     */
    'payload': string;
    /**
     * 
     * @type {string}
     * @memberof RepoCommitFileAction
     */
    'sha': string;
}


/**
 * 
 * @export
 * @interface RepoContent
 */
export interface RepoContent {
    /**
     * 
     * @type {RepoDirContent}
     * @memberof RepoContent
     */
    'dir'?: RepoDirContent | null;
    /**
     * 
     * @type {RepoFileContent}
     * @memberof RepoContent
     */
    'file'?: RepoFileContent | null;
    /**
     * 
     * @type {RepoSubmoduleContent}
     * @memberof RepoContent
     */
    'submodule'?: RepoSubmoduleContent | null;
    /**
     * 
     * @type {RepoSymlinkContent}
     * @memberof RepoContent
     */
    'symlink'?: RepoSymlinkContent | null;
}
/**
 * 
 * @export
 * @interface RepoContentInfo
 */
export interface RepoContentInfo {
    /**
     * 
     * @type {string}
     * @memberof RepoContentInfo
     */
    'commit_url'?: string | null;
    /**
     * 
     * @type {Commit}
     * @memberof RepoContentInfo
     */
    'latest_commit'?: Commit | null;
    /**
     * 
     * @type {string}
     * @memberof RepoContentInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RepoContentInfo
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof RepoContentInfo
     */
    'repo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RepoContentInfo
     */
    'sha': string;
    /**
     * 
     * @type {RepoContentType}
     * @memberof RepoContentInfo
     */
    'type': RepoContentType;
}


/**
 * 
 * @export
 * @interface RepoContentOutput
 */
export interface RepoContentOutput {
    /**
     * 
     * @type {string}
     * @memberof RepoContentOutput
     */
    'commit_url'?: string;
    /**
     * 
     * @type {Commit}
     * @memberof RepoContentOutput
     */
    'latest_commit'?: Commit;
    /**
     * 
     * @type {string}
     * @memberof RepoContentOutput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RepoContentOutput
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof RepoContentOutput
     */
    'repo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoContentOutput
     */
    'sha': string;
    /**
     * 
     * @type {RepoContentType}
     * @memberof RepoContentOutput
     */
    'type': RepoContentType;
    /**
     * 
     * @type {RepoContent}
     * @memberof RepoContentOutput
     */
    'content': RepoContent;
    /**
     * 
     * @type {number}
     * @memberof RepoContentOutput
     */
    'total_commits': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RepoContentType = {
    File: 'file',
    Dir: 'dir',
    Symlink: 'symlink',
    Submodule: 'submodule'
} as const;

export type RepoContentType = typeof RepoContentType[keyof typeof RepoContentType];


/**
 * 
 * @export
 * @interface RepoCreateInput
 */
export interface RepoCreateInput {
    /**
     * 
     * @type {string}
     * @memberof RepoCreateInput
     */
    'default_branch'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepoCreateInput
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof RepoCreateInput
     */
    'fork_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RepoCreateInput
     */
    'git_ignore': string;
    /**
     * 
     * @type {string}
     * @memberof RepoCreateInput
     */
    'identifier': string;
    /**
     * 
     * @type {boolean}
     * @memberof RepoCreateInput
     */
    'is_public': boolean;
    /**
     * 
     * @type {string}
     * @memberof RepoCreateInput
     */
    'license': string;
    /**
     * 
     * @type {string}
     * @memberof RepoCreateInput
     */
    'parent_ref': string;
    /**
     * 
     * @type {boolean}
     * @memberof RepoCreateInput
     */
    'readme': boolean;
    /**
     * 
     * @type {string}
     * @memberof RepoCreateInput
     */
    'single_branch': string;
}
/**
 * 
 * @export
 * @interface RepoDirContent
 */
export interface RepoDirContent {
    /**
     * 
     * @type {Array<RepoContentInfo>}
     * @memberof RepoDirContent
     */
    'entries': Array<RepoContentInfo>;
}
/**
 * 
 * @export
 * @interface RepoFileContent
 */
export interface RepoFileContent {
    /**
     * 
     * @type {string}
     * @memberof RepoFileContent
     */
    'data': string;
    /**
     * 
     * @type {RepoFileContentEncodingType}
     * @memberof RepoFileContent
     */
    'encoding': RepoFileContentEncodingType;
    /**
     * 
     * @type {number}
     * @memberof RepoFileContent
     */
    'size': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RepoFileContentEncodingType = {
    Utf8: 'utf8',
    Base64: 'base64'
} as const;

export type RepoFileContentEncodingType = typeof RepoFileContentEncodingType[keyof typeof RepoFileContentEncodingType];


/**
 * 
 * @export
 * @interface RepoImportInput
 */
export interface RepoImportInput {
    /**
     * 
     * @type {string}
     * @memberof RepoImportInput
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RepoImportInput
     */
    'identifier': string;
    /**
     * 
     * @type {boolean}
     * @memberof RepoImportInput
     */
    'is_public': boolean;
    /**
     * 
     * @type {string}
     * @memberof RepoImportInput
     */
    'parent_ref': string;
    /**
     * 
     * @type {RepoProvider}
     * @memberof RepoImportInput
     */
    'provider': RepoProvider;
    /**
     * 
     * @type {string}
     * @memberof RepoImportInput
     */
    'provider_repo': string;
}
/**
 * 
 * @export
 * @interface RepoMergeCheckInput
 */
export interface RepoMergeCheckInput {
    /**
     * 
     * @type {string}
     * @memberof RepoMergeCheckInput
     */
    'head_repo_ref'?: string;
}
/**
 * 
 * @export
 * @interface RepoMergeCheckOutput
 */
export interface RepoMergeCheckOutput {
    /**
     * 
     * @type {Array<string>}
     * @memberof RepoMergeCheckOutput
     */
    'conflict_files': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RepoMergeCheckOutput
     */
    'mergeable': boolean;
}
/**
 * 
 * @export
 * @interface RepoMoveInput
 */
export interface RepoMoveInput {
    /**
     * 
     * @type {string}
     * @memberof RepoMoveInput
     */
    'identifier'?: string | null;
}
/**
 * 
 * @export
 * @interface RepoParent
 */
export interface RepoParent {
    /**
     * 
     * @type {RepositoryModel}
     * @memberof RepoParent
     */
    'model': RepositoryModel;
    /**
     * 
     * @type {RepositoryModel}
     * @memberof RepoParent
     */
    'parent'?: RepositoryModel | null;
}
/**
 * 
 * @export
 * @interface RepoPathsOutput
 */
export interface RepoPathsOutput {
    /**
     * 
     * @type {Array<string>}
     * @memberof RepoPathsOutput
     */
    'dirs': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RepoPathsOutput
     */
    'files': Array<string>;
}
/**
 * 
 * @export
 * @interface RepoProvider
 */
export interface RepoProvider {
    /**
     * 
     * @type {string}
     * @memberof RepoProvider
     */
    'origin'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RepoProvider
     */
    'password'?: string | null;
    /**
     * 
     * @type {RepoProviderType}
     * @memberof RepoProvider
     */
    'type': RepoProviderType;
    /**
     * 
     * @type {string}
     * @memberof RepoProvider
     */
    'username'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RepoProviderType = {
    Github: 'github',
    Gitlab: 'gitlab'
} as const;

export type RepoProviderType = typeof RepoProviderType[keyof typeof RepoProviderType];


/**
 * 
 * @export
 * @interface RepoRestoreInput
 */
export interface RepoRestoreInput {
    /**
     * 
     * @type {string}
     * @memberof RepoRestoreInput
     */
    'new_identifier'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RepoRestoreInput
     */
    'new_parent_ref'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RepoSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Created: 'created',
    Updated: 'updated'
} as const;

export type RepoSort = typeof RepoSort[keyof typeof RepoSort];


/**
 * 
 * @export
 * @interface RepoStarsInput
 */
export interface RepoStarsInput {
    /**
     * 
     * @type {boolean}
     * @memberof RepoStarsInput
     */
    'star': boolean;
}
/**
 * 
 * @export
 * @interface RepoStatsOutput
 */
export interface RepoStatsOutput {
    /**
     * 
     * @type {number}
     * @memberof RepoStatsOutput
     */
    'branch_total_num': number;
    /**
     * 
     * @type {number}
     * @memberof RepoStatsOutput
     */
    'pullreq_total_num': number;
    /**
     * 
     * @type {number}
     * @memberof RepoStatsOutput
     */
    'release_total_num': number;
    /**
     * 
     * @type {number}
     * @memberof RepoStatsOutput
     */
    'tag_total_num': number;
}
/**
 * 
 * @export
 * @interface RepoSubmoduleContent
 */
export interface RepoSubmoduleContent {
    /**
     * 
     * @type {string}
     * @memberof RepoSubmoduleContent
     */
    'commit_sha': string;
    /**
     * 
     * @type {string}
     * @memberof RepoSubmoduleContent
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RepoSymlinkContent
 */
export interface RepoSymlinkContent {
    /**
     * 
     * @type {number}
     * @memberof RepoSymlinkContent
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof RepoSymlinkContent
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface RepoUpdateDefaultBranchInput
 */
export interface RepoUpdateDefaultBranchInput {
    /**
     * 
     * @type {string}
     * @memberof RepoUpdateDefaultBranchInput
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface RepoUpdateInput
 */
export interface RepoUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof RepoUpdateInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RepoUpdateInput
     */
    'is_public'?: boolean | null;
}
/**
 * 
 * @export
 * @interface RepositoryModel
 */
export interface RepositoryModel {
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof RepositoryModel
     */
    'default_branch': string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'deleted'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RepositoryModel
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryModel
     */
    'display_name': string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'fork_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RepositoryModel
     */
    'git_ssh_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RepositoryModel
     */
    'git_uid': string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryModel
     */
    'git_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'group_id': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof RepositoryModel
     */
    'importing': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RepositoryModel
     */
    'is_empty': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RepositoryModel
     */
    'is_public': boolean;
    /**
     * 
     * @type {string}
     * @memberof RepositoryModel
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'num_closed_pulls': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'num_forks': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'num_merged_pulls': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'num_open_pulls': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'num_pulls': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'num_stars': number;
    /**
     * 
     * @type {string}
     * @memberof RepositoryModel
     */
    'path'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'pullreq_seq': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'size_updated'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryModel
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface RepositoryStarModel
 */
export interface RepositoryStarModel {
    /**
     * 
     * @type {number}
     * @memberof RepositoryStarModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryStarModel
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryStarModel
     */
    'group_id': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryStarModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryStarModel
     */
    'repo_id': number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryStarModel
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface RuleCheckOutput
 */
export interface RuleCheckOutput {
    /**
     * 
     * @type {Array<RuleCheckResult>}
     * @memberof RuleCheckOutput
     */
    'rule_checks': Array<RuleCheckResult>;
}
/**
 * 
 * @export
 * @interface RuleCheckResult
 */
export interface RuleCheckResult {
    /**
     * 
     * @type {boolean}
     * @memberof RuleCheckResult
     */
    'bypassable': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RuleCheckResult
     */
    'bypassed': boolean;
    /**
     * 
     * @type {RuleMetadata}
     * @memberof RuleCheckResult
     */
    'rule': RuleMetadata;
    /**
     * 
     * @type {Array<RuleViolation>}
     * @memberof RuleCheckResult
     */
    'violations': Array<RuleViolation>;
}
/**
 * 
 * @export
 * @interface RuleCreateInput
 */
export interface RuleCreateInput {
    /**
     * 
     * @type {ProtectionDefinition}
     * @memberof RuleCreateInput
     */
    'definition'?: ProtectionDefinition | null;
    /**
     * 
     * @type {string}
     * @memberof RuleCreateInput
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof RuleCreateInput
     */
    'name': string;
    /**
     * 
     * @type {ProtectionPattern}
     * @memberof RuleCreateInput
     */
    'pattern': ProtectionPattern;
    /**
     * 
     * @type {RuleState}
     * @memberof RuleCreateInput
     */
    'state': RuleState;
    /**
     * 
     * @type {RuleType}
     * @memberof RuleCreateInput
     */
    'type': RuleType;
}


/**
 * 
 * @export
 * @interface RuleMetadata
 */
export interface RuleMetadata {
    /**
     * 
     * @type {string}
     * @memberof RuleMetadata
     */
    'group_path': string;
    /**
     * 
     * @type {string}
     * @memberof RuleMetadata
     */
    'repo_path': string;
    /**
     * 
     * @type {any}
     * @memberof RuleMetadata
     */
    'rule_definition': any;
    /**
     * 
     * @type {number}
     * @memberof RuleMetadata
     */
    'rule_id': number;
    /**
     * 
     * @type {string}
     * @memberof RuleMetadata
     */
    'rule_name': string;
    /**
     * 
     * @type {any}
     * @memberof RuleMetadata
     */
    'rule_pattern': any;
    /**
     * 
     * @type {RuleState}
     * @memberof RuleMetadata
     */
    'rule_state': RuleState;
    /**
     * 
     * @type {RuleType}
     * @memberof RuleMetadata
     */
    'rule_type': RuleType;
}


/**
 * 
 * @export
 * @interface RuleModel
 */
export interface RuleModel {
    /**
     * 
     * @type {number}
     * @memberof RuleModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof RuleModel
     */
    'created_by': number;
    /**
     * 
     * @type {any}
     * @memberof RuleModel
     */
    'definition': any;
    /**
     * 
     * @type {string}
     * @memberof RuleModel
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof RuleModel
     */
    'group_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RuleModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RuleModel
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof RuleModel
     */
    'pattern': any;
    /**
     * 
     * @type {number}
     * @memberof RuleModel
     */
    'repo_id'?: number | null;
    /**
     * 
     * @type {RuleState}
     * @memberof RuleModel
     */
    'state': RuleState;
    /**
     * 
     * @type {RuleType}
     * @memberof RuleModel
     */
    'type': RuleType;
    /**
     * 
     * @type {number}
     * @memberof RuleModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof RuleModel
     */
    'version': number;
}


/**
 * 
 * @export
 * @interface RulePatchInput
 */
export interface RulePatchInput {
    /**
     * 
     * @type {ProtectionDefinition}
     * @memberof RulePatchInput
     */
    'definition'?: ProtectionDefinition | null;
    /**
     * 
     * @type {string}
     * @memberof RulePatchInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RulePatchInput
     */
    'name'?: string | null;
    /**
     * 
     * @type {ProtectionPattern}
     * @memberof RulePatchInput
     */
    'pattern'?: ProtectionPattern | null;
    /**
     * 
     * @type {RuleState}
     * @memberof RulePatchInput
     */
    'state'?: RuleState | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RuleSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Created: 'created',
    Updated: 'updated'
} as const;

export type RuleSort = typeof RuleSort[keyof typeof RuleSort];


/**
 * 
 * @export
 * @enum {string}
 */

export const RuleState = {
    Disabled: 'disabled',
    Active: 'active',
    Monitor: 'monitor'
} as const;

export type RuleState = typeof RuleState[keyof typeof RuleState];


/**
 * 
 * @export
 * @enum {string}
 */

export const RuleType = {
    Branch: 'branch'
} as const;

export type RuleType = typeof RuleType[keyof typeof RuleType];


/**
 * 
 * @export
 * @interface RuleViolation
 */
export interface RuleViolation {
    /**
     * 
     * @type {string}
     * @memberof RuleViolation
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof RuleViolation
     */
    'message': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof RuleViolation
     */
    'params': Array<any>;
}
/**
 * 
 * @export
 * @interface RunnerCreator
 */
export interface RunnerCreator {
    /**
     * 
     * @type {UserModel}
     * @memberof RunnerCreator
     */
    'creator'?: UserModel | null;
    /**
     * 
     * @type {RunnerModel}
     * @memberof RunnerCreator
     */
    'model': RunnerModel;
}
/**
 * 
 * @export
 * @interface RunnerModel
 */
export interface RunnerModel {
    /**
     * 
     * @type {number}
     * @memberof RunnerModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof RunnerModel
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof RunnerModel
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof RunnerModel
     */
    'id': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RunnerModel
     */
    'labels': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RunnerModel
     */
    'last_online': number;
    /**
     * 
     * @type {string}
     * @memberof RunnerModel
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof RunnerModel
     */
    'parent_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RunnerModel
     */
    'release': string;
    /**
     * 
     * @type {Scope}
     * @memberof RunnerModel
     */
    'scope': Scope;
    /**
     * 
     * @type {RunnerStatus}
     * @memberof RunnerModel
     */
    'status': RunnerStatus;
    /**
     * 
     * @type {number}
     * @memberof RunnerModel
     */
    'token_id': number;
    /**
     * 
     * @type {number}
     * @memberof RunnerModel
     */
    'updated': number;
    /**
     * 
     * @type {string}
     * @memberof RunnerModel
     */
    'uuid': string;
    /**
     * 
     * @type {number}
     * @memberof RunnerModel
     */
    'version': number;
}


/**
 * 
 * @export
 * @interface RunnerPatchInput
 */
export interface RunnerPatchInput {
    /**
     * 
     * @type {string}
     * @memberof RunnerPatchInput
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface RunnerPostInput
 */
export interface RunnerPostInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof RunnerPostInput
     */
    'labels': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RunnerPostInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RunnerPostInput
     */
    'release': string;
    /**
     * 
     * @type {string}
     * @memberof RunnerPostInput
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RunnerStageOutput
 */
export interface RunnerStageOutput {
    /**
     * 
     * @type {string}
     * @memberof RunnerStageOutput
     */
    'access_token': string;
    /**
     * 
     * @type {StageModel}
     * @memberof RunnerStageOutput
     */
    'stage'?: StageModel | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RunnerStatus = {
    Offline: 'offline',
    Online: 'online'
} as const;

export type RunnerStatus = typeof RunnerStatus[keyof typeof RunnerStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const Scope = {
    System: 'system',
    Group: 'group',
    Repository: 'repository'
} as const;

export type Scope = typeof Scope[keyof typeof Scope];


/**
 * 
 * @export
 * @interface SecuritySettings
 */
export interface SecuritySettings {
    /**
     * 
     * @type {boolean}
     * @memberof SecuritySettings
     */
    'secret_scanning_enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ServiceAccountCreateInput
 */
export interface ServiceAccountCreateInput {
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountCreateInput
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountCreateInput
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof ServiceAccountCreateInput
     */
    'parent_id': number;
    /**
     * 
     * @type {ParentResourceType}
     * @memberof ServiceAccountCreateInput
     */
    'parent_type': ParentResourceType;
}


/**
 * 
 * @export
 * @interface ServiceAccountTokenOutput
 */
export interface ServiceAccountTokenOutput {
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountTokenOutput
     */
    'access_token': string;
    /**
     * 
     * @type {number}
     * @memberof ServiceAccountTokenOutput
     */
    'expires_at'?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SseType = {
    Noop: 'noop',
    WorkflowUpdated: 'workflow_updated',
    WorkflowRunning: 'workflow_running',
    WorkflowCompleted: 'workflow_completed',
    WorkflowCanceled: 'workflow_canceled',
    RepositoryImportCompleted: 'repository_import_completed',
    PullreqUpdated: 'pullreq_updated'
} as const;

export type SseType = typeof SseType[keyof typeof SseType];


/**
 * 
 * @export
 * @interface StageCreateInput
 */
export interface StageCreateInput {
    /**
     * 
     * @type {string}
     * @memberof StageCreateInput
     */
    'arch': string;
    /**
     * 
     * @type {boolean}
     * @memberof StageCreateInput
     */
    'errignore': boolean;
    /**
     * 
     * @type {string}
     * @memberof StageCreateInput
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof StageCreateInput
     */
    'exit_code': number;
    /**
     * 
     * @type {string}
     * @memberof StageCreateInput
     */
    'kernel': string;
    /**
     * 
     * @type {string}
     * @memberof StageCreateInput
     */
    'kind': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StageCreateInput
     */
    'labels': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StageCreateInput
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof StageCreateInput
     */
    'limit_repo': number;
    /**
     * 
     * @type {string}
     * @memberof StageCreateInput
     */
    'machine': string;
    /**
     * 
     * @type {string}
     * @memberof StageCreateInput
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof StageCreateInput
     */
    'needs': any;
    /**
     * 
     * @type {number}
     * @memberof StageCreateInput
     */
    'number': number;
    /**
     * 
     * @type {boolean}
     * @memberof StageCreateInput
     */
    'on_failure': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StageCreateInput
     */
    'on_success': boolean;
    /**
     * 
     * @type {string}
     * @memberof StageCreateInput
     */
    'os': string;
    /**
     * 
     * @type {number}
     * @memberof StageCreateInput
     */
    'parent_group_id': number;
    /**
     * 
     * @type {number}
     * @memberof StageCreateInput
     */
    'started'?: number | null;
    /**
     * 
     * @type {CIStatus}
     * @memberof StageCreateInput
     */
    'status': CIStatus;
    /**
     * 
     * @type {number}
     * @memberof StageCreateInput
     */
    'stopped'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof StageCreateInput
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof StageCreateInput
     */
    'variant': string;
    /**
     * 
     * @type {YamlProvider}
     * @memberof StageCreateInput
     */
    'yaml_provider': YamlProvider;
    /**
     * 
     * @type {string}
     * @memberof StageCreateInput
     */
    'yaml_resolved': string;
}


/**
 * 
 * @export
 * @interface StageModel
 */
export interface StageModel {
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'action_id': number;
    /**
     * 
     * @type {string}
     * @memberof StageModel
     */
    'arch': string;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'created': number;
    /**
     * 
     * @type {boolean}
     * @memberof StageModel
     */
    'errignore': boolean;
    /**
     * 
     * @type {string}
     * @memberof StageModel
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'exit_code': number;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StageModel
     */
    'kernel': string;
    /**
     * 
     * @type {string}
     * @memberof StageModel
     */
    'kind': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StageModel
     */
    'labels': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'limit_repo': number;
    /**
     * 
     * @type {string}
     * @memberof StageModel
     */
    'machine': string;
    /**
     * 
     * @type {string}
     * @memberof StageModel
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof StageModel
     */
    'needs': any;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'number': number;
    /**
     * 
     * @type {boolean}
     * @memberof StageModel
     */
    'on_failure': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StageModel
     */
    'on_success': boolean;
    /**
     * 
     * @type {string}
     * @memberof StageModel
     */
    'os': string;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'parent_group_id': number;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'parent_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'repo_id': number;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'started'?: number | null;
    /**
     * 
     * @type {CIStatus}
     * @memberof StageModel
     */
    'status': CIStatus;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'stopped'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof StageModel
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'updated': number;
    /**
     * 
     * @type {string}
     * @memberof StageModel
     */
    'variant': string;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'version': number;
    /**
     * 
     * @type {number}
     * @memberof StageModel
     */
    'workflow_id': number;
    /**
     * 
     * @type {YamlProvider}
     * @memberof StageModel
     */
    'yaml_provider': YamlProvider;
    /**
     * 
     * @type {string}
     * @memberof StageModel
     */
    'yaml_resolved': string;
}


/**
 * 
 * @export
 * @interface StageSteps
 */
export interface StageSteps {
    /**
     * 
     * @type {StageModel}
     * @memberof StageSteps
     */
    'model': StageModel;
    /**
     * 
     * @type {Array<StepModel>}
     * @memberof StageSteps
     */
    'steps': Array<StepModel>;
}
/**
 * 
 * @export
 * @interface StageUpdateInput
 */
export interface StageUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof StageUpdateInput
     */
    'error'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StageUpdateInput
     */
    'exit_code'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StageUpdateInput
     */
    'started'?: number | null;
    /**
     * 
     * @type {CIStatus}
     * @memberof StageUpdateInput
     */
    'status'?: CIStatus | null;
    /**
     * 
     * @type {number}
     * @memberof StageUpdateInput
     */
    'stopped'?: number | null;
}


/**
 * 
 * @export
 * @interface StepCreateInput
 */
export interface StepCreateInput {
    /**
     * 
     * @type {any}
     * @memberof StepCreateInput
     */
    'depends_on': any;
    /**
     * 
     * @type {boolean}
     * @memberof StepCreateInput
     */
    'detached': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StepCreateInput
     */
    'errignore': boolean;
    /**
     * 
     * @type {string}
     * @memberof StepCreateInput
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof StepCreateInput
     */
    'exit_code': number;
    /**
     * 
     * @type {string}
     * @memberof StepCreateInput
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof StepCreateInput
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof StepCreateInput
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof StepCreateInput
     */
    'parent_group_id': number;
    /**
     * 
     * @type {CIStatus}
     * @memberof StepCreateInput
     */
    'status': CIStatus;
    /**
     * 
     * @type {YamlProvider}
     * @memberof StepCreateInput
     */
    'yaml_provider': YamlProvider;
    /**
     * 
     * @type {string}
     * @memberof StepCreateInput
     */
    'yaml_resolved': string;
}


/**
 * 
 * @export
 * @interface StepModel
 */
export interface StepModel {
    /**
     * 
     * @type {any}
     * @memberof StepModel
     */
    'depends_on': any;
    /**
     * 
     * @type {boolean}
     * @memberof StepModel
     */
    'detached': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StepModel
     */
    'errignore': boolean;
    /**
     * 
     * @type {string}
     * @memberof StepModel
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof StepModel
     */
    'exit_code': number;
    /**
     * 
     * @type {number}
     * @memberof StepModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StepModel
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof StepModel
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof StepModel
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof StepModel
     */
    'parent_group_id': number;
    /**
     * 
     * @type {number}
     * @memberof StepModel
     */
    'stage_id': number;
    /**
     * 
     * @type {number}
     * @memberof StepModel
     */
    'started'?: number | null;
    /**
     * 
     * @type {CIStatus}
     * @memberof StepModel
     */
    'status': CIStatus;
    /**
     * 
     * @type {number}
     * @memberof StepModel
     */
    'stopped'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StepModel
     */
    'version': number;
    /**
     * 
     * @type {YamlProvider}
     * @memberof StepModel
     */
    'yaml_provider': YamlProvider;
    /**
     * 
     * @type {string}
     * @memberof StepModel
     */
    'yaml_resolved': string;
}


/**
 * 
 * @export
 * @interface StepUpdateInput
 */
export interface StepUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof StepUpdateInput
     */
    'error'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StepUpdateInput
     */
    'exit_code'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof StepUpdateInput
     */
    'started'?: number | null;
    /**
     * 
     * @type {CIStatus}
     * @memberof StepUpdateInput
     */
    'status'?: CIStatus | null;
    /**
     * 
     * @type {number}
     * @memberof StepUpdateInput
     */
    'stopped'?: number | null;
}


/**
 * 
 * @export
 * @interface SystemConfig
 */
export interface SystemConfig {
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfig
     */
    'nested_groups_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfig
     */
    'public_resource_creation_enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemConfig
     */
    'user_signup_allowed': boolean;
}
/**
 * 
 * @export
 * @interface TagCreateInput
 */
export interface TagCreateInput {
    /**
     * 
     * @type {boolean}
     * @memberof TagCreateInput
     */
    'bypass_rules': boolean;
    /**
     * 
     * @type {string}
     * @memberof TagCreateInput
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof TagCreateInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TagCreateInput
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface TokenCreateInput
 */
export interface TokenCreateInput {
    /**
     * 
     * @type {number}
     * @memberof TokenCreateInput
     */
    'lifetime_ms'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TokenCreateInput
     */
    'name': string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof TokenCreateInput
     */
    'permissions'?: Array<Permission>;
}
/**
 * 
 * @export
 * @interface TokenCreateOutput
 */
export interface TokenCreateOutput {
    /**
     * 
     * @type {string}
     * @memberof TokenCreateOutput
     */
    'access_token': string;
    /**
     * 
     * @type {number}
     * @memberof TokenCreateOutput
     */
    'expires_at'?: number | null;
    /**
     * 
     * @type {TokenModel}
     * @memberof TokenCreateOutput
     */
    'model': TokenModel;
}
/**
 * 
 * @export
 * @interface TokenModel
 */
export interface TokenModel {
    /**
     * 
     * @type {number}
     * @memberof TokenModel
     */
    'created_by': number;
    /**
     * 
     * @type {number}
     * @memberof TokenModel
     */
    'expires_at'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TokenModel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof TokenModel
     */
    'issued_at': number;
    /**
     * 
     * @type {string}
     * @memberof TokenModel
     */
    'name': string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof TokenModel
     */
    'permissions'?: Array<Permission>;
    /**
     * 
     * @type {TokenType}
     * @memberof TokenModel
     */
    'type': TokenType;
    /**
     * 
     * @type {number}
     * @memberof TokenModel
     */
    'user_id': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TokenType = {
    Session: 'session',
    TwoFactor: 'two_factor',
    Pat: 'pat',
    Sat: 'sat',
    Runner: 'runner'
} as const;

export type TokenType = typeof TokenType[keyof typeof TokenType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TriggerEvent = {
    Noop: 'noop',
    BranchProtectionRule: 'branch_protection_rule',
    CheckRun: 'check_run',
    CheckSuite: 'check_suite',
    Branch: 'branch',
    Tag: 'tag',
    PullRequest: 'pull_request',
    Release: 'release',
    Repository: 'repository',
    Schedule: 'schedule',
    Status: 'status',
    WorkflowDispatch: 'workflow_dispatch',
    WorkflowRun: 'workflow_run'
} as const;

export type TriggerEvent = typeof TriggerEvent[keyof typeof TriggerEvent];


/**
 * 
 * @export
 * @interface TwoFactorCreateInput
 */
export interface TwoFactorCreateInput {
    /**
     * 
     * @type {string}
     * @memberof TwoFactorCreateInput
     */
    'passcode': string;
    /**
     * 
     * @type {string}
     * @memberof TwoFactorCreateInput
     */
    'secret': string;
}
/**
 * 
 * @export
 * @interface TwoFactorGetOutput
 */
export interface TwoFactorGetOutput {
    /**
     * 
     * @type {boolean}
     * @memberof TwoFactorGetOutput
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof TwoFactorGetOutput
     */
    'qr_uri': string;
    /**
     * 
     * @type {string}
     * @memberof TwoFactorGetOutput
     */
    'secret': string;
}
/**
 * 
 * @export
 * @interface TwoFactorPasscodeInput
 */
export interface TwoFactorPasscodeInput {
    /**
     * 
     * @type {string}
     * @memberof TwoFactorPasscodeInput
     */
    'passcode': string;
}
/**
 * 
 * @export
 * @interface TwoFactorScratchTokenInput
 */
export interface TwoFactorScratchTokenInput {
    /**
     * 
     * @type {string}
     * @memberof TwoFactorScratchTokenInput
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UserCreateInput
 */
export interface UserCreateInput {
    /**
     * 
     * @type {string}
     * @memberof UserCreateInput
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInput
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInput
     */
    'password'?: string | null;
}
/**
 * 
 * @export
 * @interface UserGroupOwnerEvaluation
 */
export interface UserGroupOwnerEvaluation {
    /**
     * 
     * @type {Array<OwnerEvaluation>}
     * @memberof UserGroupOwnerEvaluation
     */
    'evaluations': Array<OwnerEvaluation>;
    /**
     * 
     * @type {string}
     * @memberof UserGroupOwnerEvaluation
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof UserGroupOwnerEvaluation
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UserModel
 */
export interface UserModel {
    /**
     * 
     * @type {number}
     * @memberof UserModel
     */
    'created': number;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof UserModel
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserModel
     */
    'is_active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserModel
     */
    'is_admin': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserModel
     */
    'is_blocked': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof UserModel
     */
    'parent_id'?: number | null;
    /**
     * 
     * @type {ParentResourceType}
     * @memberof UserModel
     */
    'parent_type'?: ParentResourceType | null;
    /**
     * 
     * @type {UserType}
     * @memberof UserModel
     */
    'type': UserType;
    /**
     * 
     * @type {number}
     * @memberof UserModel
     */
    'updated': number;
}


/**
 * 
 * @export
 * @interface UserPatchInput
 */
export interface UserPatchInput {
    /**
     * 
     * @type {string}
     * @memberof UserPatchInput
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPatchInput
     */
    'email'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPatchInput
     */
    'is_active'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPatchInput
     */
    'is_blocked'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserPatchInput
     */
    'password'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Email: 'email',
    Admin: 'admin',
    Created: 'created',
    Updated: 'updated'
} as const;

export type UserSort = typeof UserSort[keyof typeof UserSort];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserType = {
    User: 'user',
    ServiceAccount: 'service_account'
} as const;

export type UserType = typeof UserType[keyof typeof UserType];


/**
 * 
 * @export
 * @interface VariableCreateInput
 */
export interface VariableCreateInput {
    /**
     * 
     * @type {string}
     * @memberof VariableCreateInput
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof VariableCreateInput
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof VariableCreateInput
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof VariableCreateInput
     */
    'parent_ref': string;
    /**
     * 
     * @type {VariableType}
     * @memberof VariableCreateInput
     */
    'type': VariableType;
}


/**
 * 
 * @export
 * @interface VariableGroup
 */
export interface VariableGroup {
    /**
     * 
     * @type {GroupModel}
     * @memberof VariableGroup
     */
    'group'?: GroupModel | null;
    /**
     * 
     * @type {VariableModel}
     * @memberof VariableGroup
     */
    'model': VariableModel;
}
/**
 * 
 * @export
 * @interface VariableModel
 */
export interface VariableModel {
    /**
     * 
     * @type {number}
     * @memberof VariableModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof VariableModel
     */
    'created_by': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof VariableModel
     */
    'data': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof VariableModel
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof VariableModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof VariableModel
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof VariableModel
     */
    'parent_id': number;
    /**
     * 
     * @type {Scope}
     * @memberof VariableModel
     */
    'scope': Scope;
    /**
     * 
     * @type {VariableType}
     * @memberof VariableModel
     */
    'type': VariableType;
    /**
     * 
     * @type {number}
     * @memberof VariableModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof VariableModel
     */
    'version': number;
}


/**
 * 
 * @export
 * @interface VariablePatchInput
 */
export interface VariablePatchInput {
    /**
     * 
     * @type {string}
     * @memberof VariablePatchInput
     */
    'data'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VariablePatchInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VariablePatchInput
     */
    'identifier'?: string | null;
    /**
     * 
     * @type {VariableType}
     * @memberof VariablePatchInput
     */
    'type': VariableType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const VariableSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    Type: 'type',
    Created: 'created',
    Updated: 'updated'
} as const;

export type VariableSort = typeof VariableSort[keyof typeof VariableSort];


/**
 * 
 * @export
 * @enum {string}
 */

export const VariableType = {
    PlainText: 'plain_text',
    SecretText: 'secret_text',
    EnvironmentText: 'environment_text',
    EnvironmentSecret: 'environment_secret'
} as const;

export type VariableType = typeof VariableType[keyof typeof VariableType];


/**
 * 
 * @export
 * @interface WebhookCreateInput
 */
export interface WebhookCreateInput {
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateInput
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateInput
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookCreateInput
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateInput
     */
    'identifier': string;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookCreateInput
     */
    'insecure': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateInput
     */
    'secret': string;
    /**
     * 
     * @type {Array<WebhookTrigger>}
     * @memberof WebhookCreateInput
     */
    'triggers': Array<WebhookTrigger>;
    /**
     * 
     * @type {string}
     * @memberof WebhookCreateInput
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface WebhookExecutionModel
 */
export interface WebhookExecutionModel {
    /**
     * 
     * @type {number}
     * @memberof WebhookExecutionModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof WebhookExecutionModel
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof WebhookExecutionModel
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof WebhookExecutionModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WebhookExecutionModel
     */
    'request_body': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookExecutionModel
     */
    'request_headers': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookExecutionModel
     */
    'request_url': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookExecutionModel
     */
    'response_body': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookExecutionModel
     */
    'response_headers': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookExecutionModel
     */
    'response_status': string;
    /**
     * 
     * @type {number}
     * @memberof WebhookExecutionModel
     */
    'response_status_code': number;
    /**
     * 
     * @type {WebhookExecutionResult}
     * @memberof WebhookExecutionModel
     */
    'result': WebhookExecutionResult;
    /**
     * 
     * @type {number}
     * @memberof WebhookExecutionModel
     */
    'retrigger_of'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookExecutionModel
     */
    'retriggerable': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebhookExecutionModel
     */
    'trigger_id': string;
    /**
     * 
     * @type {WebhookTrigger}
     * @memberof WebhookExecutionModel
     */
    'trigger_type': WebhookTrigger;
    /**
     * 
     * @type {number}
     * @memberof WebhookExecutionModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof WebhookExecutionModel
     */
    'webhook_id': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookExecutionResult = {
    Unknown: 'unknown',
    Success: 'success',
    RetriableError: 'retriable_error',
    FatalError: 'fatal_error'
} as const;

export type WebhookExecutionResult = typeof WebhookExecutionResult[keyof typeof WebhookExecutionResult];


/**
 * 
 * @export
 * @interface WebhookModel
 */
export interface WebhookModel {
    /**
     * 
     * @type {number}
     * @memberof WebhookModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof WebhookModel
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookModel
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebhookModel
     */
    'group_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookModel
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookModel
     */
    'insecure': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookModel
     */
    'internal': boolean;
    /**
     * 
     * @type {WebhookExecutionResult}
     * @memberof WebhookModel
     */
    'latest_execution_result'?: WebhookExecutionResult | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    'name': string;
    /**
     * 
     * @type {WebhookParentType}
     * @memberof WebhookModel
     */
    'parent_type': WebhookParentType;
    /**
     * 
     * @type {number}
     * @memberof WebhookModel
     */
    'repo_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    'secret': string;
    /**
     * 
     * @type {Array<WebhookTrigger>}
     * @memberof WebhookModel
     */
    'triggers': Array<WebhookTrigger>;
    /**
     * 
     * @type {number}
     * @memberof WebhookModel
     */
    'updated': number;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof WebhookModel
     */
    'version': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookParentType = {
    Repository: 'repository',
    Group: 'group'
} as const;

export type WebhookParentType = typeof WebhookParentType[keyof typeof WebhookParentType];


/**
 * 
 * @export
 * @interface WebhookPatchInput
 */
export interface WebhookPatchInput {
    /**
     * 
     * @type {string}
     * @memberof WebhookPatchInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookPatchInput
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookPatchInput
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookPatchInput
     */
    'identifier'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookPatchInput
     */
    'insecure'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookPatchInput
     */
    'secret'?: string | null;
    /**
     * 
     * @type {Array<WebhookTrigger>}
     * @memberof WebhookPatchInput
     */
    'triggers'?: Array<WebhookTrigger> | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookPatchInput
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookSort = {
    Noop: 'noop',
    Id: 'id',
    Name: 'name',
    DisplayName: 'display_name',
    Created: 'created',
    Updated: 'updated'
} as const;

export type WebhookSort = typeof WebhookSort[keyof typeof WebhookSort];


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookTrigger = {
    Noop: 'noop',
    BranchCreated: 'branch_created',
    BranchUpdated: 'branch_updated',
    BranchDeleted: 'branch_deleted',
    TagCreated: 'tag_created',
    TagUpdated: 'tag_updated',
    TagDeleted: 'tag_deleted',
    PullreqCreated: 'pullreq_created',
    PullreqReopened: 'pullreq_reopened',
    PullreqSynchronize: 'pullreq_synchronize',
    PullreqClosed: 'pullreq_closed',
    PullreqCommented: 'pullreq_commented',
    PullreqMerged: 'pullreq_merged'
} as const;

export type WebhookTrigger = typeof WebhookTrigger[keyof typeof WebhookTrigger];


/**
 * 
 * @export
 * @interface WorkflowCreateInput
 */
export interface WorkflowCreateInput {
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowCreateInput
     */
    'debug': boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkflowCreateInput
     */
    'deploy'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorkflowCreateInput
     */
    'deploy_id'?: number | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WorkflowCreateInput
     */
    'params'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof WorkflowCreateInput
     */
    'source_repo_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowCreateInput
     */
    'source_sha'?: string | null;
}
/**
 * 
 * @export
 * @interface WorkflowModel
 */
export interface WorkflowModel {
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'action'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'action_id': number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'after_sha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'author_email': string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'author_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'author_name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'before_sha': string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'created': number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'cron': string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowModel
     */
    'debug': boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'deploy': string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'deploy_id': number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'error': string;
    /**
     * 
     * @type {TriggerEvent}
     * @memberof WorkflowModel
     */
    'event': TriggerEvent;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'finished': number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'number': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WorkflowModel
     */
    'params': { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'repo_id': number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'source_repo_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'source_rev'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'started': number;
    /**
     * 
     * @type {CIStatus}
     * @memberof WorkflowModel
     */
    'status': CIStatus;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'target_rev': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'updated': number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowModel
     */
    'version': number;
    /**
     * 
     * @type {YamlProvider}
     * @memberof WorkflowModel
     */
    'yaml_provider': YamlProvider;
    /**
     * 
     * @type {string}
     * @memberof WorkflowModel
     */
    'yaml_resolved': string;
}


/**
 * 
 * @export
 * @interface WorkflowStages
 */
export interface WorkflowStages {
    /**
     * 
     * @type {WorkflowModel}
     * @memberof WorkflowStages
     */
    'model': WorkflowModel;
    /**
     * 
     * @type {Array<StageSteps>}
     * @memberof WorkflowStages
     */
    'stages': Array<StageSteps>;
}
/**
 * 
 * @export
 * @interface WorkflowUpdateInput
 */
export interface WorkflowUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof WorkflowUpdateInput
     */
    'after'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkflowUpdateInput
     */
    'error'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorkflowUpdateInput
     */
    'finished'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WorkflowUpdateInput
     */
    'started'?: number | null;
    /**
     * 
     * @type {CIStatus}
     * @memberof WorkflowUpdateInput
     */
    'status'?: CIStatus | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const YamlProvider = {
    Unknown: 'unknown',
    Github: 'github',
    Gitlab: 'gitlab'
} as const;

export type YamlProvider = typeof YamlProvider[keyof typeof YamlProvider];



/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginInput} loginInput Login input
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin: async (loginInput: LoginInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInput' is not null or undefined
            assertParamExists('postLogin', 'loginInput', loginInput)
            const localVarPath = `/account/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterInput} registerInput Register a new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegister: async (registerInput: RegisterInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerInput' is not null or undefined
            assertParamExists('postRegister', 'registerInput', registerInput)
            const localVarPath = `/account/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TwoFactorPasscodeInput} twoFactorPasscodeInput Login with two factor passcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactorPasscode: async (twoFactorPasscodeInput: TwoFactorPasscodeInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorPasscodeInput' is not null or undefined
            assertParamExists('postTwoFactorPasscode', 'twoFactorPasscodeInput', twoFactorPasscodeInput)
            const localVarPath = `/account/two_factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorPasscodeInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TwoFactorScratchTokenInput} twoFactorScratchTokenInput Login with two scratch token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactorScratchToken: async (twoFactorScratchTokenInput: TwoFactorScratchTokenInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorScratchTokenInput' is not null or undefined
            assertParamExists('postTwoFactorScratchToken', 'twoFactorScratchTokenInput', twoFactorScratchTokenInput)
            const localVarPath = `/account/two_factor/scratch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorScratchTokenInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginInput} loginInput Login input
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogin(loginInput: LoginInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLogin(loginInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterInput} registerInput Register a new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegister(registerInput: RegisterInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegister(registerInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TwoFactorPasscodeInput} twoFactorPasscodeInput Login with two factor passcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTwoFactorPasscode(twoFactorPasscodeInput: TwoFactorPasscodeInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTwoFactorPasscode(twoFactorPasscodeInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postTwoFactorPasscode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TwoFactorScratchTokenInput} twoFactorScratchTokenInput Login with two scratch token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTwoFactorScratchToken(twoFactorScratchTokenInput: TwoFactorScratchTokenInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTwoFactorScratchToken(twoFactorScratchTokenInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postTwoFactorScratchToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginInput} loginInput Login input
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin(loginInput: LoginInput, options?: RawAxiosRequestConfig): AxiosPromise<LoginOutput> {
            return localVarFp.postLogin(loginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterInput} registerInput Register a new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegister(registerInput: RegisterInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.postRegister(registerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TwoFactorPasscodeInput} twoFactorPasscodeInput Login with two factor passcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactorPasscode(twoFactorPasscodeInput: TwoFactorPasscodeInput, options?: RawAxiosRequestConfig): AxiosPromise<LoginOutput> {
            return localVarFp.postTwoFactorPasscode(twoFactorPasscodeInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TwoFactorScratchTokenInput} twoFactorScratchTokenInput Login with two scratch token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactorScratchToken(twoFactorScratchTokenInput: TwoFactorScratchTokenInput, options?: RawAxiosRequestConfig): AxiosPromise<LoginOutput> {
            return localVarFp.postTwoFactorScratchToken(twoFactorScratchTokenInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @param {LoginInput} loginInput Login input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public postLogin(loginInput: LoginInput, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postLogin(loginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public postLogout(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterInput} registerInput Register a new user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public postRegister(registerInput: RegisterInput, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postRegister(registerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TwoFactorPasscodeInput} twoFactorPasscodeInput Login with two factor passcode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public postTwoFactorPasscode(twoFactorPasscodeInput: TwoFactorPasscodeInput, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postTwoFactorPasscode(twoFactorPasscodeInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TwoFactorScratchTokenInput} twoFactorScratchTokenInput Login with two scratch token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public postTwoFactorScratchToken(twoFactorScratchTokenInput: TwoFactorScratchTokenInput, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postTwoFactorScratchToken(twoFactorScratchTokenInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflow: async (repoRef: string, actionIdentifier: string, workflowIdn: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('cancelWorkflow', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('cancelWorkflow', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('cancelWorkflow', 'workflowIdn', workflowIdn)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/cancel`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAction: async (repoRef: string, actionIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteAction', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('deleteAction', 'actionIdentifier', actionIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: async (repoRef: string, actionIdentifier: string, workflowIdn: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteWorkflow', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('deleteWorkflow', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('deleteWorkflow', 'workflowIdn', workflowIdn)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAction: async (repoRef: string, actionIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getAction', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('getAction', 'actionIdentifier', actionIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [latest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions: async (repoRef: string, page?: number, size?: number, query?: string, latest?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getActions', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/actions`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (latest !== undefined) {
                localVarQueryParameter['latest'] = latest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStepLogStream: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getStepLogStream', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('getStepLogStream', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('getStepLogStream', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('getStepLogStream', 'stageNumber', stageNumber)
            // verify required parameter 'stepNumber' is not null or undefined
            assertParamExists('getStepLogStream', 'stepNumber', stepNumber)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/logs/{stage_number}/{step_number}/stream`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)))
                .replace(`{${"step_number"}}`, encodeURIComponent(String(stepNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStepLogs: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getStepLogs', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('getStepLogs', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('getStepLogs', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('getStepLogs', 'stageNumber', stageNumber)
            // verify required parameter 'stepNumber' is not null or undefined
            assertParamExists('getStepLogs', 'stepNumber', stepNumber)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/logs/{stage_number}/{step_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)))
                .replace(`{${"step_number"}}`, encodeURIComponent(String(stepNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow: async (repoRef: string, actionIdentifier: string, workflowIdn: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getWorkflow', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('getWorkflow', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('getWorkflow', 'workflowIdn', workflowIdn)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows: async (repoRef: string, actionIdentifier: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getWorkflows', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('getWorkflows', 'actionIdentifier', actionIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {ActionUpdateInput} actionUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAction: async (repoRef: string, actionIdentifier: string, actionUpdateInput: ActionUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchAction', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('patchAction', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'actionUpdateInput' is not null or undefined
            assertParamExists('patchAction', 'actionUpdateInput', actionUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StageUpdateInput} stageUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStage: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stageUpdateInput: StageUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchStage', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('patchStage', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('patchStage', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('patchStage', 'stageNumber', stageNumber)
            // verify required parameter 'stageUpdateInput' is not null or undefined
            assertParamExists('patchStage', 'stageUpdateInput', stageUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/stages/{stage_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stageUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {StepUpdateInput} stepUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStep: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, stepUpdateInput: StepUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchStep', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('patchStep', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('patchStep', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('patchStep', 'stageNumber', stageNumber)
            // verify required parameter 'stepNumber' is not null or undefined
            assertParamExists('patchStep', 'stepNumber', stepNumber)
            // verify required parameter 'stepUpdateInput' is not null or undefined
            assertParamExists('patchStep', 'stepUpdateInput', stepUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/stages/{stage_number}/{step_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)))
                .replace(`{${"step_number"}}`, encodeURIComponent(String(stepNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {WorkflowUpdateInput} workflowUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow: async (repoRef: string, actionIdentifier: string, workflowIdn: number, workflowUpdateInput: WorkflowUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchWorkflow', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('patchWorkflow', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('patchWorkflow', 'workflowIdn', workflowIdn)
            // verify required parameter 'workflowUpdateInput' is not null or undefined
            assertParamExists('patchWorkflow', 'workflowUpdateInput', workflowUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ActionCreateInput} actionCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAction: async (repoRef: string, actionCreateInput: ActionCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postAction', 'repoRef', repoRef)
            // verify required parameter 'actionCreateInput' is not null or undefined
            assertParamExists('postAction', 'actionCreateInput', actionCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {StageCreateInput} stageCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStage: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageCreateInput: StageCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postStage', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('postStage', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('postStage', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageCreateInput' is not null or undefined
            assertParamExists('postStage', 'stageCreateInput', stageCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/stages`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stageCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StepCreateInput} stepCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStep: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepCreateInput: StepCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postStep', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('postStep', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('postStep', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('postStep', 'stageNumber', stageNumber)
            // verify required parameter 'stepCreateInput' is not null or undefined
            assertParamExists('postStep', 'stepCreateInput', stepCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/stages/{stage_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {Array<number>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStepLog: async (repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, requestBody: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postStepLog', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('postStepLog', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowIdn' is not null or undefined
            assertParamExists('postStepLog', 'workflowIdn', workflowIdn)
            // verify required parameter 'stageNumber' is not null or undefined
            assertParamExists('postStepLog', 'stageNumber', stageNumber)
            // verify required parameter 'stepNumber' is not null or undefined
            assertParamExists('postStepLog', 'stepNumber', stepNumber)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('postStepLog', 'requestBody', requestBody)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows/{workflow_idn}/stages/{stage_number}/{step_number}/logs`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)))
                .replace(`{${"workflow_idn"}}`, encodeURIComponent(String(workflowIdn)))
                .replace(`{${"stage_number"}}`, encodeURIComponent(String(stageNumber)))
                .replace(`{${"step_number"}}`, encodeURIComponent(String(stepNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {WorkflowCreateInput} workflowCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkflow: async (repoRef: string, actionIdentifier: string, workflowCreateInput: WorkflowCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postWorkflow', 'repoRef', repoRef)
            // verify required parameter 'actionIdentifier' is not null or undefined
            assertParamExists('postWorkflow', 'actionIdentifier', actionIdentifier)
            // verify required parameter 'workflowCreateInput' is not null or undefined
            assertParamExists('postWorkflow', 'workflowCreateInput', workflowCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/actions/{action_identifier}/workflows`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"action_identifier"}}`, encodeURIComponent(String(actionIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelWorkflow(repoRef, actionIdentifier, workflowIdn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.cancelWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAction(repoRef, actionIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.deleteAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflow(repoRef, actionIdentifier, workflowIdn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.deleteWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAction(repoRef, actionIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [latest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActions(repoRef: string, page?: number, size?: number, query?: string, latest?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActionWorkflow>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActions(repoRef, page, size, query, latest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getActions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStepLogStream(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveLogLine>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStepLogStream(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getStepLogStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStepLogs(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveLogLine>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStepLogs(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getStepLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflow(repoRef, actionIdentifier, workflowIdn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflows(repoRef: string, actionIdentifier: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflows(repoRef, actionIdentifier, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getWorkflows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {ActionUpdateInput} actionUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAction(repoRef: string, actionIdentifier: string, actionUpdateInput: ActionUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAction(repoRef, actionIdentifier, actionUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.patchAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StageUpdateInput} stageUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStage(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stageUpdateInput: StageUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchStage(repoRef, actionIdentifier, workflowIdn, stageNumber, stageUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.patchStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {StepUpdateInput} stepUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, stepUpdateInput: StepUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, stepUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.patchStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {WorkflowUpdateInput} workflowUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, workflowUpdateInput: WorkflowUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchWorkflow(repoRef, actionIdentifier, workflowIdn, workflowUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.patchWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ActionCreateInput} actionCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAction(repoRef: string, actionCreateInput: ActionCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAction(repoRef, actionCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.postAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {StageCreateInput} stageCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStage(repoRef: string, actionIdentifier: string, workflowIdn: number, stageCreateInput: StageCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postStage(repoRef, actionIdentifier, workflowIdn, stageCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.postStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StepCreateInput} stepCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepCreateInput: StepCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.postStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {Array<number>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStepLog(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, requestBody: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postStepLog(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.postStepLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {WorkflowCreateInput} workflowCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWorkflow(repoRef: string, actionIdentifier: string, workflowCreateInput: WorkflowCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWorkflow(repoRef, actionIdentifier, workflowCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.postWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowStages> {
            return localVarFp.cancelWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAction(repoRef, actionIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<ActionModel> {
            return localVarFp.getAction(repoRef, actionIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [latest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions(repoRef: string, page?: number, size?: number, query?: string, latest?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ActionWorkflow>> {
            return localVarFp.getActions(repoRef, page, size, query, latest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStepLogStream(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<LiveLogLine>> {
            return localVarFp.getStepLogStream(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStepLogs(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<LiveLogLine>> {
            return localVarFp.getStepLogs(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowStages> {
            return localVarFp.getWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows(repoRef: string, actionIdentifier: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkflowModel>> {
            return localVarFp.getWorkflows(repoRef, actionIdentifier, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {ActionUpdateInput} actionUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAction(repoRef: string, actionIdentifier: string, actionUpdateInput: ActionUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<ActionModel> {
            return localVarFp.patchAction(repoRef, actionIdentifier, actionUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StageUpdateInput} stageUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStage(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stageUpdateInput: StageUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<StageModel> {
            return localVarFp.patchStage(repoRef, actionIdentifier, workflowIdn, stageNumber, stageUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {StepUpdateInput} stepUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, stepUpdateInput: StepUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<StepModel> {
            return localVarFp.patchStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, stepUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {WorkflowUpdateInput} workflowUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, workflowUpdateInput: WorkflowUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowModel> {
            return localVarFp.patchWorkflow(repoRef, actionIdentifier, workflowIdn, workflowUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ActionCreateInput} actionCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAction(repoRef: string, actionCreateInput: ActionCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<ActionModel> {
            return localVarFp.postAction(repoRef, actionCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {StageCreateInput} stageCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStage(repoRef: string, actionIdentifier: string, workflowIdn: number, stageCreateInput: StageCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<StageModel> {
            return localVarFp.postStage(repoRef, actionIdentifier, workflowIdn, stageCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {StepCreateInput} stepCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepCreateInput: StepCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<StepModel> {
            return localVarFp.postStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {number} workflowIdn Workflow number or id
         * @param {number} stageNumber Stage number
         * @param {number} stepNumber Step number
         * @param {Array<number>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStepLog(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, requestBody: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postStepLog(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} actionIdentifier Action id or name
         * @param {WorkflowCreateInput} workflowCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkflow(repoRef: string, actionIdentifier: string, workflowCreateInput: WorkflowCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postWorkflow(repoRef, actionIdentifier, workflowCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public cancelWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).cancelWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public deleteAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).deleteAction(repoRef, actionIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public deleteWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).deleteWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getAction(repoRef: string, actionIdentifier: string, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getAction(repoRef, actionIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {boolean} [latest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getActions(repoRef: string, page?: number, size?: number, query?: string, latest?: boolean, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getActions(repoRef, page, size, query, latest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {number} stepNumber Step number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getStepLogStream(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getStepLogStream(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {number} stepNumber Step number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getStepLogs(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getStepLogs(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getWorkflow(repoRef, actionIdentifier, workflowIdn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getWorkflows(repoRef: string, actionIdentifier: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getWorkflows(repoRef, actionIdentifier, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {ActionUpdateInput} actionUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public patchAction(repoRef: string, actionIdentifier: string, actionUpdateInput: ActionUpdateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).patchAction(repoRef, actionIdentifier, actionUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {StageUpdateInput} stageUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public patchStage(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stageUpdateInput: StageUpdateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).patchStage(repoRef, actionIdentifier, workflowIdn, stageNumber, stageUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {number} stepNumber Step number
     * @param {StepUpdateInput} stepUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public patchStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, stepUpdateInput: StepUpdateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).patchStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, stepUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {WorkflowUpdateInput} workflowUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public patchWorkflow(repoRef: string, actionIdentifier: string, workflowIdn: number, workflowUpdateInput: WorkflowUpdateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).patchWorkflow(repoRef, actionIdentifier, workflowIdn, workflowUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {ActionCreateInput} actionCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public postAction(repoRef: string, actionCreateInput: ActionCreateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).postAction(repoRef, actionCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {StageCreateInput} stageCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public postStage(repoRef: string, actionIdentifier: string, workflowIdn: number, stageCreateInput: StageCreateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).postStage(repoRef, actionIdentifier, workflowIdn, stageCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {StepCreateInput} stepCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public postStep(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepCreateInput: StepCreateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).postStep(repoRef, actionIdentifier, workflowIdn, stageNumber, stepCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {number} workflowIdn Workflow number or id
     * @param {number} stageNumber Stage number
     * @param {number} stepNumber Step number
     * @param {Array<number>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public postStepLog(repoRef: string, actionIdentifier: string, workflowIdn: number, stageNumber: number, stepNumber: number, requestBody: Array<number>, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).postStepLog(repoRef, actionIdentifier, workflowIdn, stageNumber, stepNumber, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} actionIdentifier Action id or name
     * @param {WorkflowCreateInput} workflowCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public postWorkflow(repoRef: string, actionIdentifier: string, workflowCreateInput: WorkflowCreateInput, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).postWorkflow(repoRef, actionIdentifier, workflowCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('deleteGroup', 'groupRef', groupRef)
            const localVarPath = `/admin/groups/{group_ref}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner: async (runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('deleteRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/admin/runners/{runner_uuid}`
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('deleteUser', 'userIdentifier', userIdentifier)
            const localVarPath = `/admin/users/{user_identifier}`
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable: async (variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('deleteVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/admin/variables/{variable_identifier}`
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: async (page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResetedRunnerRegisterToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/runners/register_token/reseted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner: async (runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('getRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/admin/runners/{runner_uuid}`
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerRegisterToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/runners/register_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunners: async (page?: number, size?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/runners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('getUser', 'userIdentifier', userIdentifier)
            const localVarPath = `/admin/users/{user_identifier}`
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {OrderOption} [order] 
         * @param {UserSort} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (page?: number, size?: number, query?: string, order?: OrderOption, sort?: UserSort, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariable: async (variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('getVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/admin/variables/{variable_identifier}`
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables: async (page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRunner: async (runnerUuid: string, runnerPatchInput: RunnerPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('patchRunner', 'runnerUuid', runnerUuid)
            // verify required parameter 'runnerPatchInput' is not null or undefined
            assertParamExists('patchRunner', 'runnerPatchInput', runnerPatchInput)
            const localVarPath = `/admin/runners/{runner_uuid}`
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {UserPatchInput} userPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser: async (userIdentifier: string, userPatchInput: UserPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('patchUser', 'userIdentifier', userIdentifier)
            // verify required parameter 'userPatchInput' is not null or undefined
            assertParamExists('patchUser', 'userPatchInput', userPatchInput)
            const localVarPath = `/admin/users/{user_identifier}`
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {AdminPatchInput} adminPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserAdmin: async (userIdentifier: string, adminPatchInput: AdminPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('patchUserAdmin', 'userIdentifier', userIdentifier)
            // verify required parameter 'adminPatchInput' is not null or undefined
            assertParamExists('patchUserAdmin', 'adminPatchInput', adminPatchInput)
            const localVarPath = `/admin/users/{user_identifier}/admin`
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVariable: async (variableIdentifier: string, variablePatchInput: VariablePatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('patchVariable', 'variableIdentifier', variableIdentifier)
            // verify required parameter 'variablePatchInput' is not null or undefined
            assertParamExists('patchVariable', 'variablePatchInput', variablePatchInput)
            const localVarPath = `/admin/variables/{variable_identifier}`
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variablePatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserCreateInput} userCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser: async (userCreateInput: UserCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateInput' is not null or undefined
            assertParamExists('postUser', 'userCreateInput', userCreateInput)
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariable: async (variableCreateInput: VariableCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variableCreateInput' is not null or undefined
            assertParamExists('postVariable', 'variableCreateInput', variableCreateInput)
            const localVarPath = `/admin/variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRunner(runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRunner(runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVariable(variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVariable(variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResetedRunnerRegisterToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResetedRunnerRegisterToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getResetedRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunner(runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunner(runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerRegisterToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerRegisterToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunners(page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunnerCreator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunners(page, size, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getRunners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {OrderOption} [order] 
         * @param {UserSort} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(page?: number, size?: number, query?: string, order?: OrderOption, sort?: UserSort, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(page, size, query, order, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariable(variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariable(variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariables(page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariableGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariables(page, size, query, types, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRunner(runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRunner(runnerUuid, runnerPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.patchRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {UserPatchInput} userPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUser(userIdentifier: string, userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUser(userIdentifier, userPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.patchUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {AdminPatchInput} adminPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserAdmin(userIdentifier: string, adminPatchInput: AdminPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUserAdmin(userIdentifier, adminPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.patchUserAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchVariable(variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchVariable(variableIdentifier, variablePatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.patchVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserCreateInput} userCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUser(userCreateInput: UserCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUser(userCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.postUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVariable(variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postVariable(variableCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.postVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroup(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner(runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRunner(runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(userIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariable(variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVariable(variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupModel>> {
            return localVarFp.getGroups(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResetedRunnerRegisterToken(options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getResetedRunnerRegisterToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner(runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.getRunner(runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerRegisterToken(options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getRunnerRegisterToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunners(page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunnerCreator>> {
            return localVarFp.getRunners(page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: RawAxiosRequestConfig): AxiosPromise<AdminStats> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.getUser(userIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {OrderOption} [order] 
         * @param {UserSort} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(page?: number, size?: number, query?: string, order?: OrderOption, sort?: UserSort, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserModel>> {
            return localVarFp.getUsers(page, size, query, order, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariable(variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.getVariable(variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariableGroup>> {
            return localVarFp.getVariables(page, size, query, types, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRunner(runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.patchRunner(runnerUuid, runnerPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {UserPatchInput} userPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser(userIdentifier: string, userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.patchUser(userIdentifier, userPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userIdentifier 
         * @param {AdminPatchInput} adminPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserAdmin(userIdentifier: string, adminPatchInput: AdminPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.patchUserAdmin(userIdentifier, adminPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchVariable(variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.patchVariable(variableIdentifier, variablePatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserCreateInput} userCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(userCreateInput: UserCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.postUser(userCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVariable(variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.postVariable(variableCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @param {string} groupRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteGroup(groupRef: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteGroup(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteRunner(runnerUuid: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteRunner(runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteUser(userIdentifier: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteUser(userIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteVariable(variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteVariable(variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {GroupSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getGroups(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getResetedRunnerRegisterToken(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getResetedRunnerRegisterToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getRunner(runnerUuid: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getRunner(runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getRunnerRegisterToken(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getRunnerRegisterToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getRunners(page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getRunners(page, size, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getStats(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUser(userIdentifier: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUser(userIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {OrderOption} [order] 
     * @param {UserSort} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUsers(page?: number, size?: number, query?: string, order?: OrderOption, sort?: UserSort, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUsers(page, size, query, order, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getVariable(variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getVariable(variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<VariableType>} [types] 
     * @param {VariableSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getVariables(page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getVariables(page, size, query, types, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} runnerUuid 
     * @param {RunnerPatchInput} runnerPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public patchRunner(runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).patchRunner(runnerUuid, runnerPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userIdentifier 
     * @param {UserPatchInput} userPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public patchUser(userIdentifier: string, userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).patchUser(userIdentifier, userPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userIdentifier 
     * @param {AdminPatchInput} adminPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public patchUserAdmin(userIdentifier: string, adminPatchInput: AdminPatchInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).patchUserAdmin(userIdentifier, adminPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} variableIdentifier 
     * @param {VariablePatchInput} variablePatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public patchVariable(variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).patchVariable(variableIdentifier, variablePatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserCreateInput} userCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public postUser(userCreateInput: UserCreateInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).postUser(userCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VariableCreateInput} variableCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public postVariable(variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).postVariable(variableCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BootstrapApi - axios parameter creator
 * @export
 */
export const BootstrapApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} bootstrapRef Group path (eg: \&#39;/group1/group2\&#39;), or repository path (eg: \&#39;/group1/group2/repo\&#39;), or username
         * @param {string | null} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBootstrap: async (bootstrapRef: string, path: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bootstrapRef' is not null or undefined
            assertParamExists('getBootstrap', 'bootstrapRef', bootstrapRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getBootstrap', 'path', path)
            const localVarPath = `/bootstrap/{bootstrap_ref}/+/{path}`
                .replace(`{${"bootstrap_ref"}}`, encodeURIComponent(String(bootstrapRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BootstrapApi - functional programming interface
 * @export
 */
export const BootstrapApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BootstrapApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} bootstrapRef Group path (eg: \&#39;/group1/group2\&#39;), or repository path (eg: \&#39;/group1/group2/repo\&#39;), or username
         * @param {string | null} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBootstrap(bootstrapRef: string, path: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BootstrapMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBootstrap(bootstrapRef, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BootstrapApi.getBootstrap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BootstrapApi - factory interface
 * @export
 */
export const BootstrapApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BootstrapApiFp(configuration)
    return {
        /**
         * 
         * @param {string} bootstrapRef Group path (eg: \&#39;/group1/group2\&#39;), or repository path (eg: \&#39;/group1/group2/repo\&#39;), or username
         * @param {string | null} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBootstrap(bootstrapRef: string, path: string | null, options?: RawAxiosRequestConfig): AxiosPromise<BootstrapMetadata> {
            return localVarFp.getBootstrap(bootstrapRef, path, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BootstrapApi - object-oriented interface
 * @export
 * @class BootstrapApi
 * @extends {BaseAPI}
 */
export class BootstrapApi extends BaseAPI {
    /**
     * 
     * @param {string} bootstrapRef Group path (eg: \&#39;/group1/group2\&#39;), or repository path (eg: \&#39;/group1/group2/repo\&#39;), or username
     * @param {string | null} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BootstrapApi
     */
    public getBootstrap(bootstrapRef: string, path: string | null, options?: RawAxiosRequestConfig) {
        return BootstrapApiFp(this.configuration).getBootstrap(bootstrapRef, path, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectorsApi - axios parameter creator
 * @export
 */
export const ConnectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector: async (connectorRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorRef' is not null or undefined
            assertParamExists('deleteConnector', 'connectorRef', connectorRef)
            const localVarPath = `/connectors/{connector_ref}`
                .replace(`{${"connector_ref"}}`, encodeURIComponent(String(connectorRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: async (connectorRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorRef' is not null or undefined
            assertParamExists('getConnector', 'connectorRef', connectorRef)
            const localVarPath = `/connectors/{connector_ref}`
                .replace(`{${"connector_ref"}}`, encodeURIComponent(String(connectorRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {ConnectorPatchInput} connectorPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnector: async (connectorRef: string, connectorPatchInput: ConnectorPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorRef' is not null or undefined
            assertParamExists('patchConnector', 'connectorRef', connectorRef)
            // verify required parameter 'connectorPatchInput' is not null or undefined
            assertParamExists('patchConnector', 'connectorPatchInput', connectorPatchInput)
            const localVarPath = `/connectors/{connector_ref}`
                .replace(`{${"connector_ref"}}`, encodeURIComponent(String(connectorRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConnectorCreateInput} connectorCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConnector: async (connectorCreateInput: ConnectorCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorCreateInput' is not null or undefined
            assertParamExists('postConnector', 'connectorCreateInput', connectorCreateInput)
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsApi - functional programming interface
 * @export
 */
export const ConnectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnector(connectorRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnector(connectorRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.deleteConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnector(connectorRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnector(connectorRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {ConnectorPatchInput} connectorPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchConnector(connectorRef: string, connectorPatchInput: ConnectorPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchConnector(connectorRef, connectorPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.patchConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ConnectorCreateInput} connectorCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postConnector(connectorCreateInput: ConnectorCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postConnector(connectorCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.postConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorsApi - factory interface
 * @export
 */
export const ConnectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector(connectorRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteConnector(connectorRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector(connectorRef: string, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorModel> {
            return localVarFp.getConnector(connectorRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectorRef 
         * @param {ConnectorPatchInput} connectorPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnector(connectorRef: string, connectorPatchInput: ConnectorPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorModel> {
            return localVarFp.patchConnector(connectorRef, connectorPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConnectorCreateInput} connectorCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConnector(connectorCreateInput: ConnectorCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<ConnectorModel> {
            return localVarFp.postConnector(connectorCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorsApi - object-oriented interface
 * @export
 * @class ConnectorsApi
 * @extends {BaseAPI}
 */
export class ConnectorsApi extends BaseAPI {
    /**
     * 
     * @param {string} connectorRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public deleteConnector(connectorRef: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).deleteConnector(connectorRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectorRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnector(connectorRef: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnector(connectorRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectorRef 
     * @param {ConnectorPatchInput} connectorPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public patchConnector(connectorRef: string, connectorPatchInput: ConnectorPatchInput, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).patchConnector(connectorRef, connectorPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConnectorCreateInput} connectorCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public postConnector(connectorCreateInput: ConnectorCreateInput, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).postConnector(connectorCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsRunner: async (groupRef: string, runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('deleteGroupsRunner', 'groupRef', groupRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('deleteGroupsRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/groups/{group_ref}/+/runners/{runner_uuid}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsVariable: async (groupRef: string, variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('deleteGroupsVariable', 'groupRef', groupRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('deleteGroupsVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/groups/{group_ref}/+/variables/{variable_identifier}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (groupRef: string, userIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('deleteMember', 'groupRef', groupRef)
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('deleteMember', 'userIdentifier', userIdentifier)
            const localVarPath = `/groups/{group_ref}/+/members/{user_identifier}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors: async (groupRef: string, page?: number, size?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getConnectors', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/connectors`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getEvents', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/events`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroup', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsResetedRunnerRegisterToken: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsResetedRunnerRegisterToken', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/runners/register_token/reseted`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunner: async (groupRef: string, runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsRunner', 'groupRef', groupRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('getGroupsRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/groups/{group_ref}/+/runners/{runner_uuid}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunnerRegisterToken: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsRunnerRegisterToken', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/runners/register_token`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunners: async (groupRef: string, page?: number, size?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsRunners', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/runners`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsVariable: async (groupRef: string, variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsVariable', 'groupRef', groupRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('getGroupsVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/groups/{group_ref}/+/variables/{variable_identifier}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsVariables: async (groupRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getGroupsVariables', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/variables`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers: async (groupRef: string, page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getMembers', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/members`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepos: async (groupRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getRepos', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/repos`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccounts: async (groupRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getServiceAccounts', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/service-accounts`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubGroups: async (groupRef: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('getSubGroups', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/groups`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupPatchInput} groupPatchInput Group update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroup: async (groupRef: string, groupPatchInput: GroupPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('patchGroup', 'groupRef', groupRef)
            // verify required parameter 'groupPatchInput' is not null or undefined
            assertParamExists('patchGroup', 'groupPatchInput', groupPatchInput)
            const localVarPath = `/groups/{group_ref}/+`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroupsRunner: async (groupRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('patchGroupsRunner', 'groupRef', groupRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('patchGroupsRunner', 'runnerUuid', runnerUuid)
            // verify required parameter 'runnerPatchInput' is not null or undefined
            assertParamExists('patchGroupsRunner', 'runnerPatchInput', runnerPatchInput)
            const localVarPath = `/groups/{group_ref}/+/runners/{runner_uuid}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroupsVariable: async (groupRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('patchGroupsVariable', 'groupRef', groupRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('patchGroupsVariable', 'variableIdentifier', variableIdentifier)
            // verify required parameter 'variablePatchInput' is not null or undefined
            assertParamExists('patchGroupsVariable', 'variablePatchInput', variablePatchInput)
            const localVarPath = `/groups/{group_ref}/+/variables/{variable_identifier}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variablePatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {GroupMemberUpdateInput} groupMemberUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMember: async (groupRef: string, userIdentifier: string, groupMemberUpdateInput: GroupMemberUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('patchMember', 'groupRef', groupRef)
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('patchMember', 'userIdentifier', userIdentifier)
            // verify required parameter 'groupMemberUpdateInput' is not null or undefined
            assertParamExists('patchMember', 'groupMemberUpdateInput', groupMemberUpdateInput)
            const localVarPath = `/groups/{group_ref}/+/members/{user_identifier}`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)))
                .replace(`{${"user_identifier"}}`, encodeURIComponent(String(userIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupMemberUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GroupCreateInput} groupCreateInput Group creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroup: async (groupCreateInput: GroupCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupCreateInput' is not null or undefined
            assertParamExists('postGroup', 'groupCreateInput', groupCreateInput)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsVariable: async (groupRef: string, variableCreateInput: VariableCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postGroupsVariable', 'groupRef', groupRef)
            // verify required parameter 'variableCreateInput' is not null or undefined
            assertParamExists('postGroupsVariable', 'variableCreateInput', variableCreateInput)
            const localVarPath = `/groups/{group_ref}/+/variables`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GroupImportInput} groupImportInput Group import request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImport: async (groupImportInput: GroupImportInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupImportInput' is not null or undefined
            assertParamExists('postImport', 'groupImportInput', groupImportInput)
            const localVarPath = `/groups/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupImportInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupImportReposInput} groupImportReposInput Group import repositories request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImportRepos: async (groupRef: string, groupImportReposInput: GroupImportReposInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postImportRepos', 'groupRef', groupRef)
            // verify required parameter 'groupImportReposInput' is not null or undefined
            assertParamExists('postImportRepos', 'groupImportReposInput', groupImportReposInput)
            const localVarPath = `/groups/{group_ref}/+/import`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupImportReposInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMemberAddInput} groupMemberAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMember: async (groupRef: string, groupMemberAddInput: GroupMemberAddInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postMember', 'groupRef', groupRef)
            // verify required parameter 'groupMemberAddInput' is not null or undefined
            assertParamExists('postMember', 'groupMemberAddInput', groupMemberAddInput)
            const localVarPath = `/groups/{group_ref}/+/members`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupMemberAddInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMoveInput} groupMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMove: async (groupRef: string, groupMoveInput: GroupMoveInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postMove', 'groupRef', groupRef)
            // verify required parameter 'groupMoveInput' is not null or undefined
            assertParamExists('postMove', 'groupMoveInput', groupMoveInput)
            const localVarPath = `/groups/{group_ref}/+/move`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupMoveInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPurge: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postPurge', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+/purge`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupRestoreInput} groupRestoreInput Group restore request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRestore: async (groupRef: string, groupRestoreInput: GroupRestoreInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('postRestore', 'groupRef', groupRef)
            // verify required parameter 'groupRestoreInput' is not null or undefined
            assertParamExists('postRestore', 'groupRestoreInput', groupRestoreInput)
            const localVarPath = `/groups/{group_ref}/+/restore`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupRestoreInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softDelete: async (groupRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupRef' is not null or undefined
            assertParamExists('softDelete', 'groupRef', groupRef)
            const localVarPath = `/groups/{group_ref}/+`
                .replace(`{${"group_ref"}}`, encodeURIComponent(String(groupRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupsRunner(groupRef, runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteGroupsRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupsVariable(groupRef, variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteGroupsVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(groupRef: string, userIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(groupRef, userIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectors(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectors(groupRef, page, size, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getConnectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsResetedRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsResetedRunnerRegisterToken(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsResetedRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsRunner(groupRef, runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsRunnerRegisterToken(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsRunners(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunnerCreator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsRunners(groupRef, page, size, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsRunners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsVariable(groupRef, variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsVariables(groupRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariableGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsVariables(groupRef, page, size, query, types, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupsVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembers(groupRef: string, page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MembershipUserGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembers(groupRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepos(groupRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoParent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepos(groupRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAccounts(groupRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAccounts(groupRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getServiceAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubGroups(groupRef: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubGroups(groupRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getSubGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupPatchInput} groupPatchInput Group update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchGroup(groupRef: string, groupPatchInput: GroupPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchGroup(groupRef, groupPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.patchGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchGroupsRunner(groupRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchGroupsRunner(groupRef, runnerUuid, runnerPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.patchGroupsRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchGroupsVariable(groupRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchGroupsVariable(groupRef, variableIdentifier, variablePatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.patchGroupsVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {GroupMemberUpdateInput} groupMemberUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMember(groupRef: string, userIdentifier: string, groupMemberUpdateInput: GroupMemberUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MembershipModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMember(groupRef, userIdentifier, groupMemberUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.patchMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GroupCreateInput} groupCreateInput Group creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGroup(groupCreateInput: GroupCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGroup(groupCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGroupsVariable(groupRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGroupsVariable(groupRef, variableCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postGroupsVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GroupImportInput} groupImportInput Group import request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImport(groupImportInput: GroupImportInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postImport(groupImportInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupImportReposInput} groupImportReposInput Group import repositories request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImportRepos(groupRef: string, groupImportReposInput: GroupImportReposInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupImportReposOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postImportRepos(groupRef, groupImportReposInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postImportRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMemberAddInput} groupMemberAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMember(groupRef: string, groupMemberAddInput: GroupMemberAddInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MembershipUserGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMember(groupRef, groupMemberAddInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMoveInput} groupMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMove(groupRef: string, groupMoveInput: GroupMoveInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMove(groupRef, groupMoveInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postMove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPurge(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPurge(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postPurge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupRestoreInput} groupRestoreInput Group restore request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRestore(groupRef: string, groupRestoreInput: GroupRestoreInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRestore(groupRef, groupRestoreInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.postRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async softDelete(groupRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.softDelete(groupRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.softDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroupsRunner(groupRef, runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroupsVariable(groupRef, variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(groupRef: string, userIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMember(groupRef, userIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConnectorModel>> {
            return localVarFp.getConnectors(groupRef, page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getEvents(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.getGroup(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsResetedRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getGroupsResetedRunnerRegisterToken(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.getGroupsRunner(groupRef, runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getGroupsRunnerRegisterToken(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsRunners(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunnerCreator>> {
            return localVarFp.getGroupsRunners(groupRef, page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.getGroupsVariable(groupRef, variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsVariables(groupRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariableGroup>> {
            return localVarFp.getGroupsVariables(groupRef, page, size, query, types, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers(groupRef: string, page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<MembershipUserGroup>> {
            return localVarFp.getMembers(groupRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepos(groupRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepoParent>> {
            return localVarFp.getRepos(groupRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccounts(groupRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserModel>> {
            return localVarFp.getServiceAccounts(groupRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubGroups(groupRef: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupModel>> {
            return localVarFp.getSubGroups(groupRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupPatchInput} groupPatchInput Group update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroup(groupRef: string, groupPatchInput: GroupPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.patchGroup(groupRef, groupPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroupsRunner(groupRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.patchGroupsRunner(groupRef, runnerUuid, runnerPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchGroupsVariable(groupRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.patchGroupsVariable(groupRef, variableIdentifier, variablePatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {string} userIdentifier 
         * @param {GroupMemberUpdateInput} groupMemberUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMember(groupRef: string, userIdentifier: string, groupMemberUpdateInput: GroupMemberUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<MembershipModel> {
            return localVarFp.patchMember(groupRef, userIdentifier, groupMemberUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GroupCreateInput} groupCreateInput Group creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroup(groupCreateInput: GroupCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.postGroup(groupCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsVariable(groupRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.postGroupsVariable(groupRef, variableCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GroupImportInput} groupImportInput Group import request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImport(groupImportInput: GroupImportInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.postImport(groupImportInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupImportReposInput} groupImportReposInput Group import repositories request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImportRepos(groupRef: string, groupImportReposInput: GroupImportReposInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupImportReposOutput> {
            return localVarFp.postImportRepos(groupRef, groupImportReposInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMemberAddInput} groupMemberAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMember(groupRef: string, groupMemberAddInput: GroupMemberAddInput, options?: RawAxiosRequestConfig): AxiosPromise<MembershipUserGroup> {
            return localVarFp.postMember(groupRef, groupMemberAddInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupMoveInput} groupMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMove(groupRef: string, groupMoveInput: GroupMoveInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.postMove(groupRef, groupMoveInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPurge(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postPurge(groupRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {GroupRestoreInput} groupRestoreInput Group restore request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRestore(groupRef: string, groupRestoreInput: GroupRestoreInput, options?: RawAxiosRequestConfig): AxiosPromise<GroupModel> {
            return localVarFp.postRestore(groupRef, groupRestoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupRef Group ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softDelete(groupRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.softDelete(groupRef, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupsRunner(groupRef, runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupsVariable(groupRef, variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} userIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteMember(groupRef: string, userIdentifier: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteMember(groupRef, userIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getConnectors(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getConnectors(groupRef, page, size, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getEvents(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getEvents(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroup(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroup(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupsResetedRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsResetedRunnerRegisterToken(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupsRunner(groupRef: string, runnerUuid: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsRunner(groupRef, runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupsRunnerRegisterToken(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsRunnerRegisterToken(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupsRunners(groupRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsRunners(groupRef, page, size, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupsVariable(groupRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsVariable(groupRef, variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<VariableType>} [types] 
     * @param {VariableSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupsVariables(groupRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupsVariables(groupRef, page, size, query, types, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {MembershipSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getMembers(groupRef: string, page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getMembers(groupRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getRepos(groupRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getRepos(groupRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {UserSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getServiceAccounts(groupRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getServiceAccounts(groupRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {GroupSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getSubGroups(groupRef: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getSubGroups(groupRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {GroupPatchInput} groupPatchInput Group update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public patchGroup(groupRef: string, groupPatchInput: GroupPatchInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).patchGroup(groupRef, groupPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} runnerUuid 
     * @param {RunnerPatchInput} runnerPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public patchGroupsRunner(groupRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).patchGroupsRunner(groupRef, runnerUuid, runnerPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} variableIdentifier 
     * @param {VariablePatchInput} variablePatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public patchGroupsVariable(groupRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).patchGroupsVariable(groupRef, variableIdentifier, variablePatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {string} userIdentifier 
     * @param {GroupMemberUpdateInput} groupMemberUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public patchMember(groupRef: string, userIdentifier: string, groupMemberUpdateInput: GroupMemberUpdateInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).patchMember(groupRef, userIdentifier, groupMemberUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GroupCreateInput} groupCreateInput Group creation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public postGroup(groupCreateInput: GroupCreateInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postGroup(groupCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {VariableCreateInput} variableCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public postGroupsVariable(groupRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postGroupsVariable(groupRef, variableCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GroupImportInput} groupImportInput Group import request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public postImport(groupImportInput: GroupImportInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postImport(groupImportInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {GroupImportReposInput} groupImportReposInput Group import repositories request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public postImportRepos(groupRef: string, groupImportReposInput: GroupImportReposInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postImportRepos(groupRef, groupImportReposInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {GroupMemberAddInput} groupMemberAddInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public postMember(groupRef: string, groupMemberAddInput: GroupMemberAddInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postMember(groupRef, groupMemberAddInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {GroupMoveInput} groupMoveInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public postMove(groupRef: string, groupMoveInput: GroupMoveInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postMove(groupRef, groupMoveInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public postPurge(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postPurge(groupRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {GroupRestoreInput} groupRestoreInput Group restore request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public postRestore(groupRef: string, groupRestoreInput: GroupRestoreInput, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).postRestore(groupRef, groupRestoreInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupRef Group ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public softDelete(groupRef: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).softDelete(groupRef, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KeywordSearchApi - axios parameter creator
 * @export
 */
export const KeywordSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeywordSearchApi - functional programming interface
 * @export
 */
export const KeywordSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeywordSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordSearchApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KeywordSearchApi - factory interface
 * @export
 */
export const KeywordSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeywordSearchApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.search(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeywordSearchApi - object-oriented interface
 * @export
 * @class KeywordSearchApi
 * @extends {BaseAPI}
 */
export class KeywordSearchApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordSearchApi
     */
    public search(options?: RawAxiosRequestConfig) {
        return KeywordSearchApiFp(this.configuration).search(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PullRequestApi - axios parameter creator
 * @export
 */
export const PullRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment: async (repoRef: string, pullreqNumber: number, pullreqCommentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteComment', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('deleteComment', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqCommentId' is not null or undefined
            assertParamExists('deleteComment', 'pullreqCommentId', pullreqCommentId)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/comments/{pullreq_comment_id}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)))
                .replace(`{${"pullreq_comment_id"}}`, encodeURIComponent(String(pullreqCommentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileView: async (repoRef: string, pullreqNumber: number, path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteFileView', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('deleteFileView', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('deleteFileView', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/file-views/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqReviewerId Pull request reviewer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewer: async (repoRef: string, pullreqNumber: number, pullreqReviewerId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteReviewer', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('deleteReviewer', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqReviewerId' is not null or undefined
            assertParamExists('deleteReviewer', 'pullreqReviewerId', pullreqReviewerId)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/reviewers/{pullreq_reviewer_id}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)))
                .replace(`{${"pullreq_reviewer_id"}}`, encodeURIComponent(String(pullreqReviewerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {number} [after] 
         * @param {number} [before] 
         * @param {Array<PullreqActivityType>} [types] 
         * @param {Array<PullreqActivityKind>} [kinds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities: async (repoRef: string, pullreqNumber: number, page?: number, size?: number, query?: string, after?: number, before?: number, types?: Array<PullreqActivityType>, kinds?: Array<PullreqActivityKind>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getActivities', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getActivities', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/activities`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (kinds) {
                localVarQueryParameter['kinds'] = kinds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeOwners: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCodeOwners', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getCodeOwners', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/codeowners`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileViews: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getFileViews', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getFileViews', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/file-views`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getMetadata', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getMetadata', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/metadata`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequestChecks: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getPullRequestChecks', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getPullRequestChecks', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/checks`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequestCommits: async (repoRef: string, pullreqNumber: number, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getPullRequestCommits', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getPullRequestCommits', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/commits`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullreq: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getPullreq', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getPullreq', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<number>} [createdBy] 
         * @param {string} [sourceRepoRef] 
         * @param {string} [sourceBranch] 
         * @param {string} [targetBranch] 
         * @param {Array<PullreqState>} [states] 
         * @param {PullreqSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {number} [createdGt] 
         * @param {number} [createdLt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullreqs: async (repoRef: string, page?: number, size?: number, query?: string, createdBy?: Array<number>, sourceRepoRef?: string, sourceBranch?: string, targetBranch?: string, states?: Array<PullreqState>, sort?: PullreqSort, order?: OrderOption, createdGt?: number, createdLt?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getPullreqs', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/pullreq`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (createdBy) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (sourceRepoRef !== undefined) {
                localVarQueryParameter['source_repo_ref'] = sourceRepoRef;
            }

            if (sourceBranch !== undefined) {
                localVarQueryParameter['source_branch'] = sourceBranch;
            }

            if (targetBranch !== undefined) {
                localVarQueryParameter['target_branch'] = targetBranch;
            }

            if (states) {
                localVarQueryParameter['states'] = states;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (createdGt !== undefined) {
                localVarQueryParameter['created_gt'] = createdGt;
            }

            if (createdLt !== undefined) {
                localVarQueryParameter['created_lt'] = createdLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewers: async (repoRef: string, pullreqNumber: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getReviewers', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('getReviewers', 'pullreqNumber', pullreqNumber)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/reviewers`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentUpdateInput} pullreqCommentUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchComment: async (repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentUpdateInput: PullreqCommentUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchComment', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('patchComment', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqCommentId' is not null or undefined
            assertParamExists('patchComment', 'pullreqCommentId', pullreqCommentId)
            // verify required parameter 'pullreqCommentUpdateInput' is not null or undefined
            assertParamExists('patchComment', 'pullreqCommentUpdateInput', pullreqCommentUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/comments/{pullreq_comment_id}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)))
                .replace(`{${"pullreq_comment_id"}}`, encodeURIComponent(String(pullreqCommentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqCommentUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqUpdateInput} pullreqUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPullreq: async (repoRef: string, pullreqNumber: number, pullreqUpdateInput: PullreqUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchPullreq', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('patchPullreq', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqUpdateInput' is not null or undefined
            assertParamExists('patchPullreq', 'pullreqUpdateInput', pullreqUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqApplySuggestionsInput} pullreqApplySuggestionsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplySuggestions: async (repoRef: string, pullreqNumber: number, pullreqApplySuggestionsInput: PullreqApplySuggestionsInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postApplySuggestions', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postApplySuggestions', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqApplySuggestionsInput' is not null or undefined
            assertParamExists('postApplySuggestions', 'pullreqApplySuggestionsInput', pullreqApplySuggestionsInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/comments/apply-suggestions`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqApplySuggestionsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqCommentCreateInput} pullreqCommentCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment: async (repoRef: string, pullreqNumber: number, pullreqCommentCreateInput: PullreqCommentCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postComment', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postComment', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqCommentCreateInput' is not null or undefined
            assertParamExists('postComment', 'pullreqCommentCreateInput', pullreqCommentCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/comments`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqCommentCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiff: async (repoRef: string, pullreqNumber: number, commitDiffFile: Array<CommitDiffFile>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postDiff', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postDiff', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'commitDiffFile' is not null or undefined
            assertParamExists('postDiff', 'commitDiffFile', commitDiffFile)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/diff`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commitDiffFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqMergeInput} pullreqMergeInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMerge: async (repoRef: string, pullreqNumber: number, pullreqMergeInput: PullreqMergeInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postMerge', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postMerge', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqMergeInput' is not null or undefined
            assertParamExists('postMerge', 'pullreqMergeInput', pullreqMergeInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/merge`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqMergeInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {PullreqCreateInput} pullreqCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPullreq: async (repoRef: string, pullreqCreateInput: PullreqCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postPullreq', 'repoRef', repoRef)
            // verify required parameter 'pullreqCreateInput' is not null or undefined
            assertParamExists('postPullreq', 'pullreqCreateInput', pullreqCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewSubmitInput} pullreqReviewSubmitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReviews: async (repoRef: string, pullreqNumber: number, pullreqReviewSubmitInput: PullreqReviewSubmitInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postReviews', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postReviews', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqReviewSubmitInput' is not null or undefined
            assertParamExists('postReviews', 'pullreqReviewSubmitInput', pullreqReviewSubmitInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/reviews`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqReviewSubmitInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqStateUpdateInput} pullreqStateUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postState: async (repoRef: string, pullreqNumber: number, pullreqStateUpdateInput: PullreqStateUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postState', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('postState', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqStateUpdateInput' is not null or undefined
            assertParamExists('postState', 'pullreqStateUpdateInput', pullreqStateUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/state`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqStateUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentStatusInput} pullreqCommentStatusInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCommentStatus: async (repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentStatusInput: PullreqCommentStatusInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('putCommentStatus', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('putCommentStatus', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqCommentId' is not null or undefined
            assertParamExists('putCommentStatus', 'pullreqCommentId', pullreqCommentId)
            // verify required parameter 'pullreqCommentStatusInput' is not null or undefined
            assertParamExists('putCommentStatus', 'pullreqCommentStatusInput', pullreqCommentStatusInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/comments/{pullreq_comment_id}/status`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)))
                .replace(`{${"pullreq_comment_id"}}`, encodeURIComponent(String(pullreqCommentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqCommentStatusInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqFileViewCreateInput} pullreqFileViewCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileViews: async (repoRef: string, pullreqNumber: number, pullreqFileViewCreateInput: PullreqFileViewCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('putFileViews', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('putFileViews', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqFileViewCreateInput' is not null or undefined
            assertParamExists('putFileViews', 'pullreqFileViewCreateInput', pullreqFileViewCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/file-views`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqFileViewCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewerAddInput} pullreqReviewerAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putReviewer: async (repoRef: string, pullreqNumber: number, pullreqReviewerAddInput: PullreqReviewerAddInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('putReviewer', 'repoRef', repoRef)
            // verify required parameter 'pullreqNumber' is not null or undefined
            assertParamExists('putReviewer', 'pullreqNumber', pullreqNumber)
            // verify required parameter 'pullreqReviewerAddInput' is not null or undefined
            assertParamExists('putReviewer', 'pullreqReviewerAddInput', pullreqReviewerAddInput)
            const localVarPath = `/repos/{repo_ref}/+/pullreq/{pullreq_number}/reviewers`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"pullreq_number"}}`, encodeURIComponent(String(pullreqNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pullreqReviewerAddInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PullRequestApi - functional programming interface
 * @export
 */
export const PullRequestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PullRequestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(repoRef, pullreqNumber, pullreqCommentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.deleteComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileView(repoRef: string, pullreqNumber: number, path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileView(repoRef, pullreqNumber, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.deleteFileView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqReviewerId Pull request reviewer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReviewer(repoRef, pullreqNumber, pullreqReviewerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.deleteReviewer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {number} [after] 
         * @param {number} [before] 
         * @param {Array<PullreqActivityType>} [types] 
         * @param {Array<PullreqActivityKind>} [kinds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivities(repoRef: string, pullreqNumber: number, page?: number, size?: number, query?: string, after?: number, before?: number, types?: Array<PullreqActivityType>, kinds?: Array<PullreqActivityKind>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullreqActivityRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(repoRef, pullreqNumber, page, size, query, after, before, types, kinds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodeOwners(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeOwnerEvaluation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodeOwners(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getCodeOwners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileViews(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullreqFileViewModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileViews(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getFileViews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqWithDiffStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullRequestChecks(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqChecksOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullRequestChecks(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getPullRequestChecks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullRequestCommits(repoRef: string, pullreqNumber: number, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Commit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullRequestCommits(repoRef, pullreqNumber, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getPullRequestCommits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullreq(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqWithDiffStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullreq(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getPullreq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<number>} [createdBy] 
         * @param {string} [sourceRepoRef] 
         * @param {string} [sourceBranch] 
         * @param {string} [targetBranch] 
         * @param {Array<PullreqState>} [states] 
         * @param {PullreqSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {number} [createdGt] 
         * @param {number} [createdLt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPullreqs(repoRef: string, page?: number, size?: number, query?: string, createdBy?: Array<number>, sourceRepoRef?: string, sourceBranch?: string, targetBranch?: string, states?: Array<PullreqState>, sort?: PullreqSort, order?: OrderOption, createdGt?: number, createdLt?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullreqWithDiffStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPullreqs(repoRef, page, size, query, createdBy, sourceRepoRef, sourceBranch, targetBranch, states, sort, order, createdGt, createdLt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getPullreqs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewers(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullreqReviewerUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewers(repoRef, pullreqNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.getReviewers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentUpdateInput} pullreqCommentUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentUpdateInput: PullreqCommentUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqActivityModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchComment(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.patchComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqUpdateInput} pullreqUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchPullreq(repoRef: string, pullreqNumber: number, pullreqUpdateInput: PullreqUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPullreq(repoRef, pullreqNumber, pullreqUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.patchPullreq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqApplySuggestionsInput} pullreqApplySuggestionsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApplySuggestions(repoRef: string, pullreqNumber: number, pullreqApplySuggestionsInput: PullreqApplySuggestionsInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqApplySuggestionsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApplySuggestions(repoRef, pullreqNumber, pullreqApplySuggestionsInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postApplySuggestions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqCommentCreateInput} pullreqCommentCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postComment(repoRef: string, pullreqNumber: number, pullreqCommentCreateInput: PullreqCommentCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqActivityModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postComment(repoRef, pullreqNumber, pullreqCommentCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDiff(repoRef: string, pullreqNumber: number, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDiff(repoRef, pullreqNumber, commitDiffFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postDiff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqMergeInput} pullreqMergeInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMerge(repoRef: string, pullreqNumber: number, pullreqMergeInput: PullreqMergeInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqMergeOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMerge(repoRef, pullreqNumber, pullreqMergeInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postMerge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {PullreqCreateInput} pullreqCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPullreq(repoRef: string, pullreqCreateInput: PullreqCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPullreq(repoRef, pullreqCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postPullreq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewSubmitInput} pullreqReviewSubmitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postReviews(repoRef: string, pullreqNumber: number, pullreqReviewSubmitInput: PullreqReviewSubmitInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqReviewModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postReviews(repoRef, pullreqNumber, pullreqReviewSubmitInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postReviews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqStateUpdateInput} pullreqStateUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postState(repoRef: string, pullreqNumber: number, pullreqStateUpdateInput: PullreqStateUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postState(repoRef, pullreqNumber, pullreqStateUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.postState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentStatusInput} pullreqCommentStatusInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCommentStatus(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentStatusInput: PullreqCommentStatusInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqActivityModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCommentStatus(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentStatusInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.putCommentStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqFileViewCreateInput} pullreqFileViewCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFileViews(repoRef: string, pullreqNumber: number, pullreqFileViewCreateInput: PullreqFileViewCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqFileViewModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFileViews(repoRef, pullreqNumber, pullreqFileViewCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.putFileViews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewerAddInput} pullreqReviewerAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerAddInput: PullreqReviewerAddInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullreqReviewerUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putReviewer(repoRef, pullreqNumber, pullreqReviewerAddInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PullRequestApi.putReviewer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PullRequestApi - factory interface
 * @export
 */
export const PullRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PullRequestApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteComment(repoRef, pullreqNumber, pullreqCommentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileView(repoRef: string, pullreqNumber: number, path: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFileView(repoRef, pullreqNumber, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqReviewerId Pull request reviewer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteReviewer(repoRef, pullreqNumber, pullreqReviewerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {number} [after] 
         * @param {number} [before] 
         * @param {Array<PullreqActivityType>} [types] 
         * @param {Array<PullreqActivityKind>} [kinds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(repoRef: string, pullreqNumber: number, page?: number, size?: number, query?: string, after?: number, before?: number, types?: Array<PullreqActivityType>, kinds?: Array<PullreqActivityKind>, options?: RawAxiosRequestConfig): AxiosPromise<Array<PullreqActivityRelations>> {
            return localVarFp.getActivities(repoRef, pullreqNumber, page, size, query, after, before, types, kinds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeOwners(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<CodeOwnerEvaluation> {
            return localVarFp.getCodeOwners(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileViews(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PullreqFileViewModel>> {
            return localVarFp.getFileViews(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<PullreqWithDiffStats> {
            return localVarFp.getMetadata(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequestChecks(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<PullreqChecksOutput> {
            return localVarFp.getPullRequestChecks(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullRequestCommits(repoRef: string, pullreqNumber: number, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Commit>> {
            return localVarFp.getPullRequestCommits(repoRef, pullreqNumber, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullreq(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<PullreqWithDiffStats> {
            return localVarFp.getPullreq(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<number>} [createdBy] 
         * @param {string} [sourceRepoRef] 
         * @param {string} [sourceBranch] 
         * @param {string} [targetBranch] 
         * @param {Array<PullreqState>} [states] 
         * @param {PullreqSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {number} [createdGt] 
         * @param {number} [createdLt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPullreqs(repoRef: string, page?: number, size?: number, query?: string, createdBy?: Array<number>, sourceRepoRef?: string, sourceBranch?: string, targetBranch?: string, states?: Array<PullreqState>, sort?: PullreqSort, order?: OrderOption, createdGt?: number, createdLt?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PullreqWithDiffStats>> {
            return localVarFp.getPullreqs(repoRef, page, size, query, createdBy, sourceRepoRef, sourceBranch, targetBranch, states, sort, order, createdGt, createdLt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewers(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PullreqReviewerUser>> {
            return localVarFp.getReviewers(repoRef, pullreqNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentUpdateInput} pullreqCommentUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentUpdateInput: PullreqCommentUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqActivityModel> {
            return localVarFp.patchComment(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqUpdateInput} pullreqUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPullreq(repoRef: string, pullreqNumber: number, pullreqUpdateInput: PullreqUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqModel> {
            return localVarFp.patchPullreq(repoRef, pullreqNumber, pullreqUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqApplySuggestionsInput} pullreqApplySuggestionsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplySuggestions(repoRef: string, pullreqNumber: number, pullreqApplySuggestionsInput: PullreqApplySuggestionsInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqApplySuggestionsOutput> {
            return localVarFp.postApplySuggestions(repoRef, pullreqNumber, pullreqApplySuggestionsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqCommentCreateInput} pullreqCommentCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment(repoRef: string, pullreqNumber: number, pullreqCommentCreateInput: PullreqCommentCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqActivityModel> {
            return localVarFp.postComment(repoRef, pullreqNumber, pullreqCommentCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiff(repoRef: string, pullreqNumber: number, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.postDiff(repoRef, pullreqNumber, commitDiffFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqMergeInput} pullreqMergeInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMerge(repoRef: string, pullreqNumber: number, pullreqMergeInput: PullreqMergeInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqMergeOutput> {
            return localVarFp.postMerge(repoRef, pullreqNumber, pullreqMergeInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {PullreqCreateInput} pullreqCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPullreq(repoRef: string, pullreqCreateInput: PullreqCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqModel> {
            return localVarFp.postPullreq(repoRef, pullreqCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewSubmitInput} pullreqReviewSubmitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postReviews(repoRef: string, pullreqNumber: number, pullreqReviewSubmitInput: PullreqReviewSubmitInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqReviewModel> {
            return localVarFp.postReviews(repoRef, pullreqNumber, pullreqReviewSubmitInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqStateUpdateInput} pullreqStateUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postState(repoRef: string, pullreqNumber: number, pullreqStateUpdateInput: PullreqStateUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqModel> {
            return localVarFp.postState(repoRef, pullreqNumber, pullreqStateUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {number} pullreqCommentId Pull request comment id
         * @param {PullreqCommentStatusInput} pullreqCommentStatusInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCommentStatus(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentStatusInput: PullreqCommentStatusInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqActivityModel> {
            return localVarFp.putCommentStatus(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentStatusInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqFileViewCreateInput} pullreqFileViewCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileViews(repoRef: string, pullreqNumber: number, pullreqFileViewCreateInput: PullreqFileViewCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqFileViewModel> {
            return localVarFp.putFileViews(repoRef, pullreqNumber, pullreqFileViewCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} pullreqNumber Pull request number
         * @param {PullreqReviewerAddInput} pullreqReviewerAddInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerAddInput: PullreqReviewerAddInput, options?: RawAxiosRequestConfig): AxiosPromise<PullreqReviewerUser> {
            return localVarFp.putReviewer(repoRef, pullreqNumber, pullreqReviewerAddInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PullRequestApi - object-oriented interface
 * @export
 * @class PullRequestApi
 * @extends {BaseAPI}
 */
export class PullRequestApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} pullreqCommentId Pull request comment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public deleteComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).deleteComment(repoRef, pullreqNumber, pullreqCommentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public deleteFileView(repoRef: string, pullreqNumber: number, path: string, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).deleteFileView(repoRef, pullreqNumber, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} pullreqReviewerId Pull request reviewer id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public deleteReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerId: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).deleteReviewer(repoRef, pullreqNumber, pullreqReviewerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {number} [after] 
     * @param {number} [before] 
     * @param {Array<PullreqActivityType>} [types] 
     * @param {Array<PullreqActivityKind>} [kinds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public getActivities(repoRef: string, pullreqNumber: number, page?: number, size?: number, query?: string, after?: number, before?: number, types?: Array<PullreqActivityType>, kinds?: Array<PullreqActivityKind>, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getActivities(repoRef, pullreqNumber, page, size, query, after, before, types, kinds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public getCodeOwners(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getCodeOwners(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public getFileViews(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getFileViews(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public getMetadata(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getMetadata(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public getPullRequestChecks(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getPullRequestChecks(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public getPullRequestCommits(repoRef: string, pullreqNumber: number, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getPullRequestCommits(repoRef, pullreqNumber, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public getPullreq(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getPullreq(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<number>} [createdBy] 
     * @param {string} [sourceRepoRef] 
     * @param {string} [sourceBranch] 
     * @param {string} [targetBranch] 
     * @param {Array<PullreqState>} [states] 
     * @param {PullreqSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {number} [createdGt] 
     * @param {number} [createdLt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public getPullreqs(repoRef: string, page?: number, size?: number, query?: string, createdBy?: Array<number>, sourceRepoRef?: string, sourceBranch?: string, targetBranch?: string, states?: Array<PullreqState>, sort?: PullreqSort, order?: OrderOption, createdGt?: number, createdLt?: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getPullreqs(repoRef, page, size, query, createdBy, sourceRepoRef, sourceBranch, targetBranch, states, sort, order, createdGt, createdLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public getReviewers(repoRef: string, pullreqNumber: number, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).getReviewers(repoRef, pullreqNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} pullreqCommentId Pull request comment id
     * @param {PullreqCommentUpdateInput} pullreqCommentUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public patchComment(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentUpdateInput: PullreqCommentUpdateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).patchComment(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqUpdateInput} pullreqUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public patchPullreq(repoRef: string, pullreqNumber: number, pullreqUpdateInput: PullreqUpdateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).patchPullreq(repoRef, pullreqNumber, pullreqUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqApplySuggestionsInput} pullreqApplySuggestionsInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public postApplySuggestions(repoRef: string, pullreqNumber: number, pullreqApplySuggestionsInput: PullreqApplySuggestionsInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postApplySuggestions(repoRef, pullreqNumber, pullreqApplySuggestionsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqCommentCreateInput} pullreqCommentCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public postComment(repoRef: string, pullreqNumber: number, pullreqCommentCreateInput: PullreqCommentCreateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postComment(repoRef, pullreqNumber, pullreqCommentCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {Array<CommitDiffFile>} commitDiffFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public postDiff(repoRef: string, pullreqNumber: number, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postDiff(repoRef, pullreqNumber, commitDiffFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqMergeInput} pullreqMergeInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public postMerge(repoRef: string, pullreqNumber: number, pullreqMergeInput: PullreqMergeInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postMerge(repoRef, pullreqNumber, pullreqMergeInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {PullreqCreateInput} pullreqCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public postPullreq(repoRef: string, pullreqCreateInput: PullreqCreateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postPullreq(repoRef, pullreqCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqReviewSubmitInput} pullreqReviewSubmitInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public postReviews(repoRef: string, pullreqNumber: number, pullreqReviewSubmitInput: PullreqReviewSubmitInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postReviews(repoRef, pullreqNumber, pullreqReviewSubmitInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqStateUpdateInput} pullreqStateUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public postState(repoRef: string, pullreqNumber: number, pullreqStateUpdateInput: PullreqStateUpdateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).postState(repoRef, pullreqNumber, pullreqStateUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {number} pullreqCommentId Pull request comment id
     * @param {PullreqCommentStatusInput} pullreqCommentStatusInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public putCommentStatus(repoRef: string, pullreqNumber: number, pullreqCommentId: number, pullreqCommentStatusInput: PullreqCommentStatusInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).putCommentStatus(repoRef, pullreqNumber, pullreqCommentId, pullreqCommentStatusInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqFileViewCreateInput} pullreqFileViewCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public putFileViews(repoRef: string, pullreqNumber: number, pullreqFileViewCreateInput: PullreqFileViewCreateInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).putFileViews(repoRef, pullreqNumber, pullreqFileViewCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} pullreqNumber Pull request number
     * @param {PullreqReviewerAddInput} pullreqReviewerAddInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullRequestApi
     */
    public putReviewer(repoRef: string, pullreqNumber: number, pullreqReviewerAddInput: PullreqReviewerAddInput, options?: RawAxiosRequestConfig) {
        return PullRequestApiFp(this.configuration).putReviewer(repoRef, pullreqNumber, pullreqReviewerAddInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReleaseUploadApi - axios parameter creator
 * @export
 */
export const ReleaseUploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUpload: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteUpload', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('deleteUpload', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getAssets', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('getAssets', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases/assets/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getDownload', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('getDownload', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/download/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestore: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRestore', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('getRestore', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headOffset: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('headOffset', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchChunks: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchChunks', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('patchChunks', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpload: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postUpload', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('postUpload', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/uploads/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReleaseUploadApi - functional programming interface
 * @export
 */
export const ReleaseUploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReleaseUploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUpload(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.deleteUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssets(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssets(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.getAssets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownload(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.getDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRestore(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRestore(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.getRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headOffset(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.headOffset(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.headOffset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchChunks(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchChunks(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.patchChunks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUpload(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReleaseUploadApi.postUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReleaseUploadApi - factory interface
 * @export
 */
export const ReleaseUploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReleaseUploadApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUpload(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getAssets(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getDownload(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestore(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getRestore(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headOffset(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.headOffset(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchChunks(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.patchChunks(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postUpload(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReleaseUploadApi - object-oriented interface
 * @export
 * @class ReleaseUploadApi
 * @extends {BaseAPI}
 */
export class ReleaseUploadApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseUploadApi
     */
    public deleteUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).deleteUpload(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseUploadApi
     */
    public getAssets(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).getAssets(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseUploadApi
     */
    public getDownload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).getDownload(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseUploadApi
     */
    public getRestore(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).getRestore(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseUploadApi
     */
    public headOffset(repoRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).headOffset(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseUploadApi
     */
    public patchChunks(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).patchChunks(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReleaseUploadApi
     */
    public postUpload(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return ReleaseUploadApiFp(this.configuration).postUpload(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {CommitFilesInput} commitFilesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitFiles: async (repoRef: string, commitFilesInput: CommitFilesInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('commitFiles', 'repoRef', repoRef)
            // verify required parameter 'commitFilesInput' is not null or undefined
            assertParamExists('commitFiles', 'commitFilesInput', commitFilesInput)
            const localVarPath = `/repos/{repo_ref}/+/commits`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commitFilesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoCommitDivergencesInput} repoCommitDivergencesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsCalculateDivergence: async (repoRef: string, repoCommitDivergencesInput: RepoCommitDivergencesInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('commitsCalculateDivergence', 'repoRef', repoRef)
            // verify required parameter 'repoCommitDivergencesInput' is not null or undefined
            assertParamExists('commitsCalculateDivergence', 'repoCommitDivergencesInput', repoCommitDivergencesInput)
            const localVarPath = `/repos/{repo_ref}/+/commits/calculate-divergence`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoCommitDivergencesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch: async (repoRef: string, branchName: string, bypassRules?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteBranch', 'repoRef', repoRef)
            // verify required parameter 'branchName' is not null or undefined
            assertParamExists('deleteBranch', 'branchName', branchName)
            const localVarPath = `/repos/{repo_ref}/+/branches/{branch_name}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"branch_name"}}`, encodeURIComponent(String(branchName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (bypassRules !== undefined) {
                localVarQueryParameter['bypass_rules'] = bypassRules;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelease: async (repoRef: string, tagRef: string, bypassRules?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteRelease', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('deleteRelease', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (bypassRules !== undefined) {
                localVarQueryParameter['bypass_rules'] = bypassRules;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryRunner: async (repoRef: string, runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteRepositoryRunner', 'repoRef', repoRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('deleteRepositoryRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/repos/{repo_ref}/+/runners/{runner_uuid}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryVariable: async (repoRef: string, variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteRepositoryVariable', 'repoRef', repoRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('deleteRepositoryVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/variables/{variable_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (repoRef: string, tagName: string, bypassRules?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteTag', 'repoRef', repoRef)
            // verify required parameter 'tagName' is not null or undefined
            assertParamExists('deleteTag', 'tagName', tagName)
            const localVarPath = `/repos/{repo_ref}/+/tags/{tag_name}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_name"}}`, encodeURIComponent(String(tagName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (bypassRules !== undefined) {
                localVarQueryParameter['bypass_rules'] = bypassRules;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {GeneralSettings} generalSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalUpdate: async (repoRef: string, generalSettings: GeneralSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('generalUpdate', 'repoRef', repoRef)
            // verify required parameter 'generalSettings' is not null or undefined
            assertParamExists('generalUpdate', 'generalSettings', generalSettings)
            const localVarPath = `/repos/{repo_ref}/+/settings/general`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generalSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} archiveRef 
         * @param {string} [prefix] 
         * @param {ArchiveAttribute} [attributes] 
         * @param {Array<string>} [paths] 
         * @param {number} [timestamp] 
         * @param {number} [compression] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchive: async (repoRef: string, archiveRef: string, prefix?: string, attributes?: ArchiveAttribute, paths?: Array<string>, timestamp?: number, compression?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getArchive', 'repoRef', repoRef)
            // verify required parameter 'archiveRef' is not null or undefined
            assertParamExists('getArchive', 'archiveRef', archiveRef)
            const localVarPath = `/repos/{repo_ref}/+/archive/{archive_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"archive_ref"}}`, encodeURIComponent(String(archiveRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = attributes;
            }

            if (paths) {
                localVarQueryParameter['paths'] = paths;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (compression !== undefined) {
                localVarQueryParameter['compression'] = compression;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] The git reference (branch / tag / commitID) that will be used to retrieve the data. If no value is provided the default branch of the repository is used.         Default value : {Repository Default Branch}
         * @param {number} [lineFrom] 
         * @param {number} [lineTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlame: async (repoRef: string, path: string, gitRef?: string, lineFrom?: number, lineTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getBlame', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getBlame', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/blame/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }

            if (lineFrom !== undefined) {
                localVarQueryParameter['line_from'] = lineFrom;
            }

            if (lineTo !== undefined) {
                localVarQueryParameter['line_to'] = lineTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranch: async (repoRef: string, branchName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getBranch', 'repoRef', repoRef)
            // verify required parameter 'branchName' is not null or undefined
            assertParamExists('getBranch', 'branchName', branchName)
            const localVarPath = `/repos/{repo_ref}/+/branches/{branch_name}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"branch_name"}}`, encodeURIComponent(String(branchName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranches: async (repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getBranches', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/branches`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (includeCommit !== undefined) {
                localVarQueryParameter['include_commit'] = includeCommit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeownersValidate: async (repoRef: string, gitRef?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCodeownersValidate', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/codeowners/validate`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommit: async (repoRef: string, commitSha: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCommit', 'repoRef', repoRef)
            // verify required parameter 'commitSha' is not null or undefined
            assertParamExists('getCommit', 'commitSha', commitSha)
            const localVarPath = `/repos/{repo_ref}/+/commits/{commit_sha}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"commit_sha"}}`, encodeURIComponent(String(commitSha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitDiff: async (repoRef: string, commitSha: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCommitDiff', 'repoRef', repoRef)
            // verify required parameter 'commitSha' is not null or undefined
            assertParamExists('getCommitDiff', 'commitSha', commitSha)
            const localVarPath = `/repos/{repo_ref}/+/commits/{commit_sha}/diff`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"commit_sha"}}`, encodeURIComponent(String(commitSha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {string} filePath 
         * @param {string} hunkHeader 
         * @param {boolean} expandUp 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitFileContent: async (repoRef: string, commitSha: string, filePath: string, hunkHeader: string, expandUp: boolean, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCommitFileContent', 'repoRef', repoRef)
            // verify required parameter 'commitSha' is not null or undefined
            assertParamExists('getCommitFileContent', 'commitSha', commitSha)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getCommitFileContent', 'filePath', filePath)
            // verify required parameter 'hunkHeader' is not null or undefined
            assertParamExists('getCommitFileContent', 'hunkHeader', hunkHeader)
            // verify required parameter 'expandUp' is not null or undefined
            assertParamExists('getCommitFileContent', 'expandUp', expandUp)
            const localVarPath = `/repos/{repo_ref}/+/commits/{commit_sha}/content`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"commit_sha"}}`, encodeURIComponent(String(commitSha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['file_path'] = filePath;
            }

            if (hunkHeader !== undefined) {
                localVarQueryParameter['hunk_header'] = hunkHeader;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (expandUp !== undefined) {
                localVarQueryParameter['expand_up'] = expandUp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [after] 
         * @param {string} [path] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {string} [author] 
         * @param {boolean} [includeStats] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommits: async (repoRef: string, gitRef?: string, page?: number, size?: number, after?: string, path?: string, since?: number, until?: number, author?: string, includeStats?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getCommits', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/commits`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (includeStats !== undefined) {
                localVarQueryParameter['include_stats'] = includeStats;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent: async (repoRef: string, path: string, gitRef?: string, includeCommit?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getContent', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getContent', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/content/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }

            if (includeCommit !== undefined) {
                localVarQueryParameter['include_commit'] = includeCommit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContributors: async (repoRef: string, gitRef?: string, since?: number, until?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getContributors', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/contributors`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiffStats: async (repoRef: string, path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getDiffStats', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getDiffStats', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/diff-stats/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiffs: async (repoRef: string, path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getDiffs', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getDiffs', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/diff/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForks: async (repoRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getForks', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/forks`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneral: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getGeneral', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/settings/general`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHasStarred: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getHasStarred', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/stars/has_starred`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportProgress: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getImportProgress', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/import-progress`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {boolean} [includeDirectories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaths: async (repoRef: string, gitRef?: string, includeDirectories?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getPaths', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/paths`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }

            if (includeDirectories !== undefined) {
                localVarQueryParameter['include_directories'] = includeDirectories;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaw: async (repoRef: string, path: string, gitRef?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRaw', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getRaw', 'path', path)
            const localVarPath = `/repos/{repo_ref}/+/raw/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelease: async (repoRef: string, tagRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRelease', 'repoRef', repoRef)
            // verify required parameter 'tagRef' is not null or undefined
            assertParamExists('getRelease', 'tagRef', tagRef)
            const localVarPath = `/repos/{repo_ref}/+/releases/{tag_ref}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"tag_ref"}}`, encodeURIComponent(String(tagRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {ReleaseSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleases: async (repoRef: string, page?: number, size?: number, query?: string, sort?: ReleaseSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getReleases', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/releases`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepo: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepo', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryResetedRunnerRegisterToken: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryResetedRunnerRegisterToken', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/runners/register_token/reseted`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunner: async (repoRef: string, runnerUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryRunner', 'repoRef', repoRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('getRepositoryRunner', 'runnerUuid', runnerUuid)
            const localVarPath = `/repos/{repo_ref}/+/runners/{runner_uuid}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunnerRegisterToken: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryRunnerRegisterToken', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/runners/register_token`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunners: async (repoRef: string, page?: number, size?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryRunners', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/runners`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryServiceAccounts: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryServiceAccounts', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/service-accounts`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryStats: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryStats', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/stats`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryVariable: async (repoRef: string, variableIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryVariable', 'repoRef', repoRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('getRepositoryVariable', 'variableIdentifier', variableIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/variables/{variable_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryVariables: async (repoRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRepositoryVariables', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/variables`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getSecurity', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/settings/security`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStars: async (repoRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getStars', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/stars`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getTags', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/tags`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (includeCommit !== undefined) {
                localVarQueryParameter['include_commit'] = includeCommit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateInput} repoUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepo: async (repoRef: string, repoUpdateInput: RepoUpdateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchRepo', 'repoRef', repoRef)
            // verify required parameter 'repoUpdateInput' is not null or undefined
            assertParamExists('patchRepo', 'repoUpdateInput', repoUpdateInput)
            const localVarPath = `/repos/{repo_ref}/+`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepositoryRunner: async (repoRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchRepositoryRunner', 'repoRef', repoRef)
            // verify required parameter 'runnerUuid' is not null or undefined
            assertParamExists('patchRepositoryRunner', 'runnerUuid', runnerUuid)
            // verify required parameter 'runnerPatchInput' is not null or undefined
            assertParamExists('patchRepositoryRunner', 'runnerPatchInput', runnerPatchInput)
            const localVarPath = `/repos/{repo_ref}/+/runners/{runner_uuid}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"runner_uuid"}}`, encodeURIComponent(String(runnerUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepositoryVariable: async (repoRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchRepositoryVariable', 'repoRef', repoRef)
            // verify required parameter 'variableIdentifier' is not null or undefined
            assertParamExists('patchRepositoryVariable', 'variableIdentifier', variableIdentifier)
            // verify required parameter 'variablePatchInput' is not null or undefined
            assertParamExists('patchRepositoryVariable', 'variablePatchInput', variablePatchInput)
            const localVarPath = `/repos/{repo_ref}/+/variables/{variable_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"variable_identifier"}}`, encodeURIComponent(String(variableIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variablePatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {SecuritySettings} securitySettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSecurity: async (repoRef: string, securitySettings: SecuritySettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchSecurity', 'repoRef', repoRef)
            // verify required parameter 'securitySettings' is not null or undefined
            assertParamExists('patchSecurity', 'securitySettings', securitySettings)
            const localVarPath = `/repos/{repo_ref}/+/settings/security`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(securitySettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoStarsInput} repoStarsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStars: async (repoRef: string, repoStarsInput: RepoStarsInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchStars', 'repoRef', repoRef)
            // verify required parameter 'repoStarsInput' is not null or undefined
            assertParamExists('patchStars', 'repoStarsInput', repoStarsInput)
            const localVarPath = `/repos/{repo_ref}/+/stars`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoStarsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchCreateInput} branchCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBranch: async (repoRef: string, branchCreateInput: BranchCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postBranch', 'repoRef', repoRef)
            // verify required parameter 'branchCreateInput' is not null or undefined
            assertParamExists('postBranch', 'branchCreateInput', branchCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/branches`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(branchCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateDefaultBranchInput} repoUpdateDefaultBranchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDefaultBranch: async (repoRef: string, repoUpdateDefaultBranchInput: RepoUpdateDefaultBranchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postDefaultBranch', 'repoRef', repoRef)
            // verify required parameter 'repoUpdateDefaultBranchInput' is not null or undefined
            assertParamExists('postDefaultBranch', 'repoUpdateDefaultBranchInput', repoUpdateDefaultBranchInput)
            const localVarPath = `/repos/{repo_ref}/+/default-branch`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoUpdateDefaultBranchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} path2 
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiffs: async (repoRef: string, path: string, path2: string, commitDiffFile: Array<CommitDiffFile>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postDiffs', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('postDiffs', 'path', path)
            // verify required parameter 'path2' is not null or undefined
            assertParamExists('postDiffs', 'path2', path2)
            // verify required parameter 'commitDiffFile' is not null or undefined
            assertParamExists('postDiffs', 'commitDiffFile', commitDiffFile)
            const localVarPath = `/repos/{repo_ref}/+/diff/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commitDiffFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {RepoMergeCheckInput} repoMergeCheckInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMergeCheck: async (repoRef: string, path: string, repoMergeCheckInput: RepoMergeCheckInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postMergeCheck', 'repoRef', repoRef)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('postMergeCheck', 'path', path)
            // verify required parameter 'repoMergeCheckInput' is not null or undefined
            assertParamExists('postMergeCheck', 'repoMergeCheckInput', repoMergeCheckInput)
            const localVarPath = `/repos/{repo_ref}/+/merge-check/{path}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoMergeCheckInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {Array<string>} requestBody 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPathDetails: async (repoRef: string, requestBody: Array<string>, gitRef?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postPathDetails', 'repoRef', repoRef)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('postPathDetails', 'requestBody', requestBody)
            const localVarPath = `/repos/{repo_ref}/+/path-details`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (gitRef !== undefined) {
                localVarQueryParameter['git_ref'] = gitRef;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ReleaseCreateInput} releaseCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRelease: async (repoRef: string, releaseCreateInput: ReleaseCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRelease', 'repoRef', repoRef)
            // verify required parameter 'releaseCreateInput' is not null or undefined
            assertParamExists('postRelease', 'releaseCreateInput', releaseCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/releases`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(releaseCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RepoCreateInput} repoCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepo: async (repoCreateInput: RepoCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoCreateInput' is not null or undefined
            assertParamExists('postRepo', 'repoCreateInput', repoCreateInput)
            const localVarPath = `/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RepoImportInput} repoImportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryImport: async (repoImportInput: RepoImportInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoImportInput' is not null or undefined
            assertParamExists('postRepositoryImport', 'repoImportInput', repoImportInput)
            const localVarPath = `/repos/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoImportInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoMoveInput} repoMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryMove: async (repoRef: string, repoMoveInput: RepoMoveInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRepositoryMove', 'repoRef', repoRef)
            // verify required parameter 'repoMoveInput' is not null or undefined
            assertParamExists('postRepositoryMove', 'repoMoveInput', repoMoveInput)
            const localVarPath = `/repos/{repo_ref}/+/move`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoMoveInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryPurge: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRepositoryPurge', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/purge`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryVariable: async (repoRef: string, variableCreateInput: VariableCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRepositoryVariable', 'repoRef', repoRef)
            // verify required parameter 'variableCreateInput' is not null or undefined
            assertParamExists('postRepositoryVariable', 'variableCreateInput', variableCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/variables`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {TagCreateInput} tagCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTag: async (repoRef: string, tagCreateInput: TagCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postTag', 'repoRef', repoRef)
            // verify required parameter 'tagCreateInput' is not null or undefined
            assertParamExists('postTag', 'tagCreateInput', tagCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/tags`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchRenameInput} branchRenameInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameBranch: async (repoRef: string, branchRenameInput: BranchRenameInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('renameBranch', 'repoRef', repoRef)
            // verify required parameter 'branchRenameInput' is not null or undefined
            assertParamExists('renameBranch', 'branchRenameInput', branchRenameInput)
            const localVarPath = `/repos/{repo_ref}/+/branches`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(branchRenameInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoRestoreInput} repoRestoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoRestore: async (repoRef: string, repoRestoreInput: RepoRestoreInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('repoRestore', 'repoRef', repoRef)
            // verify required parameter 'repoRestoreInput' is not null or undefined
            assertParamExists('repoRestore', 'repoRestoreInput', repoRestoreInput)
            const localVarPath = `/repos/{repo_ref}/+/restore`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoRestoreInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softRepositoryDelete: async (repoRef: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('softRepositoryDelete', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {CommitFilesInput} commitFilesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitFiles(repoRef: string, commitFilesInput: CommitFilesInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitFilesOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commitFiles(repoRef, commitFilesInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.commitFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoCommitDivergencesInput} repoCommitDivergencesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitsCalculateDivergence(repoRef: string, repoCommitDivergencesInput: RepoCommitDivergencesInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitDivergence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commitsCalculateDivergence(repoRef, repoCommitDivergencesInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.commitsCalculateDivergence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBranch(repoRef: string, branchName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBranch(repoRef, branchName, bypassRules, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.deleteBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelease(repoRef: string, tagRef: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelease(repoRef, tagRef, bypassRules, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.deleteRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryRunner(repoRef, runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.deleteRepositoryRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepositoryVariable(repoRef, variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.deleteRepositoryVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(repoRef: string, tagName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(repoRef, tagName, bypassRules, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.deleteTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {GeneralSettings} generalSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generalUpdate(repoRef: string, generalSettings: GeneralSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generalUpdate(repoRef, generalSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.generalUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} archiveRef 
         * @param {string} [prefix] 
         * @param {ArchiveAttribute} [attributes] 
         * @param {Array<string>} [paths] 
         * @param {number} [timestamp] 
         * @param {number} [compression] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArchive(repoRef: string, archiveRef: string, prefix?: string, attributes?: ArchiveAttribute, paths?: Array<string>, timestamp?: number, compression?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArchive(repoRef, archiveRef, prefix, attributes, paths, timestamp, compression, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] The git reference (branch / tag / commitID) that will be used to retrieve the data. If no value is provided the default branch of the repository is used.         Default value : {Repository Default Branch}
         * @param {number} [lineFrom] 
         * @param {number} [lineTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlame(repoRef: string, path: string, gitRef?: string, lineFrom?: number, lineTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlamePart>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlame(repoRef, path, gitRef, lineFrom, lineTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getBlame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranch(repoRef: string, branchName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitBranch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranch(repoRef, branchName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranches(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitBranch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranches(repoRef, page, size, query, includeCommit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodeownersValidate(repoRef: string, gitRef?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeOwnersValidation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodeownersValidate(repoRef, gitRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getCodeownersValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommit(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommit(repoRef, commitSha, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getCommit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommitDiff(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommitDiff(repoRef, commitSha, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getCommitDiff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {string} filePath 
         * @param {string} hunkHeader 
         * @param {boolean} expandUp 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommitFileContent(repoRef: string, commitSha: string, filePath: string, hunkHeader: string, expandUp: boolean, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiffFileContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommitFileContent(repoRef, commitSha, filePath, hunkHeader, expandUp, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getCommitFileContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [after] 
         * @param {string} [path] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {string} [author] 
         * @param {boolean} [includeStats] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommits(repoRef: string, gitRef?: string, page?: number, size?: number, after?: string, path?: string, since?: number, until?: number, author?: string, includeStats?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitWithPathRenameDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommits(repoRef, gitRef, page, size, after, path, since, until, author, includeStats, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getCommits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContent(repoRef: string, path: string, gitRef?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoContentOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContent(repoRef, path, gitRef, includeCommit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContributors(repoRef: string, gitRef?: string, since?: number, until?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contributor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContributors(repoRef, gitRef, since, until, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getContributors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiffStats(repoRef: string, path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiffStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiffStats(repoRef, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getDiffStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiffs(repoRef: string, path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiffs(repoRef, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getDiffs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForks(repoRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForks(repoRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getForks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneral(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneral(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getGeneral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHasStarred(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryStarModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHasStarred(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getHasStarred']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportProgress(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobProgress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportProgress(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getImportProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {boolean} [includeDirectories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaths(repoRef: string, gitRef?: string, includeDirectories?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoPathsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaths(repoRef, gitRef, includeDirectories, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getPaths']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaw(repoRef: string, path: string, gitRef?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaw(repoRef, path, gitRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelease(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseCreator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelease(repoRef, tagRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {ReleaseSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReleases(repoRef: string, page?: number, size?: number, query?: string, sort?: ReleaseSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReleaseCreator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReleases(repoRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getReleases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepo(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoParent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepo(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryResetedRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryResetedRunnerRegisterToken(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryResetedRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryRunner(repoRef, runnerUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterTokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryRunnerRegisterToken(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryRunnerRegisterToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryRunners(repoRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunnerCreator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryRunners(repoRef, page, size, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryRunners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryServiceAccounts(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryServiceAccounts(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryServiceAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryStats(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoStatsOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryStats(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryVariable(repoRef, variableIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositoryVariables(repoRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariableGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepositoryVariables(repoRef, page, size, query, types, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getRepositoryVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecurity(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecuritySettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecurity(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStars(repoRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStars(repoRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getStars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(repoRef, page, size, query, includeCommit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.getTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateInput} repoUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRepo(repoRef: string, repoUpdateInput: RepoUpdateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRepo(repoRef, repoUpdateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.patchRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRepositoryRunner(repoRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRepositoryRunner(repoRef, runnerUuid, runnerPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.patchRepositoryRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRepositoryVariable(repoRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRepositoryVariable(repoRef, variableIdentifier, variablePatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.patchRepositoryVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {SecuritySettings} securitySettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchSecurity(repoRef: string, securitySettings: SecuritySettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecuritySettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchSecurity(repoRef, securitySettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.patchSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoStarsInput} repoStarsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStars(repoRef: string, repoStarsInput: RepoStarsInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchStars(repoRef, repoStarsInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.patchStars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchCreateInput} branchCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBranch(repoRef: string, branchCreateInput: BranchCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitBranch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBranch(repoRef, branchCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateDefaultBranchInput} repoUpdateDefaultBranchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDefaultBranch(repoRef: string, repoUpdateDefaultBranchInput: RepoUpdateDefaultBranchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDefaultBranch(repoRef, repoUpdateDefaultBranchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postDefaultBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} path2 
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDiffs(repoRef: string, path: string, path2: string, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDiffs(repoRef, path, path2, commitDiffFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postDiffs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {RepoMergeCheckInput} repoMergeCheckInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMergeCheck(repoRef: string, path: string, repoMergeCheckInput: RepoMergeCheckInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoMergeCheckOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMergeCheck(repoRef, path, repoMergeCheckInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postMergeCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {Array<string>} requestBody 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPathDetails(repoRef: string, requestBody: Array<string>, gitRef?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PathDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPathDetails(repoRef, requestBody, gitRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postPathDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ReleaseCreateInput} releaseCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRelease(repoRef: string, releaseCreateInput: ReleaseCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRelease(repoRef, releaseCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RepoCreateInput} repoCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepo(repoCreateInput: RepoCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepo(repoCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRepo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RepoImportInput} repoImportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepositoryImport(repoImportInput: RepoImportInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepositoryImport(repoImportInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRepositoryImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoMoveInput} repoMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepositoryMove(repoRef: string, repoMoveInput: RepoMoveInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepositoryMove(repoRef, repoMoveInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRepositoryMove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepositoryPurge(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepositoryPurge(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRepositoryPurge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRepositoryVariable(repoRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRepositoryVariable(repoRef, variableCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postRepositoryVariable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {TagCreateInput} tagCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTag(repoRef: string, tagCreateInput: TagCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTag(repoRef, tagCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.postTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchRenameInput} branchRenameInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameBranch(repoRef: string, branchRenameInput: BranchRenameInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitBranch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameBranch(repoRef, branchRenameInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.renameBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoRestoreInput} repoRestoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoRestore(repoRef: string, repoRestoreInput: RepoRestoreInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoRestore(repoRef, repoRestoreInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.repoRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async softRepositoryDelete(repoRef: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.softRepositoryDelete(repoRef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RepositoryApi.softRepositoryDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {CommitFilesInput} commitFilesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitFiles(repoRef: string, commitFilesInput: CommitFilesInput, options?: RawAxiosRequestConfig): AxiosPromise<CommitFilesOutput> {
            return localVarFp.commitFiles(repoRef, commitFilesInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoCommitDivergencesInput} repoCommitDivergencesInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitsCalculateDivergence(repoRef: string, repoCommitDivergencesInput: RepoCommitDivergencesInput, options?: RawAxiosRequestConfig): AxiosPromise<Array<CommitDivergence>> {
            return localVarFp.commitsCalculateDivergence(repoRef, repoCommitDivergencesInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch(repoRef: string, branchName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBranch(repoRef, branchName, bypassRules, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelease(repoRef: string, tagRef: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRelease(repoRef, tagRef, bypassRules, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryRunner(repoRef, runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRepositoryVariable(repoRef, variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagName 
         * @param {boolean} [bypassRules] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(repoRef: string, tagName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTag(repoRef, tagName, bypassRules, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {GeneralSettings} generalSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generalUpdate(repoRef: string, generalSettings: GeneralSettings, options?: RawAxiosRequestConfig): AxiosPromise<GeneralSettings> {
            return localVarFp.generalUpdate(repoRef, generalSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} archiveRef 
         * @param {string} [prefix] 
         * @param {ArchiveAttribute} [attributes] 
         * @param {Array<string>} [paths] 
         * @param {number} [timestamp] 
         * @param {number} [compression] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArchive(repoRef: string, archiveRef: string, prefix?: string, attributes?: ArchiveAttribute, paths?: Array<string>, timestamp?: number, compression?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getArchive(repoRef, archiveRef, prefix, attributes, paths, timestamp, compression, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] The git reference (branch / tag / commitID) that will be used to retrieve the data. If no value is provided the default branch of the repository is used.         Default value : {Repository Default Branch}
         * @param {number} [lineFrom] 
         * @param {number} [lineTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlame(repoRef: string, path: string, gitRef?: string, lineFrom?: number, lineTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<BlamePart>> {
            return localVarFp.getBlame(repoRef, path, gitRef, lineFrom, lineTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} branchName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranch(repoRef: string, branchName: string, options?: RawAxiosRequestConfig): AxiosPromise<CommitBranch> {
            return localVarFp.getBranch(repoRef, branchName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranches(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<CommitBranch>> {
            return localVarFp.getBranches(repoRef, page, size, query, includeCommit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeownersValidate(repoRef: string, gitRef?: string, options?: RawAxiosRequestConfig): AxiosPromise<CodeOwnersValidation> {
            return localVarFp.getCodeownersValidate(repoRef, gitRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommit(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig): AxiosPromise<Commit> {
            return localVarFp.getCommit(repoRef, commitSha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitDiff(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getCommitDiff(repoRef, commitSha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {string} filePath 
         * @param {string} hunkHeader 
         * @param {boolean} expandUp 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitFileContent(repoRef: string, commitSha: string, filePath: string, hunkHeader: string, expandUp: boolean, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<DiffFileContent> {
            return localVarFp.getCommitFileContent(repoRef, commitSha, filePath, hunkHeader, expandUp, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [after] 
         * @param {string} [path] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {string} [author] 
         * @param {boolean} [includeStats] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommits(repoRef: string, gitRef?: string, page?: number, size?: number, after?: string, path?: string, since?: number, until?: number, author?: string, includeStats?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<CommitWithPathRenameDetails>> {
            return localVarFp.getCommits(repoRef, gitRef, page, size, after, path, since, until, author, includeStats, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent(repoRef: string, path: string, gitRef?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<RepoContentOutput> {
            return localVarFp.getContent(repoRef, path, gitRef, includeCommit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {number} [since] 
         * @param {number} [until] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContributors(repoRef: string, gitRef?: string, since?: number, until?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Contributor>> {
            return localVarFp.getContributors(repoRef, gitRef, since, until, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiffStats(repoRef: string, path: string, options?: RawAxiosRequestConfig): AxiosPromise<DiffStats> {
            return localVarFp.getDiffStats(repoRef, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiffs(repoRef: string, path: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getDiffs(repoRef, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForks(repoRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepositoryModel>> {
            return localVarFp.getForks(repoRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneral(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<GeneralSettings> {
            return localVarFp.getGeneral(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHasStarred(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryStarModel> {
            return localVarFp.getHasStarred(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportProgress(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<JobProgress> {
            return localVarFp.getImportProgress(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [gitRef] 
         * @param {boolean} [includeDirectories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaths(repoRef: string, gitRef?: string, includeDirectories?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<RepoPathsOutput> {
            return localVarFp.getPaths(repoRef, gitRef, includeDirectories, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaw(repoRef: string, path: string, gitRef?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getRaw(repoRef, path, gitRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} tagRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelease(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig): AxiosPromise<ReleaseCreator> {
            return localVarFp.getRelease(repoRef, tagRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {ReleaseSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleases(repoRef: string, page?: number, size?: number, query?: string, sort?: ReleaseSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReleaseCreator>> {
            return localVarFp.getReleases(repoRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepo(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RepoParent> {
            return localVarFp.getRepo(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryResetedRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getRepositoryResetedRunnerRegisterToken(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.getRepositoryRunner(repoRef, runnerUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RegisterTokenModel> {
            return localVarFp.getRepositoryRunnerRegisterToken(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryRunners(repoRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunnerCreator>> {
            return localVarFp.getRepositoryRunners(repoRef, page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryServiceAccounts(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserModel>> {
            return localVarFp.getRepositoryServiceAccounts(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryStats(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<RepoStatsOutput> {
            return localVarFp.getRepositoryStats(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.getRepositoryVariable(repoRef, variableIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<VariableType>} [types] 
         * @param {VariableSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositoryVariables(repoRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<VariableGroup>> {
            return localVarFp.getRepositoryVariables(repoRef, page, size, query, types, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurity(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<SecuritySettings> {
            return localVarFp.getSecurity(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStars(repoRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserModel>> {
            return localVarFp.getStars(repoRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {boolean} [includeCommit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<CommitTag>> {
            return localVarFp.getTags(repoRef, page, size, query, includeCommit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateInput} repoUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepo(repoRef: string, repoUpdateInput: RepoUpdateInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.patchRepo(repoRef, repoUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} runnerUuid 
         * @param {RunnerPatchInput} runnerPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepositoryRunner(repoRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<RunnerModel> {
            return localVarFp.patchRepositoryRunner(repoRef, runnerUuid, runnerPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} variableIdentifier 
         * @param {VariablePatchInput} variablePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRepositoryVariable(repoRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.patchRepositoryVariable(repoRef, variableIdentifier, variablePatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {SecuritySettings} securitySettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSecurity(repoRef: string, securitySettings: SecuritySettings, options?: RawAxiosRequestConfig): AxiosPromise<SecuritySettings> {
            return localVarFp.patchSecurity(repoRef, securitySettings, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoStarsInput} repoStarsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStars(repoRef: string, repoStarsInput: RepoStarsInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.patchStars(repoRef, repoStarsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchCreateInput} branchCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBranch(repoRef: string, branchCreateInput: BranchCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<CommitBranch> {
            return localVarFp.postBranch(repoRef, branchCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoUpdateDefaultBranchInput} repoUpdateDefaultBranchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDefaultBranch(repoRef: string, repoUpdateDefaultBranchInput: RepoUpdateDefaultBranchInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.postDefaultBranch(repoRef, repoUpdateDefaultBranchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {string} path2 
         * @param {Array<CommitDiffFile>} commitDiffFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiffs(repoRef: string, path: string, path2: string, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.postDiffs(repoRef, path, path2, commitDiffFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} path 
         * @param {RepoMergeCheckInput} repoMergeCheckInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMergeCheck(repoRef: string, path: string, repoMergeCheckInput: RepoMergeCheckInput, options?: RawAxiosRequestConfig): AxiosPromise<RepoMergeCheckOutput> {
            return localVarFp.postMergeCheck(repoRef, path, repoMergeCheckInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {Array<string>} requestBody 
         * @param {string} [gitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPathDetails(repoRef: string, requestBody: Array<string>, gitRef?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PathDetails>> {
            return localVarFp.postPathDetails(repoRef, requestBody, gitRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {ReleaseCreateInput} releaseCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRelease(repoRef: string, releaseCreateInput: ReleaseCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<ReleaseModel> {
            return localVarFp.postRelease(repoRef, releaseCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RepoCreateInput} repoCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepo(repoCreateInput: RepoCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.postRepo(repoCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RepoImportInput} repoImportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryImport(repoImportInput: RepoImportInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.postRepositoryImport(repoImportInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoMoveInput} repoMoveInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryMove(repoRef: string, repoMoveInput: RepoMoveInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.postRepositoryMove(repoRef, repoMoveInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryPurge(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postRepositoryPurge(repoRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {VariableCreateInput} variableCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRepositoryVariable(repoRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<VariableModel> {
            return localVarFp.postRepositoryVariable(repoRef, variableCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {TagCreateInput} tagCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTag(repoRef: string, tagCreateInput: TagCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<CommitTag> {
            return localVarFp.postTag(repoRef, tagCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {BranchRenameInput} branchRenameInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameBranch(repoRef: string, branchRenameInput: BranchRenameInput, options?: RawAxiosRequestConfig): AxiosPromise<CommitBranch> {
            return localVarFp.renameBranch(repoRef, branchRenameInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RepoRestoreInput} repoRestoreInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoRestore(repoRef: string, repoRestoreInput: RepoRestoreInput, options?: RawAxiosRequestConfig): AxiosPromise<RepositoryModel> {
            return localVarFp.repoRestore(repoRef, repoRestoreInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softRepositoryDelete(repoRef: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.softRepositoryDelete(repoRef, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {CommitFilesInput} commitFilesInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public commitFiles(repoRef: string, commitFilesInput: CommitFilesInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).commitFiles(repoRef, commitFilesInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoCommitDivergencesInput} repoCommitDivergencesInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public commitsCalculateDivergence(repoRef: string, repoCommitDivergencesInput: RepoCommitDivergencesInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).commitsCalculateDivergence(repoRef, repoCommitDivergencesInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} branchName 
     * @param {boolean} [bypassRules] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteBranch(repoRef: string, branchName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteBranch(repoRef, branchName, bypassRules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {boolean} [bypassRules] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteRelease(repoRef: string, tagRef: string, bypassRules?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteRelease(repoRef, tagRef, bypassRules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteRepositoryRunner(repoRef, runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteRepositoryVariable(repoRef, variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagName 
     * @param {boolean} [bypassRules] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteTag(repoRef: string, tagName: string, bypassRules?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).deleteTag(repoRef, tagName, bypassRules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {GeneralSettings} generalSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public generalUpdate(repoRef: string, generalSettings: GeneralSettings, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).generalUpdate(repoRef, generalSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} archiveRef 
     * @param {string} [prefix] 
     * @param {ArchiveAttribute} [attributes] 
     * @param {Array<string>} [paths] 
     * @param {number} [timestamp] 
     * @param {number} [compression] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getArchive(repoRef: string, archiveRef: string, prefix?: string, attributes?: ArchiveAttribute, paths?: Array<string>, timestamp?: number, compression?: number, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getArchive(repoRef, archiveRef, prefix, attributes, paths, timestamp, compression, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {string} [gitRef] The git reference (branch / tag / commitID) that will be used to retrieve the data. If no value is provided the default branch of the repository is used.         Default value : {Repository Default Branch}
     * @param {number} [lineFrom] 
     * @param {number} [lineTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getBlame(repoRef: string, path: string, gitRef?: string, lineFrom?: number, lineTo?: number, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getBlame(repoRef, path, gitRef, lineFrom, lineTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} branchName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getBranch(repoRef: string, branchName: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getBranch(repoRef, branchName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {boolean} [includeCommit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getBranches(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getBranches(repoRef, page, size, query, includeCommit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} [gitRef] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getCodeownersValidate(repoRef: string, gitRef?: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getCodeownersValidate(repoRef, gitRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} commitSha 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getCommit(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getCommit(repoRef, commitSha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} commitSha 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getCommitDiff(repoRef: string, commitSha: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getCommitDiff(repoRef, commitSha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} commitSha 
     * @param {string} filePath 
     * @param {string} hunkHeader 
     * @param {boolean} expandUp 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getCommitFileContent(repoRef: string, commitSha: string, filePath: string, hunkHeader: string, expandUp: boolean, size?: number, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getCommitFileContent(repoRef, commitSha, filePath, hunkHeader, expandUp, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} [gitRef] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [after] 
     * @param {string} [path] 
     * @param {number} [since] 
     * @param {number} [until] 
     * @param {string} [author] 
     * @param {boolean} [includeStats] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getCommits(repoRef: string, gitRef?: string, page?: number, size?: number, after?: string, path?: string, since?: number, until?: number, author?: string, includeStats?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getCommits(repoRef, gitRef, page, size, after, path, since, until, author, includeStats, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {string} [gitRef] 
     * @param {boolean} [includeCommit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getContent(repoRef: string, path: string, gitRef?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getContent(repoRef, path, gitRef, includeCommit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} [gitRef] 
     * @param {number} [since] 
     * @param {number} [until] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getContributors(repoRef: string, gitRef?: string, since?: number, until?: number, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getContributors(repoRef, gitRef, since, until, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getDiffStats(repoRef: string, path: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getDiffStats(repoRef, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getDiffs(repoRef: string, path: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getDiffs(repoRef, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getForks(repoRef: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getForks(repoRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getGeneral(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getGeneral(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getHasStarred(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getHasStarred(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getImportProgress(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getImportProgress(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} [gitRef] 
     * @param {boolean} [includeDirectories] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getPaths(repoRef: string, gitRef?: string, includeDirectories?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getPaths(repoRef, gitRef, includeDirectories, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {string} [gitRef] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRaw(repoRef: string, path: string, gitRef?: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRaw(repoRef, path, gitRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} tagRef 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRelease(repoRef: string, tagRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRelease(repoRef, tagRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {ReleaseSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getReleases(repoRef: string, page?: number, size?: number, query?: string, sort?: ReleaseSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getReleases(repoRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepo(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepo(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryResetedRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryResetedRunnerRegisterToken(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} runnerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryRunner(repoRef: string, runnerUuid: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryRunner(repoRef, runnerUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryRunnerRegisterToken(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryRunnerRegisterToken(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryRunners(repoRef: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryRunners(repoRef, page, size, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryServiceAccounts(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryServiceAccounts(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryStats(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryStats(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} variableIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryVariable(repoRef: string, variableIdentifier: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryVariable(repoRef, variableIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<VariableType>} [types] 
     * @param {VariableSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getRepositoryVariables(repoRef: string, page?: number, size?: number, query?: string, types?: Array<VariableType>, sort?: VariableSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getRepositoryVariables(repoRef, page, size, query, types, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getSecurity(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getSecurity(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {UserSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getStars(repoRef: string, page?: number, size?: number, query?: string, sort?: UserSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getStars(repoRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {boolean} [includeCommit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTags(repoRef: string, page?: number, size?: number, query?: string, includeCommit?: boolean, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getTags(repoRef, page, size, query, includeCommit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoUpdateInput} repoUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public patchRepo(repoRef: string, repoUpdateInput: RepoUpdateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).patchRepo(repoRef, repoUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} runnerUuid 
     * @param {RunnerPatchInput} runnerPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public patchRepositoryRunner(repoRef: string, runnerUuid: string, runnerPatchInput: RunnerPatchInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).patchRepositoryRunner(repoRef, runnerUuid, runnerPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} variableIdentifier 
     * @param {VariablePatchInput} variablePatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public patchRepositoryVariable(repoRef: string, variableIdentifier: string, variablePatchInput: VariablePatchInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).patchRepositoryVariable(repoRef, variableIdentifier, variablePatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {SecuritySettings} securitySettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public patchSecurity(repoRef: string, securitySettings: SecuritySettings, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).patchSecurity(repoRef, securitySettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoStarsInput} repoStarsInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public patchStars(repoRef: string, repoStarsInput: RepoStarsInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).patchStars(repoRef, repoStarsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {BranchCreateInput} branchCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postBranch(repoRef: string, branchCreateInput: BranchCreateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postBranch(repoRef, branchCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoUpdateDefaultBranchInput} repoUpdateDefaultBranchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postDefaultBranch(repoRef: string, repoUpdateDefaultBranchInput: RepoUpdateDefaultBranchInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postDefaultBranch(repoRef, repoUpdateDefaultBranchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {string} path2 
     * @param {Array<CommitDiffFile>} commitDiffFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postDiffs(repoRef: string, path: string, path2: string, commitDiffFile: Array<CommitDiffFile>, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postDiffs(repoRef, path, path2, commitDiffFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} path 
     * @param {RepoMergeCheckInput} repoMergeCheckInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postMergeCheck(repoRef: string, path: string, repoMergeCheckInput: RepoMergeCheckInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postMergeCheck(repoRef, path, repoMergeCheckInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {Array<string>} requestBody 
     * @param {string} [gitRef] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postPathDetails(repoRef: string, requestBody: Array<string>, gitRef?: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postPathDetails(repoRef, requestBody, gitRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {ReleaseCreateInput} releaseCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postRelease(repoRef: string, releaseCreateInput: ReleaseCreateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRelease(repoRef, releaseCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RepoCreateInput} repoCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postRepo(repoCreateInput: RepoCreateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRepo(repoCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RepoImportInput} repoImportInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postRepositoryImport(repoImportInput: RepoImportInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRepositoryImport(repoImportInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoMoveInput} repoMoveInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postRepositoryMove(repoRef: string, repoMoveInput: RepoMoveInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRepositoryMove(repoRef, repoMoveInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postRepositoryPurge(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRepositoryPurge(repoRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {VariableCreateInput} variableCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postRepositoryVariable(repoRef: string, variableCreateInput: VariableCreateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postRepositoryVariable(repoRef, variableCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {TagCreateInput} tagCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public postTag(repoRef: string, tagCreateInput: TagCreateInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).postTag(repoRef, tagCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {BranchRenameInput} branchRenameInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public renameBranch(repoRef: string, branchRenameInput: BranchRenameInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).renameBranch(repoRef, branchRenameInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RepoRestoreInput} repoRestoreInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoRestore(repoRef: string, repoRestoreInput: RepoRestoreInput, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoRestore(repoRef, repoRestoreInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public softRepositoryDelete(repoRef: string, options?: RawAxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).softRepositoryDelete(repoRef, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitignores: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/gitignore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGitignores(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGitignores(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getGitignores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<License>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getLicenses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGitignores(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getGitignores(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenses(options?: RawAxiosRequestConfig): AxiosPromise<Array<License>> {
            return localVarFp.getLicenses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getGitignores(options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getGitignores(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getLicenses(options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getLicenses(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (repoRef: string, ruleIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteRule', 'repoRef', repoRef)
            // verify required parameter 'ruleIdentifier' is not null or undefined
            assertParamExists('deleteRule', 'ruleIdentifier', ruleIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/rules/{rule_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"rule_identifier"}}`, encodeURIComponent(String(ruleIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: async (repoRef: string, ruleIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRule', 'repoRef', repoRef)
            // verify required parameter 'ruleIdentifier' is not null or undefined
            assertParamExists('getRule', 'ruleIdentifier', ruleIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/rules/{rule_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"rule_identifier"}}`, encodeURIComponent(String(ruleIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<RuleState>} [states] 
         * @param {RuleSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules: async (repoRef: string, page?: number, size?: number, query?: string, states?: Array<RuleState>, sort?: RuleSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRules', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/rules`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (states) {
                localVarQueryParameter['states'] = states;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {RulePatchInput} rulePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRule: async (repoRef: string, ruleIdentifier: string, rulePatchInput: RulePatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchRule', 'repoRef', repoRef)
            // verify required parameter 'ruleIdentifier' is not null or undefined
            assertParamExists('patchRule', 'ruleIdentifier', ruleIdentifier)
            // verify required parameter 'rulePatchInput' is not null or undefined
            assertParamExists('patchRule', 'rulePatchInput', rulePatchInput)
            const localVarPath = `/repos/{repo_ref}/+/rules/{rule_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"rule_identifier"}}`, encodeURIComponent(String(ruleIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rulePatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RuleCreateInput} ruleCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRule: async (repoRef: string, ruleCreateInput: RuleCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRule', 'repoRef', repoRef)
            // verify required parameter 'ruleCreateInput' is not null or undefined
            assertParamExists('postRule', 'ruleCreateInput', ruleCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/rules`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(repoRef, ruleIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.deleteRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRule(repoRef, ruleIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.getRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<RuleState>} [states] 
         * @param {RuleSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRules(repoRef: string, page?: number, size?: number, query?: string, states?: Array<RuleState>, sort?: RuleSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRules(repoRef, page, size, query, states, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.getRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {RulePatchInput} rulePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRule(repoRef: string, ruleIdentifier: string, rulePatchInput: RulePatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRule(repoRef, ruleIdentifier, rulePatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.patchRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RuleCreateInput} ruleCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRule(repoRef: string, ruleCreateInput: RuleCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRule(repoRef, ruleCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.postRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRule(repoRef, ruleIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<RuleModel> {
            return localVarFp.getRule(repoRef, ruleIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<RuleState>} [states] 
         * @param {RuleSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules(repoRef: string, page?: number, size?: number, query?: string, states?: Array<RuleState>, sort?: RuleSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RuleModel>> {
            return localVarFp.getRules(repoRef, page, size, query, states, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} ruleIdentifier Rule identifier
         * @param {RulePatchInput} rulePatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRule(repoRef: string, ruleIdentifier: string, rulePatchInput: RulePatchInput, options?: RawAxiosRequestConfig): AxiosPromise<RuleModel> {
            return localVarFp.patchRule(repoRef, ruleIdentifier, rulePatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {RuleCreateInput} ruleCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRule(repoRef: string, ruleCreateInput: RuleCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<RuleModel> {
            return localVarFp.postRule(repoRef, ruleCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} ruleIdentifier Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteRule(repoRef, ruleIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} ruleIdentifier Rule identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getRule(repoRef: string, ruleIdentifier: string, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).getRule(repoRef, ruleIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<RuleState>} [states] 
     * @param {RuleSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getRules(repoRef: string, page?: number, size?: number, query?: string, states?: Array<RuleState>, sort?: RuleSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).getRules(repoRef, page, size, query, states, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} ruleIdentifier Rule identifier
     * @param {RulePatchInput} rulePatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public patchRule(repoRef: string, ruleIdentifier: string, rulePatchInput: RulePatchInput, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).patchRule(repoRef, ruleIdentifier, rulePatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {RuleCreateInput} ruleCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public postRule(repoRef: string, ruleCreateInput: RuleCreateInput, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).postRule(repoRef, ruleCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunnersApi - axios parameter creator
 * @export
 */
export const RunnersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/runners/stage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RunnerPostInput} runnerPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRunnersRegister: async (runnerPostInput: RunnerPostInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runnerPostInput' is not null or undefined
            assertParamExists('postRunnersRegister', 'runnerPostInput', runnerPostInput)
            const localVarPath = `/runners/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerPostInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunnersApi - functional programming interface
 * @export
 */
export const RunnersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunnersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerStageOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnersApi.getStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RunnerPostInput} runnerPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRunnersRegister(runnerPostInput: RunnerPostInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenCreateOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRunnersRegister(runnerPostInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnersApi.postRunnersRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunnersApi - factory interface
 * @export
 */
export const RunnersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunnersApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStage(options?: RawAxiosRequestConfig): AxiosPromise<RunnerStageOutput> {
            return localVarFp.getStage(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RunnerPostInput} runnerPostInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRunnersRegister(runnerPostInput: RunnerPostInput, options?: RawAxiosRequestConfig): AxiosPromise<TokenCreateOutput> {
            return localVarFp.postRunnersRegister(runnerPostInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunnersApi - object-oriented interface
 * @export
 * @class RunnersApi
 * @extends {BaseAPI}
 */
export class RunnersApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnersApi
     */
    public getStage(options?: RawAxiosRequestConfig) {
        return RunnersApiFp(this.configuration).getStage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RunnerPostInput} runnerPostInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnersApi
     */
    public postRunnersRegister(runnerPostInput: RunnerPostInput, options?: RawAxiosRequestConfig) {
        return RunnersApiFp(this.configuration).postRunnersRegister(runnerPostInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServiceAccountsApi - axios parameter creator
 * @export
 */
export const ServiceAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccount: async (saIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('deleteServiceAccount', 'saIdentifier', saIdentifier)
            const localVarPath = `/service-accounts/{sa_identifier}`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccountToken: async (saIdentifier: string, tokenName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('deleteServiceAccountToken', 'saIdentifier', saIdentifier)
            // verify required parameter 'tokenName' is not null or undefined
            assertParamExists('deleteServiceAccountToken', 'tokenName', tokenName)
            const localVarPath = `/service-accounts/{sa_identifier}/tokens/{token_name}`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)))
                .replace(`{${"token_name"}}`, encodeURIComponent(String(tokenName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccount: async (saIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('getServiceAccount', 'saIdentifier', saIdentifier)
            const localVarPath = `/service-accounts/{sa_identifier}`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountTokens: async (saIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('getServiceAccountTokens', 'saIdentifier', saIdentifier)
            const localVarPath = `/service-accounts/{sa_identifier}/tokens`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postServiceAccount: async (saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('postServiceAccount', 'saIdentifier', saIdentifier)
            // verify required parameter 'serviceAccountCreateInput' is not null or undefined
            assertParamExists('postServiceAccount', 'serviceAccountCreateInput', serviceAccountCreateInput)
            const localVarPath = `/service-accounts/{sa_identifier}`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceAccountCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postServiceAccountToken: async (saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saIdentifier' is not null or undefined
            assertParamExists('postServiceAccountToken', 'saIdentifier', saIdentifier)
            // verify required parameter 'serviceAccountCreateInput' is not null or undefined
            assertParamExists('postServiceAccountToken', 'serviceAccountCreateInput', serviceAccountCreateInput)
            const localVarPath = `/service-accounts/{sa_identifier}/tokens`
                .replace(`{${"sa_identifier"}}`, encodeURIComponent(String(saIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceAccountCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceAccountsApi - functional programming interface
 * @export
 */
export const ServiceAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAccount(saIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.deleteServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAccountToken(saIdentifier: string, tokenName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAccountToken(saIdentifier, tokenName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.deleteServiceAccountToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAccount(saIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.getServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAccountTokens(saIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAccountTokens(saIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.getServiceAccountTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postServiceAccount(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postServiceAccount(saIdentifier, serviceAccountCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.postServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postServiceAccountToken(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccountTokenOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postServiceAccountToken(saIdentifier, serviceAccountCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.postServiceAccountToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceAccountsApi - factory interface
 * @export
 */
export const ServiceAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceAccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteServiceAccount(saIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccountToken(saIdentifier: string, tokenName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteServiceAccountToken(saIdentifier, tokenName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.getServiceAccount(saIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAccountTokens(saIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenModel>> {
            return localVarFp.getServiceAccountTokens(saIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postServiceAccount(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.postServiceAccount(saIdentifier, serviceAccountCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} saIdentifier Service account UID
         * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postServiceAccountToken(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<ServiceAccountTokenOutput> {
            return localVarFp.postServiceAccountToken(saIdentifier, serviceAccountCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceAccountsApi - object-oriented interface
 * @export
 * @class ServiceAccountsApi
 * @extends {BaseAPI}
 */
export class ServiceAccountsApi extends BaseAPI {
    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public deleteServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).deleteServiceAccount(saIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {string} tokenName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public deleteServiceAccountToken(saIdentifier: string, tokenName: string, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).deleteServiceAccountToken(saIdentifier, tokenName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public getServiceAccount(saIdentifier: string, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).getServiceAccount(saIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public getServiceAccountTokens(saIdentifier: string, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).getServiceAccountTokens(saIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public postServiceAccount(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).postServiceAccount(saIdentifier, serviceAccountCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} saIdentifier Service account UID
     * @param {ServiceAccountCreateInput} serviceAccountCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public postServiceAccountToken(saIdentifier: string, serviceAccountCreateInput: ServiceAccountCreateInput, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).postServiceAccountToken(saIdentifier, serviceAccountCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusCheckApi - axios parameter creator
 * @export
 */
export const StatusCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChecks: async (repoRef: string, commitSha: string, page?: number, size?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getChecks', 'repoRef', repoRef)
            // verify required parameter 'commitSha' is not null or undefined
            assertParamExists('getChecks', 'commitSha', commitSha)
            const localVarPath = `/repos/{repo_ref}/+/checks/commits/{commit_sha}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"commit_sha"}}`, encodeURIComponent(String(commitSha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [query] 
         * @param {number} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent: async (repoRef: string, query?: string, since?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getRecent', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/checks/recent`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {CheckReportInput} checkReportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCheckReport: async (repoRef: string, commitSha: string, checkReportInput: CheckReportInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('putCheckReport', 'repoRef', repoRef)
            // verify required parameter 'commitSha' is not null or undefined
            assertParamExists('putCheckReport', 'commitSha', commitSha)
            // verify required parameter 'checkReportInput' is not null or undefined
            assertParamExists('putCheckReport', 'checkReportInput', checkReportInput)
            const localVarPath = `/repos/{repo_ref}/+/checks/commits/{commit_sha}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"commit_sha"}}`, encodeURIComponent(String(commitSha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkReportInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusCheckApi - functional programming interface
 * @export
 */
export const StatusCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChecks(repoRef: string, commitSha: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CheckModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChecks(repoRef, commitSha, page, size, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusCheckApi.getChecks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [query] 
         * @param {number} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecent(repoRef: string, query?: string, since?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecent(repoRef, query, since, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusCheckApi.getRecent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {CheckReportInput} checkReportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCheckReport(repoRef: string, commitSha: string, checkReportInput: CheckReportInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCheckReport(repoRef, commitSha, checkReportInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusCheckApi.putCheckReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusCheckApi - factory interface
 * @export
 */
export const StatusCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusCheckApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChecks(repoRef: string, commitSha: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CheckModel>> {
            return localVarFp.getChecks(repoRef, commitSha, page, size, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} [query] 
         * @param {number} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent(repoRef: string, query?: string, since?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getRecent(repoRef, query, since, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} commitSha 
         * @param {CheckReportInput} checkReportInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCheckReport(repoRef: string, commitSha: string, checkReportInput: CheckReportInput, options?: RawAxiosRequestConfig): AxiosPromise<CheckModel> {
            return localVarFp.putCheckReport(repoRef, commitSha, checkReportInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusCheckApi - object-oriented interface
 * @export
 * @class StatusCheckApi
 * @extends {BaseAPI}
 */
export class StatusCheckApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} commitSha 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusCheckApi
     */
    public getChecks(repoRef: string, commitSha: string, page?: number, size?: number, query?: string, options?: RawAxiosRequestConfig) {
        return StatusCheckApiFp(this.configuration).getChecks(repoRef, commitSha, page, size, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} [query] 
     * @param {number} [since] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusCheckApi
     */
    public getRecent(repoRef: string, query?: string, since?: number, options?: RawAxiosRequestConfig) {
        return StatusCheckApiFp(this.configuration).getRecent(repoRef, query, since, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} commitSha 
     * @param {CheckReportInput} checkReportInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusCheckApi
     */
    public putCheckReport(repoRef: string, commitSha: string, checkReportInput: CheckReportInput, options?: RawAxiosRequestConfig) {
        return StatusCheckApiFp(this.configuration).putCheckReport(repoRef, commitSha, checkReportInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: RawAxiosRequestConfig): AxiosPromise<SystemConfig> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getConfig(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getHealth(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getVersion(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} publicKeyName Public key name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (publicKeyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicKeyName' is not null or undefined
            assertParamExists('deletePublicKey', 'publicKeyName', publicKeyName)
            const localVarPath = `/user/keys/{public_key_name}`
                .replace(`{${"public_key_name"}}`, encodeURIComponent(String(publicKeyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession: async (sessionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionName' is not null or undefined
            assertParamExists('deleteSession', 'sessionName', sessionName)
            const localVarPath = `/user/sessions/{session_name}`
                .replace(`{${"session_name"}}`, encodeURIComponent(String(sessionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (tokenName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenName' is not null or undefined
            assertParamExists('deleteToken', 'tokenName', tokenName)
            const localVarPath = `/user/tokens/{token_name}`
                .replace(`{${"token_name"}}`, encodeURIComponent(String(tokenName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwoFactor: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/security/two_factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeds: async (page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHasPerm: async (repoRef: string, perm: Permission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getHasPerm', 'repoRef', repoRef)
            // verify required parameter 'perm' is not null or undefined
            assertParamExists('getHasPerm', 'perm', perm)
            const localVarPath = `/user/{repo_ref}/+/has_perm`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (perm !== undefined) {
                localVarQueryParameter['perm'] = perm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeatmap: async (before?: number, after?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/heatmap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberships: async (page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {PublicKeySort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (page?: number, size?: number, query?: string, sort?: PublicKeySort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwoFactor: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/security/two_factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: async (page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepos: async (page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStars: async (page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/stars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTwoFactor: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/security/two_factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserPatchInput} userPatchInput Update user infomation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserUser: async (userPatchInput: UserPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPatchInput' is not null or undefined
            assertParamExists('patchUserUser', 'userPatchInput', userPatchInput)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PublicKeyCreateInput} publicKeyCreateInput Create a new SSH public key for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPublicKey: async (publicKeyCreateInput: PublicKeyCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicKeyCreateInput' is not null or undefined
            assertParamExists('postPublicKey', 'publicKeyCreateInput', publicKeyCreateInput)
            const localVarPath = `/user/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenCreateInput} tokenCreateInput User access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postToken: async (tokenCreateInput: TokenCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenCreateInput' is not null or undefined
            assertParamExists('postToken', 'tokenCreateInput', tokenCreateInput)
            const localVarPath = `/user/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TwoFactorCreateInput} twoFactorCreateInput Two-factor creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactor: async (twoFactorCreateInput: TwoFactorCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorCreateInput' is not null or undefined
            assertParamExists('postTwoFactor', 'twoFactorCreateInput', twoFactorCreateInput)
            const localVarPath = `/user/security/two_factor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} publicKeyName Public key name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(publicKeyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(publicKeyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deletePublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sessionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSession(sessionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(sessionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(tokenName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(tokenName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTwoFactor(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTwoFactor(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeds(page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeedRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeeds(page, size, order, type, before, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getFeeds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHasPerm(repoRef: string, perm: Permission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHasPerm(repoRef, perm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getHasPerm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHeatmap(before?: number, after?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Heatmap>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHeatmap(before, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getHeatmap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberships(page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MembershipGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberships(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getMemberships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {PublicKeySort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(page?: number, size?: number, query?: string, sort?: PublicKeySort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKeyModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getPublicKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTwoFactor(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFactorGetOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTwoFactor(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroups(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRepos(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoParent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRepos(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStars(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoParent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStars(page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserStars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTwoFactor(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTwoFactor(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.patchTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserPatchInput} userPatchInput Update user infomation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserUser(userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUserUser(userPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.patchUserUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PublicKeyCreateInput} publicKeyCreateInput Create a new SSH public key for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPublicKey(publicKeyCreateInput: PublicKeyCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPublicKey(publicKeyCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.postPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TokenCreateInput} tokenCreateInput User access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postToken(tokenCreateInput: TokenCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenCreateOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postToken(tokenCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.postToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TwoFactorCreateInput} twoFactorCreateInput Two-factor creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTwoFactor(twoFactorCreateInput: TwoFactorCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTwoFactor(twoFactorCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.postTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {string} publicKeyName Public key name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(publicKeyName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePublicKey(publicKeyName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(sessionName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSession(sessionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tokenName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(tokenName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteToken(tokenName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwoFactor(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTwoFactor(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeds(page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FeedRelations>> {
            return localVarFp.getFeeds(page, size, order, type, before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHasPerm(repoRef: string, perm: Permission, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.getHasPerm(repoRef, perm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeatmap(before?: number, after?: number, options?: RawAxiosRequestConfig): AxiosPromise<Heatmap> {
            return localVarFp.getHeatmap(before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {MembershipSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberships(page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<MembershipGroup>> {
            return localVarFp.getMemberships(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {PublicKeySort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(page?: number, size?: number, query?: string, sort?: PublicKeySort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<PublicKeyModel>> {
            return localVarFp.getPublicKeys(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenModel>> {
            return localVarFp.getSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenModel>> {
            return localVarFp.getTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwoFactor(options?: RawAxiosRequestConfig): AxiosPromise<TwoFactorGetOutput> {
            return localVarFp.getTwoFactor(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupModel>> {
            return localVarFp.getUserGroups(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRepos(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepoParent>> {
            return localVarFp.getUserRepos(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStars(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepoParent>> {
            return localVarFp.getUserStars(page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUser(options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.getUserUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTwoFactor(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.patchTwoFactor(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserPatchInput} userPatchInput Update user infomation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserUser(userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.patchUserUser(userPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PublicKeyCreateInput} publicKeyCreateInput Create a new SSH public key for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPublicKey(publicKeyCreateInput: PublicKeyCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<PublicKeyModel> {
            return localVarFp.postPublicKey(publicKeyCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TokenCreateInput} tokenCreateInput User access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postToken(tokenCreateInput: TokenCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<TokenCreateOutput> {
            return localVarFp.postToken(tokenCreateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TwoFactorCreateInput} twoFactorCreateInput Two-factor creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTwoFactor(twoFactorCreateInput: TwoFactorCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.postTwoFactor(twoFactorCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {string} publicKeyName Public key name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deletePublicKey(publicKeyName: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deletePublicKey(publicKeyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteSession(sessionName: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteSession(sessionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tokenName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteToken(tokenName: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteToken(tokenName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteTwoFactor(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteTwoFactor(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {OrderOption} [order] 
     * @param {FeedType} [type] 
     * @param {number} [before] 
     * @param {number} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getFeeds(page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getFeeds(page, size, order, type, before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef 
     * @param {Permission} perm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getHasPerm(repoRef: string, perm: Permission, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getHasPerm(repoRef, perm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [before] 
     * @param {number} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getHeatmap(before?: number, after?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getHeatmap(before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {MembershipSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMemberships(page?: number, size?: number, query?: string, sort?: MembershipSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getMemberships(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {PublicKeySort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getPublicKeys(page?: number, size?: number, query?: string, sort?: PublicKeySort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getPublicKeys(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getSessions(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getTokens(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getTwoFactor(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getTwoFactor(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {GroupSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserGroups(page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserGroups(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserRepos(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserRepos(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserStars(page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserStars(page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserUser(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public patchTwoFactor(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).patchTwoFactor(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserPatchInput} userPatchInput Update user infomation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public patchUserUser(userPatchInput: UserPatchInput, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).patchUserUser(userPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PublicKeyCreateInput} publicKeyCreateInput Create a new SSH public key for the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postPublicKey(publicKeyCreateInput: PublicKeyCreateInput, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).postPublicKey(publicKeyCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TokenCreateInput} tokenCreateInput User access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postToken(tokenCreateInput: TokenCreateInput, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).postToken(tokenCreateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TwoFactorCreateInput} twoFactorCreateInput Two-factor creation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postTwoFactor(twoFactorCreateInput: TwoFactorCreateInput, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).postTwoFactor(twoFactorCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileGroups: async (identifier: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getProfileGroups', 'identifier', identifier)
            const localVarPath = `/users/{identifier}/groups`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileRepos: async (identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getProfileRepos', 'identifier', identifier)
            const localVarPath = `/users/{identifier}/repos`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFeeds: async (identifier: string, page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUsersFeeds', 'identifier', identifier)
            const localVarPath = `/users/{identifier}/feeds`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHasPerm: async (identifier: string, repoRef: string, perm: Permission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUsersHasPerm', 'identifier', identifier)
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getUsersHasPerm', 'repoRef', repoRef)
            // verify required parameter 'perm' is not null or undefined
            assertParamExists('getUsersHasPerm', 'perm', perm)
            const localVarPath = `/users/{identifier}/{repo_ref}/+/has_perm`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perm !== undefined) {
                localVarQueryParameter['perm'] = perm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHeatmap: async (identifier: string, before?: number, after?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUsersHeatmap', 'identifier', identifier)
            const localVarPath = `/users/{identifier}/heatmap`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersStars: async (identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUsersStars', 'identifier', identifier)
            const localVarPath = `/users/{identifier}/stars`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUser: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getUsersUser', 'identifier', identifier)
            const localVarPath = `/users/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<UserType>} [types] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsers: async (page?: number, size?: number, query?: string, types?: Array<UserType>, sort?: UserSort, order?: OrderOption, admin?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileGroups(identifier: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileGroups(identifier, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getProfileGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileRepos(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoParent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileRepos(identifier, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getProfileRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersFeeds(identifier: string, page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeedRelations>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersFeeds(identifier, page, size, order, type, before, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersFeeds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersHasPerm(identifier: string, repoRef: string, perm: Permission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersHasPerm(identifier, repoRef, perm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersHasPerm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersHeatmap(identifier: string, before?: number, after?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Heatmap>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersHeatmap(identifier, before, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersHeatmap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersStars(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepoParent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersStars(identifier, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersStars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUser(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUser(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<UserType>} [types] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUsers(page?: number, size?: number, query?: string, types?: Array<UserType>, sort?: UserSort, order?: OrderOption, admin?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUsers(page, size, query, types, sort, order, admin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {GroupSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileGroups(identifier: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupModel>> {
            return localVarFp.getProfileGroups(identifier, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileRepos(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepoParent>> {
            return localVarFp.getProfileRepos(identifier, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {OrderOption} [order] 
         * @param {FeedType} [type] 
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFeeds(identifier: string, page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FeedRelations>> {
            return localVarFp.getUsersFeeds(identifier, page, size, order, type, before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {string} repoRef 
         * @param {Permission} perm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHasPerm(identifier: string, repoRef: string, perm: Permission, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.getUsersHasPerm(identifier, repoRef, perm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [before] 
         * @param {number} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersHeatmap(identifier: string, before?: number, after?: number, options?: RawAxiosRequestConfig): AxiosPromise<Heatmap> {
            return localVarFp.getUsersHeatmap(identifier, before, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {RepoSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersStars(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<RepoParent>> {
            return localVarFp.getUsersStars(identifier, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifier GitBundle user id of the user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUser(identifier: string, options?: RawAxiosRequestConfig): AxiosPromise<UserModel> {
            return localVarFp.getUsersUser(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {Array<UserType>} [types] 
         * @param {UserSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsers(page?: number, size?: number, query?: string, types?: Array<UserType>, sort?: UserSort, order?: OrderOption, admin?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserModel>> {
            return localVarFp.getUsersUsers(page, size, query, types, sort, order, admin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {GroupSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getProfileGroups(identifier: string, page?: number, size?: number, query?: string, sort?: GroupSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getProfileGroups(identifier, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getProfileRepos(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getProfileRepos(identifier, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {OrderOption} [order] 
     * @param {FeedType} [type] 
     * @param {number} [before] 
     * @param {number} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersFeeds(identifier: string, page?: number, size?: number, order?: OrderOption, type?: FeedType, before?: number, after?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersFeeds(identifier, page, size, order, type, before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {string} repoRef 
     * @param {Permission} perm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersHasPerm(identifier: string, repoRef: string, perm: Permission, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersHasPerm(identifier, repoRef, perm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {number} [before] 
     * @param {number} [after] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersHeatmap(identifier: string, before?: number, after?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersHeatmap(identifier, before, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {RepoSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersStars(identifier: string, page?: number, size?: number, query?: string, sort?: RepoSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersStars(identifier, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifier GitBundle user id of the user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersUser(identifier: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersUser(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {Array<UserType>} [types] 
     * @param {UserSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersUsers(page?: number, size?: number, query?: string, types?: Array<UserType>, sort?: UserSort, order?: OrderOption, admin?: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersUsers(page, size, query, types, sort, order, admin, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (repoRef: string, webhookIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('deleteWebhook', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookIdentifier', webhookIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecution: async (repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getExecution', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('getExecution', 'webhookIdentifier', webhookIdentifier)
            // verify required parameter 'webhookExecutionId' is not null or undefined
            assertParamExists('getExecution', 'webhookExecutionId', webhookExecutionId)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}/executions/{webhook_execution_id}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)))
                .replace(`{${"webhook_execution_id"}}`, encodeURIComponent(String(webhookExecutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutions: async (repoRef: string, webhookIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getExecutions', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('getExecutions', 'webhookIdentifier', webhookIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}/executions`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (repoRef: string, webhookIdentifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getWebhook', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('getWebhook', 'webhookIdentifier', webhookIdentifier)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {WebhookSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: async (repoRef: string, page?: number, size?: number, query?: string, sort?: WebhookSort, order?: OrderOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('getWebhooks', 'repoRef', repoRef)
            const localVarPath = `/repos/{repo_ref}/+/webhooks`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {WebhookPatchInput} webhookPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWebhook: async (repoRef: string, webhookIdentifier: string, webhookPatchInput: WebhookPatchInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('patchWebhook', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('patchWebhook', 'webhookIdentifier', webhookIdentifier)
            // verify required parameter 'webhookPatchInput' is not null or undefined
            assertParamExists('patchWebhook', 'webhookPatchInput', webhookPatchInput)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookPatchInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRetrigger: async (repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postRetrigger', 'repoRef', repoRef)
            // verify required parameter 'webhookIdentifier' is not null or undefined
            assertParamExists('postRetrigger', 'webhookIdentifier', webhookIdentifier)
            // verify required parameter 'webhookExecutionId' is not null or undefined
            assertParamExists('postRetrigger', 'webhookExecutionId', webhookExecutionId)
            const localVarPath = `/repos/{repo_ref}/+/webhooks/{webhook_identifier}/executions/{webhook_execution_id}/retrigger`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)))
                .replace(`{${"webhook_identifier"}}`, encodeURIComponent(String(webhookIdentifier)))
                .replace(`{${"webhook_execution_id"}}`, encodeURIComponent(String(webhookExecutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {WebhookCreateInput} webhookCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook: async (repoRef: string, webhookCreateInput: WebhookCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoRef' is not null or undefined
            assertParamExists('postWebhook', 'repoRef', repoRef)
            // verify required parameter 'webhookCreateInput' is not null or undefined
            assertParamExists('postWebhook', 'webhookCreateInput', webhookCreateInput)
            const localVarPath = `/repos/{repo_ref}/+/webhooks`
                .replace(`{${"repo_ref"}}`, encodeURIComponent(String(repoRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication access_token_query required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(repoRef, webhookIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecution(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookExecutionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExecution(repoRef, webhookIdentifier, webhookExecutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getExecution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutions(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookExecutionModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExecutions(repoRef, webhookIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(repoRef, webhookIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {WebhookSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooks(repoRef: string, page?: number, size?: number, query?: string, sort?: WebhookSort, order?: OrderOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks(repoRef, page, size, query, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {WebhookPatchInput} webhookPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWebhook(repoRef: string, webhookIdentifier: string, webhookPatchInput: WebhookPatchInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchWebhook(repoRef, webhookIdentifier, webhookPatchInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.patchWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRetrigger(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookExecutionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRetrigger(repoRef, webhookIdentifier, webhookExecutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postRetrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {WebhookCreateInput} webhookCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhook(repoRef: string, webhookCreateInput: WebhookCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhook(repoRef, webhookCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhook(repoRef, webhookIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecution(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig): AxiosPromise<WebhookExecutionModel> {
            return localVarFp.getExecution(repoRef, webhookIdentifier, webhookExecutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutions(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookExecutionModel>> {
            return localVarFp.getExecutions(repoRef, webhookIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookModel> {
            return localVarFp.getWebhook(repoRef, webhookIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [query] 
         * @param {WebhookSort} [sort] 
         * @param {OrderOption} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(repoRef: string, page?: number, size?: number, query?: string, sort?: WebhookSort, order?: OrderOption, options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookModel>> {
            return localVarFp.getWebhooks(repoRef, page, size, query, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {WebhookPatchInput} webhookPatchInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWebhook(repoRef: string, webhookIdentifier: string, webhookPatchInput: WebhookPatchInput, options?: RawAxiosRequestConfig): AxiosPromise<WebhookModel> {
            return localVarFp.patchWebhook(repoRef, webhookIdentifier, webhookPatchInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {string} webhookIdentifier Webhook identifier
         * @param {number} webhookExecutionId Webhook execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRetrigger(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig): AxiosPromise<WebhookExecutionModel> {
            return localVarFp.postRetrigger(repoRef, webhookIdentifier, webhookExecutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoRef Repository id or ref
         * @param {WebhookCreateInput} webhookCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(repoRef: string, webhookCreateInput: WebhookCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<WebhookModel> {
            return localVarFp.postWebhook(repoRef, webhookCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(repoRef, webhookIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {number} webhookExecutionId Webhook execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getExecution(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getExecution(repoRef, webhookIdentifier, webhookExecutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getExecutions(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getExecutions(repoRef, webhookIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(repoRef: string, webhookIdentifier: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhook(repoRef, webhookIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [query] 
     * @param {WebhookSort} [sort] 
     * @param {OrderOption} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooks(repoRef: string, page?: number, size?: number, query?: string, sort?: WebhookSort, order?: OrderOption, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhooks(repoRef, page, size, query, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {WebhookPatchInput} webhookPatchInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public patchWebhook(repoRef: string, webhookIdentifier: string, webhookPatchInput: WebhookPatchInput, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).patchWebhook(repoRef, webhookIdentifier, webhookPatchInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {string} webhookIdentifier Webhook identifier
     * @param {number} webhookExecutionId Webhook execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postRetrigger(repoRef: string, webhookIdentifier: string, webhookExecutionId: number, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postRetrigger(repoRef, webhookIdentifier, webhookExecutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repoRef Repository id or ref
     * @param {WebhookCreateInput} webhookCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhook(repoRef: string, webhookCreateInput: WebhookCreateInput, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhook(repoRef, webhookCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



